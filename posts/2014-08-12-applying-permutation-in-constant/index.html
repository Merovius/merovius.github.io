<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Applying permutation in constant space (and linear time) | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="A mildly interesting algorithmic problem and my solution to it."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2014-08-12-applying-permutation-in-constant/><link crossorigin=anonymous href=/assets/css/stylesheet.9c4f5aa85dab72ee82fc33b8dfb12a3f7459e6c1b389f9fae73095efa3ecb4d6.css integrity="sha256-nE9aqF2rcu6C/DO437EqP3RZ5sGzifn65zCV76PstNY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Applying permutation in constant space (and linear time)"><meta property="og:description" content="A mildly interesting algorithmic problem and my solution to it."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2014-08-12-applying-permutation-in-constant/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-08-12T11:10:21+00:00"><meta property="article:modified_time" content="2014-08-12T11:10:21+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Applying permutation in constant space (and linear time)"><meta name=twitter:description content="A mildly interesting algorithmic problem and my solution to it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Applying permutation in constant space (and linear time)","item":"https://blog.merovius.de/posts/2014-08-12-applying-permutation-in-constant/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Applying permutation in constant space (and linear time)","name":"Applying permutation in constant space (and linear time)","description":"A mildly interesting algorithmic problem and my solution to it.","keywords":["golang","programming"],"articleBody":"I stumbled upon a mildly interesting problem yesterday: Given an Array a and a permutation p, apply the permutation (in place) to the Array, using only O(1) extra space. So, if b is the array after the algorithm, we want that a[i] == b[p[i]].\nNaively, we would solve our problem by doing something like this (I’m using go here):\nfunc Naive(vals, perm []int) { n := len(vals) res := make([]int, n) for i := range vals { res[perm[i]] = vals[i] } copy(vals, res) } This solves the problem in O(n) time, but it uses of course O(n) extra space for the result array. Note also, that it does not really work in place, we have to copy the result back.\nThe simplest iteration of this, would be to simply use a sorting-algorithm of our choice, but use as a sorting key not the value of the elements, but the position of the corresponding field in the permutation array:\nimport \"sort\" type PermSorter struct { vals []int perm []int } func (p PermSorter) Len() int { return len(p.vals) } func (p PermSorter) Less(i, j int) bool { return p.perm[i]  p.perm[j] } func (p PermSorter) Swap(i, j int) { p.vals[i], p.vals[j] = p.vals[j], p.vals[i] p.perm[i], p.perm[j] = p.perm[j], p.perm[i] } func Sort(vals, perm []int) { sort.Sort(PermSorter{vals, perm}) } This appears a promising idea at first, but as it turns out, this doesn’t really use constant space after all (at least not generally). The go sort package uses introsort internally, which is a combination of quick- and heapsort, the latter being chosen if the recursion-depth of quicksort exceeds a limit in O(log(n)). Thus it uses actually O(log(n)) auxiliary space. Also, the running time of sorting is O(n log(n)) and while time complexity wasn’t part of the initially posed problem, it would actually nice to have linear running time, if possible.\nNote also another point: The above implementation sorts perm, thus destroying the permutation array. Also not part of the original problem, this might pose problems if we want to apply the same permutation to multiple arrays. We can rectify that in this case by doing the following:\ntype NDPermSorter struct { vals []int perm []int } func (p NDPermSorter) Len() int { return len(p.vals) } func (p NDPermSorter) Less(i, j int) bool { return p.perm[p.vals[i]]  p.perm[p.vals[j]] } func (p NDPermSorter) Swap(i, j int) { p.vals[i], p.vals[j] = p.vals[j], p.vals[i] } func NDSort(vals, perm []int) { sort.Sort(NDPermSorter{vals, perm}) } But note, that this only works, because we want to sort an array of consecutive integers. In general, we don’t want to do that. And I am unaware of a solution that doesn’t have this problem (though I also didn’t think about it a lot).\nThe solution of solving this problem in linear time lies in a simple observation: If we start at any index and iteratively jump to the target index of the current one, we will trace out a cycle. If any index is not in the cycle, it will create another cycle and both cycles will be disjoint. For example the permutation\ni 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 p[i] 2 13 1 5 3 15 14 12 8 10 4 19 16 11 9 7 18 6 17 0 will create the following set of cycles: \nSo the idea is to resolve every cycle separately, by iterating over the indices and moving every element to the place it belongs:\nfunc Cycles(vals, perm []int) { for i := 0; i  len(vals); i++ { v, j := vals[i], perm[i] for j != i { vals[j], v = v, vals[j] perm[j], j = j, perm[j] } vals[i], perm[i] = v, i } } This obviously only needs O(1) space. The secret, why it also only uses O(n) time lies in the fact, that the inner loop will not be entered for elements, that are already at the correct position. Thus this is (from a complexity standpoint at least) the optimal solution to the problem, as it is impossible to use less than linear time for applying a permutation.\nThere is still one small problem with this solution: It also sorts the permutation array. We need this, to know when a position is already occupied by it’s final element. In our algorithm this is represented by the fact, that the permutation is equal to it’s index at that point. But really, it would be nice if we could mark the index without losing the order of the permutation. But that is not hard either - because every index is non-negative, we can simply negate every index we are done with. This will make a negative index out of it and we can check for that if we encounter it later and skip it in this case. After we are done, we only need to take care to flip everything back and all should be fine:\nfunc NDCycles(vals, perm []int) { for i := 0; i  len(vals); i++ { if perm[i]  0 { // already correct - unmark and go on \t// (note that ^a is the bitwise negation \tperm[i] = ^perm[i] continue } v, j := vals[i], perm[i] for j != i { vals[j], v = v, vals[j] // When we find this element in the future, we must not swap it any \t// further, so we mark it here \tperm[j], j = ^perm[j], perm[j] } vals[i] = v } } Here we only mark the elements we will again encounter in the future. The current index will always be unmarked, once we are done with the outer loop.\nI am aware, that this is technically cheating; This solution relies on the fact, that the upper-most bit of the permutation elements won’t ever be set. Thus, we actually do have O(n) auxiliary space (as in n bit), because these bits are not necessary for the algorithm. However, since it is pretty unlikely, that we will find an architecture where this is not possible (and go guarantees us that it actually is, because len(vals) is always signed, so we cant have arrays that are big enough for the msb being set anyway), I think I am okay with it ;)\nI ran sum Benchmarks on this an these are the figures I came up with:\n  n Naive NDCycle NDSort   10 332 ns 130 ns 1499 ns   100 883 ns 1019 ns 27187 ns   1000 15046 ns 17978 ns 473078 ns   10000 81800 ns 242121 ns 4659433 ns   I did not measure space-use. The time of NDCycle for 10000 elements seems suspicious - while it is not surprising, that in general it takes more time than the naive approach, due to it’s complexity, this jump is unexpected. Maybe if I have the time I will investigate this and also measure memory use. In the meantime, I uploaded all the code used here, so you can try it out yourself. You can run it with go run perm.go and run the benchmarks with go test -bench Benchmark.*.\n","wordCount":"1178","inLanguage":"en","datePublished":"2014-08-12T11:10:21Z","dateModified":"2014-08-12T11:10:21Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2014-08-12-applying-permutation-in-constant/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Applying permutation in constant space (and linear time)</h1><div class=post-meta><span title="2014-08-12 11:10:21 +0000 UTC">August 12, 2014</span></div></header><div class=post-content><p>I stumbled upon a mildly interesting problem yesterday: Given an Array a and a
permutation p, apply the permutation (in place) to the Array, using only O(1)
extra space. So, if b is the array after the algorithm, we want that
<code>a[i] == b[p[i]]</code>.</p><p>Naively, we would solve our problem by doing something like this (I&rsquo;m using go
here):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Naive</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>vals</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>vals</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span><span class=p>[</span><span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=p>=</span> <span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nb>copy</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This solves the problem in O(n) time, but it uses of course O(n) extra space
for the result array. Note also, that it does not really work in place, we have
to copy the result back.</p><p>The simplest iteration of this, would be to simply use a sorting-algorithm of
our choice, but use as a sorting key not the value of the elements, but the
position of the corresponding field in the permutation array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;sort&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PermSorter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>vals</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>PermSorter</span><span class=p>)</span> <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>PermSorter</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>PermSorter</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sort</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>PermSorter</span><span class=p>{</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This appears a promising idea at first, but as it turns out, this doesn&rsquo;t
<em>really</em> use constant space after all (at least not generally). The go sort
package uses introsort internally, which is a combination of quick- and
heapsort, the latter being chosen if the recursion-depth of quicksort exceeds a
limit in O(log(n)). Thus it uses actually O(log(n)) auxiliary space. Also, the
running time of sorting is O(n log(n)) and while time complexity wasn&rsquo;t part of
the initially posed problem, it would actually nice to have linear running
time, if possible.</p><p>Note also another point: The above implementation sorts perm, thus destroying
the permutation array. Also not part of the original problem, this might pose
problems if we want to apply the same permutation to multiple arrays. We can
rectify that in this case by doing the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NDPermSorter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>vals</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>NDPermSorter</span><span class=p>)</span> <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>NDPermSorter</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=p>&lt;</span> <span class=nx>p</span><span class=p>.</span><span class=nx>perm</span><span class=p>[</span><span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>NDPermSorter</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>p</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NDSort</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>NDPermSorter</span><span class=p>{</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But note, that this only works, because we want to sort an array of consecutive
integers. In general, we don&rsquo;t want to do that. And I am unaware of a solution
that doesn&rsquo;t have this problem (though I also didn&rsquo;t think about it a lot).</p><p>The solution of solving this problem in linear time lies in a simple
observation: If we start at any index and iteratively jump to the <em>target</em>
index of the current one, we will trace out a cycle. If any index is not in the
cycle, it will create another cycle and both cycles will be disjoint. For
example the permutation</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>i    0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19
</span></span><span class=line><span class=cl>p[i] 2  13 1  5  3  15 14 12 8  10 4  19 16 11 9  7  18 6  17 0
</span></span></code></pre></div><p>will create the following set of cycles:
<a href=/assets/permutation.svg><img src=/assets/permutation.svg></a></p><p>So the idea is to resolve every cycle separately, by iterating over the indices
and moving every element to the place it belongs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Cycles</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>vals</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>v</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>!=</span> <span class=nx>i</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>j</span> <span class=p>=</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This obviously only needs O(1) space. The secret, why it also only uses O(n)
time lies in the fact, that the inner loop will not be entered for elements,
that are already at the correct position. Thus this is (from a complexity
standpoint at least) the optimal solution to the problem, as it is impossible
to use <em>less</em> than linear time for applying a permutation.</p><p>There is still one small problem with this solution: It also sorts the
permutation array. We need this, to know when a position is already occupied by
it&rsquo;s final element. In our algorithm this is represented by the fact, that the
permutation is equal to it&rsquo;s index at that point. But really, it would be nice
if we could mark the index <em>without</em> losing the order of the permutation. But
that is not hard either - because every index is non-negative, we can
simply negate every index we are done with. This will make a negative index out
of it and we can check for that if we encounter it later and skip it in this
case. After we are done, we only need to take care to flip everything back and
all should be fine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NDCycles</span><span class=p>(</span><span class=nx>vals</span><span class=p>,</span> <span class=nx>perm</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>vals</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// already correct - unmark and go on
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// (note that ^a is the bitwise negation
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=p>^</span><span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>v</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>!=</span> <span class=nx>i</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>v</span> <span class=p>=</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>vals</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=c1>// When we find this element in the future, we must not swap it any
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// further, so we mark it here
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>j</span> <span class=p>=</span> <span class=p>^</span><span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>perm</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>vals</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here we only mark the elements we will again encounter in the <em>future</em>. The
current index will always be unmarked, once we are done with the outer loop.</p><p>I am aware, that this is technically cheating; This solution relies on the
fact, that the upper-most bit of the permutation elements won&rsquo;t ever be set.
Thus, we actually <em>do</em> have O(n) auxiliary space (as in n bit), because these
bits are not necessary for the algorithm. However, since it is pretty unlikely,
that we will find an architecture where this is not possible (and go guarantees
us that it actually is, because len(vals) is <em>always</em> signed, so we cant have
arrays that are big enough for the msb being set anyway), I think I am okay
with it ;)</p><p>I ran sum Benchmarks on this an these are the figures I came up with:</p><table><tr><th>n</th><th>Naive</th><th>NDCycle</th><th>NDSort</th></tr><tr><td>10</td><td>332 ns</td><td>130 ns</td><td>1499 ns</td></tr><tr><td>100</td><td>883 ns</td><td>1019 ns</td><td>27187 ns</td></tr><tr><td>1000</td><td>15046 ns</td><td>17978 ns</td><td>473078 ns</td></tr><tr><td>10000</td><td>81800 ns</td><td>242121 ns</td><td>4659433 ns</td></tr></table><p>I did not measure space-use. The time of NDCycle for 10000 elements seems
suspicious - while it is not surprising, that in general it takes more time
than the naive approach, due to it&rsquo;s complexity, this jump is unexpected. Maybe
if I have the time I will investigate this and also measure memory use. In the
meantime, I
<a href=https://gist.github.com/Merovius/9e31f4dc6a42a78c1942>uploaded</a> all the
code used here, so you can try it out yourself. You can run it with <code>go run perm.go</code> and run the benchmarks with <code>go test -bench Benchmark.*</code>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=/atom.xml target=_blank rel="noopener noreferrer me" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://www.tumblr.com/merovius target=_blank rel="noopener noreferrer me" title=Tumblr><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentcolor"><path d="M14.563 24c-5.093.0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941.0 9.999.0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>