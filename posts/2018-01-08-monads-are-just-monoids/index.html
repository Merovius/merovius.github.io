<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monads are just monoids in the category of endofunctors | Mero's Blog</title><meta name=keywords content="haskell,math,programming"><meta name=description content="I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory"><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/><link crossorigin=anonymous href=/assets/css/stylesheet.9c4f5aa85dab72ee82fc33b8dfb12a3f7459e6c1b389f9fae73095efa3ecb4d6.css integrity="sha256-nE9aqF2rcu6C/DO437EqP3RZ5sGzifn65zCV76PstNY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Monads are just monoids in the category of endofunctors"><meta property="og:description" content="I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-08T00:30:00+00:00"><meta property="article:modified_time" content="2018-01-08T00:30:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Monads are just monoids in the category of endofunctors"><meta name=twitter:description content="I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Monads are just monoids in the category of endofunctors","item":"https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Monads are just monoids in the category of endofunctors","name":"Monads are just monoids in the category of endofunctors","description":"I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory","keywords":["haskell","math","programming"],"articleBody":"tl;dr: I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory.\nThere is a running gag in the programming community, that newcomers will often be confused by the concept of monads (which is how sequential computations are modeled in purely functional languages) and getting the explanation “it is simple, really: Monads are just monoids in the category of endofunctors”. This is not meant as an actual explanation, but rather to poke a bit of fun at the habit of functional programmers to give quite abstract and theoretical explanations at times, that are not all that helpful.\nHowever, given my background in mathematics, I decided that I wanted to actually approach Haskell from this point of view: I am interested in how it uses math to model programming and also to, after several years of doing mostly engineering focused programming work, flex my math muscles again - as there is quite a bit of interesting math behind these concepts.\nThe quote is from a pretty popular book about category theory and is, in full:\n All told, a monad in \\(X\\) is just a monoid in the category of endofunctors of \\(X\\), with product \\(\\times\\) replaced by composition of endofunctors and unit set by the identity endofunctor.\n This, of course, is an explanation of the mathematical concept of monads, not meant for programmers. Most explanations of the quote that I found either assumed quite a bit of knowledge in Haskell or took a lot of liberties with the mathematical concepts (and relied a lot on “squinting”) or both. This write up is my attempt, to walk through all the concepts needed to explain monads as a mathematical concept and how it relates to Haskell - with as little squinting as possible.\nOf course, there are a couple of disclaimers, I should start with:\n This is not the best way to understand what monads are, if you are actually interested in using them to program. In fact, it is literally the worst way. I would recommend this intro, which takes a much more practical approach. This is not the best way to understand how category theory works, if you are actually interested in learning mathematics. In fact, it is literally the worst way. I would recommend the book the quote is from, it’s quite good (but assumes a math audience). I haven’t done mathematics in years. I also don’t know much Haskell either. So I might be getting a bunch of stuff wrong to varying degrees. I’m sure I will hear all about it :) Even if I would understand everything correctly, there are still a lot of details, mostly of technical nature, I had to omit, to keep this “short”. Not that it is short.  Originally, I intended this to be the ultimate explanation, which would teach Haskellers category theory, mathematicians Haskell and people who know neither both. Unsurprisingly, this is not what this is, at all. It ended up mostly a write up to assure myself that I understood the path myself. If anything, you can treat this as a kind of “reading companion”: If you want to understand this topic of the intersection between category theory and functional programming, this post can lead you through the correct terms to search for and give you a good idea what to focus on, in the respective Wikipedia articles.\nWith all that out of the way, let’s begin.\nCategories In mathematics, a category is (roughly) a collection of objects and a collection of arrows between them. There is not a lot of meaning behind these, but it will probably help you to think of objects as sets and arrows as mappings. Every arrow goes from an object (the domain) to an object (the codomain) and we write an arrow as \\(f:X\\to Y\\), where \\(f\\) is the name of the arrow, \\(X\\) is the domain and \\(Y\\) is the codomain. Just like with mappings, there can be many arrows between any given pair of objects - or there may be none.\nWe do need some restrictions: First, we require a specific identity arrow \\(\\mathrm{id}:X\\to X\\) attached to every object \\(X\\), which has \\(X\\) as both domain and codomain. Secondly, we require (some) arrows to be composable. That is if we have two arrows \\(f:X\\to Y,g:Y\\to Z\\) - so, whenever the domain of \\(g\\) is the codomain of \\(f\\) - there should also be a composed arrow1 \\(g\\circ f: X\\to Z\\), that shares the domain with \\(f\\) and the codomain with \\(g\\).\nFurthermore, the identity arrows must act as a unit for composition, that is, for every arrow \\(f\\) we require \\(\\mathrm{id}\\circ f = f = f \\circ\\mathrm{id}\\). We also require composition to be associative, that is \\((f\\circ g)\\circ h = f\\circ(g\\circ h)\\) (whenever all compositions exist)2.\nWhen we talk about a category, we often draw diagrams like this:\n \\[ \\require{AMScd} \\begin{CD} X @{f} Y \\\\ @V{g}VV @VV{p}V \\\\ Z @{q} W \\\\ \\end{CD} \\]  They show some of the objects and arrows from the category in a compact way. This particular diagram indicates that there are four objects and four arrows involved, with obvious domains and codomains. We only draw a subset of the objects and arrows, that is interesting for the point we are trying to make - for example, above diagram could also contain, of course, identity arrows and compositions \\(p\\circ f\\) and \\(q\\circ g\\)), but we didn’t draw them. In a square like this, we can take two paths from \\(X\\) to \\(W\\). If these paths are identical (that is, \\(p\\circ f = q\\circ g\\), we say that the square commutes. A commutative diagram is a diagram, in which any square commutes, that is, it does not matter which path we take from any object to another. Most of the time, when we draw a diagram, we intend it to be commutative.\nSo, to summarize, to define a mathematical category, we need to:\n Specify what our objects are Specify what our arrows are, where each arrow starts and ends at a certain object This collection of arrows need to include an arrow \\(\\mathrm{id}_X\\) for every object \\(X\\), which starts and ends at \\(X\\) And we need to be able to glue together arrows \\(f:X\\to Y\\) and \\(g:Y\\to Z\\) to an arrow \\(g\\circ f: X\\to Z\\)  In Haskell, we work on the category Hask, which consists of:\n The objects are types: Int is an object, String is an object but also Int | String, String - Int and any other complicated type you can think of. The arrows are functions: f :: a - b is a function taking an a as an input and returning a b and is represented by an arrow f, which has a as its domain and b as its codomain. So, for example, length :: String - Int would start at the type String and end at Int. Haskell has a function id :: a - a which gives us the identity arrow for any type a. We can compose functions with the operator (.) :: (b - c) - (a - b) - (a - c). Note, that this follows the swapped notation of \\(\\circ\\), where the input type of the left function is the output type of the right function.  In general, category theory is concerned with the relationship between categories, whereas in functional programming, we usually only deal with this one category. This turns out to be both a blessing and a curse: It means that our object of study is much simpler, but it also means, that it is sometimes hard to see how to apply the general concepts to the limited environment of functional programming.\nMonoids Understanding categories puts us in the position to understand monoids. A monoid is the generalized structure underlying concepts like the natural numbers: We can add two natural numbers, but we can’t (in general) subtract them, as there are no negative numbers. We also have the number \\(0\\), which, when added to any number, does nothing - it acts as a unit for addition. And we also observe, that addition is associative, that is, when doing a bunch of additions, the order we do them in doesn’t matter.\nThe same properties also apply to other constructs. For example, if we take all maps from a given set to itself, they can be composed and that composition is associative and there is a unit element (the identity map).\nThis provides us with the following elements to define a monoid:\n A set \\(M\\) An operation \\(\\star\\colon M\\times M\\to M\\), which “adds” together two elements to make a new one We need a special unit element \\(u\\in M\\), which acts neutrally when added to any other element, that is \\(m\\star u=m=u\\star m\\) The operation needs to be associative, that is we always require \\(m\\star(n\\star k)=(m\\star n)\\star k\\)  There is another way to frame this, which is closer in line with category theory. If we take \\(1 := \\{0\\}\\) to be a 1-element set, we can see that the elements of \\(M\\) are in a one-to-one correspondence to functions \\(1\\to M\\): Every such function chooses an element of \\(M\\) (the image of \\(0\\)) and every element \\(m\\in M\\) fixes such a function, by using \\(f(0) := m\\). Thus, instead of saying “we need a special element of \\(M\\)”, we can also choose a special function \\(\\eta: 1\\to M\\). And instead of talking about an “operation”, we can talk about a function \\(\\mu: M\\times M\\to M\\). Which means, we can define a monoid via a commutative diagram like so:\n \\[ \\begin{CD} 1 \\\\ @V{\\eta}VV \\\\ M \\\\ \\end{CD} \\hspace{1em} \\begin{CD} M\\times M \\\\ @V{\\mu}VV \\\\ M \\\\ \\end{CD} \\hspace{1em} \\begin{CD} M\\times 1 @{\\mathrm{id}\\times\\eta} M\\times M @{\\mathrm{id}} M @{\\mu\\times\\mathrm{id}} M\\times M \\\\ @V{\\mathrm{id}\\times\\mu}VV @V{\\mu}VV \\\\ M\\times M @{\\mu} M \\\\ \\end{CD} \\]  \\(\\pi_1\\) and \\(\\pi_2\\) here, are the functions that project to the first or second component of a cross product respectively (that is \\(\\pi_1(a, b) := a, \\pi_2(a, b) := b\\)) and e.g. \\(\\mathrm{id}\\times\\eta\\) is the map that applies \\(\\mathrm{id}\\) to the first component of a cross-product and \\(\\eta\\) to the second: \\(\\mathrm{id}\\times\\eta(m, 0) = (m, \\eta(0))\\).\nThere are four sub-diagrams here:\n The first diagram just says, that we need an arrow \\(\\eta:1\\to M\\). This chooses a unit element for us. Likewise, the second diagram just says, that we need an arrow \\(\\mu:M\\times M\\to M\\). This is the operation. The third diagram tells us that the chosen by \\(\\eta\\) should be a unit for \\(\\mu\\). The commutativity of the left square tells us, that it should be right-neutral, that is \\[ \\forall m\\in M: m = \\pi_1(m, 0) = \\mu(\\mathrm{id}\\times\\eta(m, 0)) = \\mu(m, \\eta(0)) \\] and the commutativity of the right square tells us, that it should be left-neutral, that is \\[ \\forall m\\in M: m = \\pi_2(0,m) = \\mu(\\eta\\times\\mathrm{id}(0, m)) = \\mu(\\eta(0), m) \\]  Thus, the first diagram is saying that the element chosen by \\(\\eta\\) should act like a unit. For example, the left square says\n\\[\\pi_1(m,0) = \\mu((\\mathrm{id}\\times\\eta)(m,0)) = \\mu(m,\\eta(0))\\]\nNow, writing \\(\\mu(m,n) = m\\star n\\) and \\(\\eta(0) = u\\), this is equivalent to saying \\(m = u\\star m\\).\nThe second diagram is saying that \\(\\mu\\) should be associative: The top arrow combines the first two elements, the left arrow combines the second two. The right and bottom arrows then combine the result with the remaining element respectively, so commutativity of that square means the familiar \\(m\\star (n\\star k) = (m\\star n)\\star k\\).\nHaskell has the concept of a monoid too. While it’s not really relevant to the discussion, it might be enlightening to see, how it’s modeled. A monoid in Haskell is a type-class with two (required) methods:\nclass Monoid a where mempty :: a mappend :: a - a - a Now, this gives us the operation (mappend) and the unit (a), but where are the requirements of associativity and the unit acting neutrally? The Haskell type system is unable to codify these requirements, so they are instead given as a “law”, that is, any implementation of a monoid is supposed to have these properties, to be manually checked by the programmer:\n mappend mempty x = x (the unit is left-neutral) mappend x mempty = x (the unit is right-neutral) mappend x (mappend y z) = mappend (mappend x y) z (the operation is associative)  Functors I mentioned that category theory investigates the relationship between categories - but so far, everything we’ve seen only happens inside a single category. Functors are, how we relate categories to each other. Given two categories \\(\\mathcal{B}\\) and \\(\\mathcal{C}\\), a functor \\(F:\\mathcal{B}\\to \\mathcal{C}\\) assigns to every object \\(X\\) of \\(\\mathcal{B}\\), an object \\(F(X)\\) of \\(\\mathcal{C}\\). It also assigns to every arrow \\(f:X\\to Y\\) in \\(\\mathcal{B}\\) a corresponding arrow \\(F(f): F(X)\\to F(Y)\\) in \\(\\mathcal{C}\\)3. So, a functor transfers arrows from one category to another, preserving domain and codomain. To actually preserve the structure, we also need it to preserve the extra requirements of a category, identities and composition. So we need, in total:\n An object map, \\(F:O_\\mathcal{B} \\to O_\\mathcal{C}\\) An arrow map, \\(F:A_\\mathcal{B}\\to A_\\mathcal{C}\\), which preserves start and end object, that is the image of an arrow \\(X\\to Y\\) starts at \\(F(X)\\) and ends at \\(F(Y)\\) The arrow map has to preserve identities, that is \\(F(\\mathrm{id}_X) = \\mathrm{id}_{F(X)}\\) The arrow map has to preserve composition, that is \\(F(g\\circ f) = F(g)\\circ F(f)\\).  A trivial example of a functor is the identity functor (which we will call \\(I\\)), which assigns each object to itself and each arrow to itself - that is, it doesn’t change the category at all.\nA simple example is the construction of the free monoid, which maps from the category of sets to the category of monoids. The Free monoid \\(S^*\\) on a set \\(S\\) is the set of all finite length strings of elements of \\(S\\), with concatenation as the operation and the empty string as the unit. Our object map then assigns to each set \\(S\\) its free monoid \\(S^*\\). And our arrow map assigns to each function \\(f:S\\to T\\) the function \\(f^*:S^*\\to T^*\\), that applies \\(f\\) to each element of the input string.\nThere is an interesting side note here: Mathematicians love to abstract. Categories arose from the observation, that in many branches of mathematics we are researching some class of objects with some associated structure and those maps between them, that preserve this structure. It turns out that category theory is a branch of mathematics that is researching the objects of categories, with some associated structure (identity arrows and composition) and maps (functors) between them, that preserve that structure. So it seems obvious that we should be able to view categories as objects of a category, with functors as arrows. Functors can be composed (in the obvious way) and every category has an identity functor, that just maps every object and arrow to itself.\nNow, in Haskell, Functors are again a type class:\nclass Functor f where fmap :: (a - b) - (f a - f b) This looks like our arrow map: It assigns to each function g :: a - b a function fmap g :: f a - f b. The object map is implicit: When we write f a, we are referring to a new type, that depends on a - so we “map” a to f a 4.\nAgain, there are additional requirements the type system of Haskell can not capture. So we provide them as laws the programmer has to check manually:\n fmap id == id (preserves identities) fmap (f . g) == fmap f . fmap g (preserves composition)  There is one thing to note here: As mentioned, in Haskell we only really deal with one category, the category of types. That means that a functor always maps from the category of types to itself. In mathematics, we call such a functor, that maps a category to itself, an endofunctor. So we can tell, that in Haskell, every functor is automatically an endofunctor.\nNatural transformations We now understand categories and we understand functors. We also understand, that we can look at something like the category of categories. But the definition of a monad given to us talks about the category of endofunctors. So we seem to have to step up yet another level in the abstraction hierarchy and somehow build this category. As objects, we’d like to have endofunctors - and arrows will be natural transformations, which take one functor to another, while preserving its internal structure (the mapping of arrows). If that sounds complicated and abstract, that’s because it is.\nWe need two functors \\(F,G:\\mathcal{B}\\to \\mathcal{C}\\) of the same “kind” (that is, mapping to and from the same categories). A natural transformation \\(\\eta:F\\dot\\to G\\) assigns an arrow5 \\(\\eta_X: F(X)\\to G(X)\\) (called a component of \\(\\eta\\)) to every object in \\(\\mathcal{B}\\). So a component \\(\\eta_X\\) describes, how we can translate the action of \\(F\\) on \\(X\\) into the action of \\(G\\) on \\(X\\) - i.e. how to translate their object maps. We also have to talk about the translation of the arrow maps. For that, we observe that for any arrow \\(f:X\\to Y\\) in \\(\\mathcal{B}\\), we get four new arrows in \\(\\mathcal{C}\\):\n \\[ \\begin{CD} X \\\\ @V{f}VV \\\\ Y \\\\ \\end{CD} \\hspace{1em} \\begin{CD} F(X) @{\\eta_X} G(X) \\\\ @V{F(f)}VV @VV{G(f)}V \\\\ F(Y) @{\\eta_Y} G(Y) \\\\ \\end{CD} \\]  For a natural transformation, we require the resulting square to commute.\nSo, to recap: To create a natural transformation, we need\n Two functors \\(F,G:\\mathcal{B}\\to\\mathcal{C}\\) For every object \\(X\\) in \\(\\mathcal{B}\\), an arrow \\(\\eta_X: F(X)\\to G(X)\\) The components need to be compatible with the arrow maps of the functors: \\(\\eta_Y\\circ F(f) = G(f)\\circ \\eta_X\\).  In Haskell, we can define a natural transformation like so:\nclass (Functor f, Functor g) = Transformation f g where eta :: f a - g a f and g are functors and a natural transformation from f to g provides a map f a - g a for every type a. Again, the requirement of compatibility with the actions of the functors is not expressible as a type signature, but we can require it as a law:\n eta (fmap fn a) = fmap fn (eta a)  Monads This, finally, puts us in the position to define monads. Let’s look at our quote above:\n All told, a monad in \\(X\\) is just a monoid in the category of endofunctors of \\(X\\), with product \\(\\times\\) replaced by composition of endofunctors and unit set by the identity endofunctor.\n It should be clear, how we can compose endofunctors. But it is important, that this is a different view of these things than if we’d look at the category of categories - there, objects are categories and functors are arrows, while here, objects are functors and arrows are natural transformations. That shows, how composition of functors can take the role of the cross-product of sets: In a set-category, the cross product makes a new set out of two other set. In the category of endofunctors, composition makes a new endofunctor out of two other endofunctors.\nWhen we defined monoids diagrammatically, we also needed a cross product of mappings, that is, given a map \\(f:X_1\\to Y_1\\) and a map \\(g:X_2\\to Y_2\\), we needed the map \\(f\\times g: X_1\\times X_2\\to Y_1\\times Y_2\\), which operated on the individual constituents. If we want to replace the cross product with composition of endofunctors, we need an equivalent for natural transformations. That is, given two natural transformations \\(\\eta:F\\to G\\) and \\(\\epsilon:J\\to K\\), we want to construct a natural transformation \\(\\eta\\epsilon:J\\circ F\\to K\\circ G\\). This diagram illustrates how we get there (working on components):\n \\[ \\begin{CD} F(X) @{\\eta_X} G(X) @. \\\\ @V{J}VV @VV{J}V @. \\\\ J(F(X)) @{J(\\eta_X)} J(G(X)) @{\\epsilon_{G(X)}} K(G(X)) \\\\ \\end{CD} \\]  As we can see, we can build an arrow \\(\\epsilon_{G(X)}\\circ J(\\eta_X): J(F(X)) \\to K(G(X))\\), which we can use as the components of our natural transformation \\(\\eta\\epsilon:J\\circ F\\to K\\circ G\\). This construction is called the horizontal composition of natural transformations. We should verify that this is indeed a natural transformation - for now, let’s just accept that it follows from the naturality of \\(\\eta\\) and \\(\\epsilon\\).\nLastly, there is an obvious natural transformation taking a functor to itself; each component being just the identity arrow. We call that natural transformation \\(\\iota\\), staying with the convention of using Greek letters for natural transformations.\nWith this, we can redraw the diagram we used to define monoids above, the replacements indicated by the quotes:\n \\[ \\begin{CD} I \\\\ @V{\\eta}VV \\\\ M \\\\ \\end{CD} \\hspace{1em} \\begin{CD} M\\circ M \\\\ @V{\\mu}VV \\\\ M \\\\ \\end{CD} \\hspace{1em} \\begin{CD} M\\circ I @{\\iota\\ \\eta} M\\circ M @{\\iota} M @{\\mu\\ \\iota} M\\circ M \\\\ @V{\\iota\\ \\mu}VV @V{\\mu}VV \\\\ M\\circ M @{\\mu} M \\\\ \\end{CD} \\]  The vertical arrows in the middle diagram now simply apply the composition of functors, using that the identity functor is a unit.\nThese diagrams encode these conditions on our natural transformations6:\n \\(\\mu\\circ\\eta\\iota = \\mu = \\iota\\eta\\circ\\mu\\), that is \\(\\eta\\) serves as a unit \\(\\mu\\circ\\mu\\iota = \\mu\\circ\\iota\\mu\\), that is \\(\\mu\\) is associative  To recap, a monad, in category theory, is\n An endofunctor \\(M\\) A natural transformation \\(\\eta: I\\to M\\), which serves as an identity for horizontal composition. A natural transformation \\(\\mu: M\\circ M\\to M\\), which is associative in respect to horizontal composition.  Now, let’s see, how this maps to Haskell monads.\nFirst, what is the identity functor in Haskell? As we pointed out above, the object function of functors is implicit, when we write f a instead of a. As such, the identity functor is simply a - i.e. we map any type to itself. fmap of that functor would thus also just be the identity fmap :: (a - a) - (a - a).\nSo, what would our natural transformation \\(\\eta\\) look like? As we said, a natural transformation between two functors is just a map f a - g a. So (if we call our endofunctor m) the identity transformation of our monoid is eta :: a - m a mapping the identity functor to m. We also need our monoidal operation, which should map m applied twice to m: mu :: m (m a) - m a.\nNow, Haskellers write return instead of eta and write join instead of mu, giving us the type class7\nclass (Functor m) = Monad where return :: a - m a join :: m (m a) - m a As a last note, it is worth pointing out that you usually won’t implement join, but instead a different function, called “monadic bind”:\n(=) :: m a - (a - m b) - m b The reason is, that this more closely maps to what monads are actually used for in functional programming. But we can move between join and = via\n(=) :: m a - (a - m b) - m b v = f = join ((fmap f) v) join :: m (m a) - m a join v = v = id Conclusion This certainly was a bit of a long ride. It took me much longer than anticipated both to understand all the steps necessary and to write them down. I hope you found it helpful and I hope I didn’t make too many, too glaring mistakes. If so (either), feel free to let me know on Twitter, reddit or Hacker News - but please remember to be kind :)\nI want to thank Tim Adler and mxf+ for proof-reading this absurdly long post and for making many helpful suggestions for improvements\n The fact that we are not doing that is a completely justified criticism, that is due to a historical accident - we write function application from right to left, that is we write \\(f(x)\\), for applying \\(f\\) to \\(x\\). Accordingly, we write \\(g(f(x))\\), when applying \\(g\\) to the result of applying \\(f\\) to \\(x\\). And we chose to have the composite-notation be consistent with that, instead of the arrow-notation.\nI chose to just eat the unfortunate confusion, as it turns out Haskell is doing exactly the same thing, so swapping things around would just increase the confusion.\nSorry.\nWhat was that? Oh, you thought Mathematicians where precise? Ha!\nThis is one of the things that was tripping me up for a while: I was trying to figure out, how I would map types to other types in Haskell or even talk about the object map. But the most useful answer is “you don’t”.\n   It is often confusing to people, that the way the arrows point in the notation and the order they are written seems to contradict each other: When writing \\(f:X\\to Y\\) and \\(g:Y\\to Z\\) you might reasonably expect their composite to work like \\(f\\circ g: X\\to Z\\), that is, you glue together the arrows in the order you are writing them. ↩︎\n Keep in mind that this is a different notion from the ones for monoids, which we come to a bit later: While the formulas seem the same and the identities look like a unit, the difference is that only certain arrows can be composed, not all. And that there are many identity arrows, not just one. However, if we would have only one object, it would have to be the domain and codomain of every arrow and there would be exactly one identity arrow. In that case, the notions would be the same and indeed, “a category with exactly one object” is yet another way to define monoids. ↩︎\n It is customary, to use the same name for the object and arrow map, even though that may seem confusing. A slight justification of that would be, that the object map is already given by the arrow map anyway: If \\(F\\) is the arrow map, we can define the object map as \\(X\\mapsto \\mathrm{dom}(F(\\mathrm{id}_X))\\). So, given that they are always occurring together and you can make one from the other, we tend to just drop the distinction and save some symbols. ↩︎\n It is important to note, that this is not really a function. Functions operate on values of a given type. But here, we are operating on types and Haskell has no concept of a “type of types” built in that a function could operate on. There are constructs operating on types to construct new types, like data, type, newtype or even deriving. But they are special syntactical constructs that exist outside of the realm of functions. ↩︎\n An important note here, is that the \\(\\eta_X\\) are arrows. Where the object map of a functor is just a general association which could look anything we like, the components of a natural transformation need to preserve the internal structure of the category we are working in. ↩︎\n You will often see these conditions written differently, namely written e.g. \\(\\mu M\\) instead of \\(\\mu\\iota\\). You can treat that as a notational shorthand, it really means the same thing. ↩︎\n There is a technicality here, that Haskell also has an intermediate between functor and monad called “applicative”. As I understand it, this does not have a clear category theoretical analogue. I’m not sure why it exits, but I believe it has been added into the hierarchy after the fact. ↩︎\n   ","wordCount":"4518","inLanguage":"en","datePublished":"2018-01-08T00:30:00Z","dateModified":"2018-01-08T00:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Monads are just monoids in the category of endofunctors</h1><div class=post-meta><span title="2018-01-08 00:30:00 +0000 UTC">January 8, 2018</span></div></header><div class=post-content><p><strong>tl;dr: I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory.</strong></p><p>There is a running gag in the programming community, that newcomers will often
be confused by the concept of monads (which is how sequential computations are
modeled in purely functional languages) and getting the explanation &ldquo;it is
simple, really: Monads are just monoids in the category of endofunctors&rdquo;. This
is not meant as an actual explanation, but rather to poke a bit of fun at the
habit of functional programmers to give quite abstract and theoretical
explanations at times, that are not all that helpful.</p><p>However, given my background in mathematics, I decided that I wanted to
actually approach Haskell from this point of view: I am interested in how it
uses math to model programming and also to, after several years of doing mostly
engineering focused programming work, flex my math muscles again - as there is
quite a bit of interesting math behind these concepts.</p><p>The quote is from a pretty popular <a href=http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf>book about category
theory</a> and is, in full:</p><blockquote><p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p></blockquote><p>This, of course, is an explanation of the <em>mathematical</em> concept of monads,
not meant for programmers. Most explanations of the quote that I found either
assumed quite a bit of knowledge in Haskell or took a lot of liberties with the
mathematical concepts (and relied a lot on &ldquo;squinting&rdquo;) or both. This write up
is my attempt, to walk through all the concepts needed to explain monads as a
mathematical concept and how it relates to Haskell - with as little squinting
as possible.</p><p>Of course, there are a couple of disclaimers, I should start with:</p><ol><li>This is not the best way to understand what monads are, if you are actually
interested in using them to program. In fact, it is literally the worst way.
I would recommend <a href=http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf>this intro</a>,
which takes a much more practical approach.</li><li>This is not the best way to understand how category theory works, if you are
actually interested in learning mathematics. In fact, it is literally the
worst way. I would recommend <a href=http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf>the book the quote is from</a>,
it&rsquo;s quite good (but assumes a math audience).</li><li>I haven&rsquo;t done mathematics in years. I also don&rsquo;t know much Haskell either.
So I might be getting a bunch of stuff wrong to varying degrees. I&rsquo;m sure I
will hear all about it :)</li><li>Even if I would <em>understand</em> everything correctly, there are still a lot of
details, mostly of technical nature, I had to omit, to keep this &ldquo;short&rdquo;.
Not that it is short.</li></ol><p>Originally, I intended this to be the ultimate explanation, which would teach
Haskellers category theory, mathematicians Haskell and people who know neither
both. Unsurprisingly, this is not what this is, at all. It ended up mostly a
write up to assure myself that I understood the path myself. If anything, you
can treat this as a kind of &ldquo;reading companion&rdquo;: If you want to understand this
topic of the intersection between category theory and functional programming,
this post can lead you through the correct terms to search for and give you a
good idea what to focus on, in the respective Wikipedia articles.</p><p>With all that out of the way, let&rsquo;s begin.</p><h2 id=categories>Categories<a hidden class=anchor aria-hidden=true href=#categories>#</a></h2><p>In mathematics, a category is (roughly) a collection of objects and a
collection of arrows between them. There is not a lot of meaning behind these,
but it will probably help you to think of objects as sets and arrows as
mappings. Every arrow goes from an object (the <em>domain</em>) to an object (the
<em>codomain</em>) and we write an arrow as \(f:X\to Y\), where \(f\) is the name
of the arrow, \(X\) is the domain and \(Y\) is the codomain. Just like with
mappings, there can be many arrows between any given pair of objects - or there
may be none.</p><p>We do need <em>some</em> restrictions: First, we require a specific <em>identity</em> arrow
\(\mathrm{id}:X\to X\) attached to every object \(X\), which has \(X\) as
both domain and codomain. Secondly, we require (some) arrows to be
<em>composable</em>. That is if we have two arrows \(f:X\to Y,g:Y\to Z\) - so,
whenever the domain of \(g\) is the codomain of \(f\) - there should also
be a composed arrow<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>
\(g\circ f: X\to Z\), that shares the domain with \(f\) and the codomain with
\(g\).</p><p>Furthermore, the identity arrows must act as a <em>unit</em> for composition, that is,
for every arrow \(f\) we require \(\mathrm{id}\circ f = f = f
\circ\mathrm{id}\). We also require composition to be <em>associative</em>, that is
\((f\circ g)\circ h = f\circ(g\circ h)\) (whenever all compositions exist)<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>When we talk about a category, we often draw diagrams like this:</p><div>\[
\require{AMScd}
\begin{CD}
X @>{f}>> Y \\
@V{g}VV @VV{p}V \\
Z @>>{q}> W \\
\end{CD}
\]</div><p>They show some of the objects and arrows from the category in a compact way.
This particular diagram indicates that there are four objects and four arrows
involved, with obvious domains and codomains. We only draw a subset of the
objects and arrows, that is interesting for the point we are trying to make -
for example, above diagram could also contain, of course, identity arrows and
compositions \(p\circ f\) and \(q\circ g\)), but we didn&rsquo;t draw them. In
a square like this, we can take two paths from \(X\) to \(W\). If these
paths are identical (that is, \(p\circ f = q\circ g\), we say that the
square <em>commutes</em>. A <em>commutative</em> diagram is a diagram, in which any square
commutes, that is, it does not matter which path we take from any object to
another. Most of the time, when we draw a diagram, we intend it to be
commutative.</p><p>So, to summarize, to define a mathematical category, we need to:</p><ol><li>Specify what our objects are</li><li>Specify what our arrows are, where each arrow starts and ends at a certain
object</li><li>This collection of arrows need to include an arrow \(\mathrm{id}_X\) for
every object \(X\), which starts and ends at \(X\)</li><li>And we need to be able to glue together arrows \(f:X\to Y\) and \(g:Y\to
Z\) to an arrow \(g\circ f: X\to Z\)</li></ol><p>In Haskell, we work on the category <strong>Hask</strong>, which consists of:</p><ol><li>The objects are <em>types</em>: <code>Int</code> is an object, <code>String</code> is an object but also
<code>Int | String</code>, <code>String -> Int</code> and any other complicated type you can think
of.</li><li>The arrows are <em>functions</em>: <code>f :: a -> b</code> is a function taking an <code>a</code> as an
input and returning a <code>b</code> and is represented by an arrow <code>f</code>, which has <code>a</code>
as its domain and <code>b</code> as its codomain. So, for example, <code>length :: String -> Int</code> would start at the type <code>String</code> and end at <code>Int</code>.</li><li>Haskell has a function <code>id :: a -> a</code> which gives us the identity arrow
for any type <code>a</code>.</li><li>We can compose functions with the operator <code>(.) :: (b -> c) -> (a -> b) -> (a -> c)</code>. Note, that this follows the swapped notation of \(\circ\), where
the input type of the left function is the output type of the right function.</li></ol><p>In general, category theory is concerned with the <em>relationship between</em>
categories, whereas in functional programming, we usually only deal with this
one category. This turns out to be both a blessing and a curse: It means that
our object of study is much simpler, but it also means, that it is sometimes
hard to see how to apply the general concepts to the limited environment of
functional programming.</p><h2 id=monoids>Monoids<a hidden class=anchor aria-hidden=true href=#monoids>#</a></h2><p>Understanding categories puts us in the position to understand <em>monoids</em>. A
monoid is the generalized structure underlying concepts like the natural
numbers: We can <em>add</em> two natural numbers, but we can&rsquo;t (in general) <em>subtract</em>
them, as there are no negative numbers. We also have the number \(0\), which,
when added to any number, does nothing - it acts as a <em>unit</em> for addition. And
we also observe, that addition is <em>associative</em>, that is, when doing a bunch of
additions, the order we do them in doesn&rsquo;t matter.</p><p>The same properties also apply to other constructs. For example, if we take all
maps from a given set to itself, they can be composed and that composition is
associative and there is a unit element (the identity map).</p><p>This provides us with the following elements to define a monoid:</p><ol><li>A set \(M\)</li><li>An operation \(\star\colon M\times M\to M\), which &ldquo;adds&rdquo; together two elements to
make a new one</li><li>We need a special unit element \(u\in M\), which acts neutrally when added to
any other element, that is \(m\star u=m=u\star m\)</li><li>The operation needs to be associative, that is we always require
\(m\star(n\star k)=(m\star n)\star k\)</li></ol><p>There is another way to frame this, which is closer in line with category theory.
If we take \(1 := \{0\}\) to be a 1-element set, we can see that the
elements of \(M\) are in a one-to-one correspondence to functions \(1\to M\):
Every such function chooses an element of \(M\) (the image of \(0\)) and
every element \(m\in M\) fixes such a function, by using \(f(0) := m\).
Thus, instead of saying &ldquo;we need a special element of \(M\)&rdquo;, we can also
choose a special <em>function</em> \(\eta: 1\to M\). And instead of talking about an
&ldquo;operation&rdquo;, we can talk about a function \(\mu: M\times M\to M\). Which
means, we can define a monoid via a commutative diagram like so:</p><div>\[
\begin{CD}
1 \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times 1 @>{\mathrm{id}\times\eta}>> M\times M @<{\eta\times\mathrm{id}}<< 1\times M \\
@V{\pi_1}VV @V{\mu}VV @V{\pi_2}VV \\
M @>{\mathrm{id}}>> M @<{\mathrm{id}}<< M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M\times M @>{\mu\times\mathrm{id}}>> M\times M \\
@V{\mathrm{id}\times\mu}VV @V{\mu}VV \\
M\times M @>{\mu}>> M \\
\end{CD}
\]</div><p>\(\pi_1\) and \(\pi_2\) here, are the functions that project to the first
or second component of a cross product respectively (that is \(\pi_1(a, b) :=
a, \pi_2(a, b) := b\)) and e.g. \(\mathrm{id}\times\eta\) is the map that
applies \(\mathrm{id}\) to the first component of a cross-product and
\(\eta\) to the second: \(\mathrm{id}\times\eta(m, 0) = (m, \eta(0))\).</p><p>There are four sub-diagrams here:</p><ol><li>The first diagram just says, that we need an arrow \(\eta:1\to M\). This
chooses a unit element for us.</li><li>Likewise, the second diagram just says, that we need an arrow
\(\mu:M\times M\to M\). This is the operation.</li><li>The third diagram tells us that the chosen by \(\eta\) should be a unit
for \(\mu\). The commutativity of the left square tells us, that it should
be right-neutral, that is
\[ \forall m\in M: m = \pi_1(m, 0) = \mu(\mathrm{id}\times\eta(m, 0)) = \mu(m, \eta(0)) \]
and the commutativity of the right square tells us, that it should be left-neutral, that is
\[ \forall m\in M: m = \pi_2(0,m) = \mu(\eta\times\mathrm{id}(0, m)) = \mu(\eta(0), m) \]</li></ol><p>Thus, the first diagram is saying that the element chosen by \(\eta\) should
act like a unit. For example, the left square says</p><p>\[\pi_1(m,0) = \mu((\mathrm{id}\times\eta)(m,0)) = \mu(m,\eta(0))\]</p><p>Now, writing \(\mu(m,n) = m\star n\) and \(\eta(0) = u\), this is equivalent to saying \(m = u\star m\).</p><p>The second diagram is saying that \(\mu\) should be associative: The top arrow
combines the first two elements, the left arrow combines the second two. The right and
bottom arrows then combine the result with the remaining element respectively,
so commutativity of that square means the familiar \(m\star (n\star k) = (m\star n)\star k\).</p><p>Haskell has the concept of a monoid too. While it&rsquo;s not really relevant to the
discussion, it might be enlightening to see, how it&rsquo;s modeled. A monoid in
Haskell is a type-class with two (required) methods:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=kt>Monoid</span> <span class=n>a</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>mempty</span> <span class=ow>::</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=n>mappend</span> <span class=ow>::</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span></code></pre></div><p>Now, this gives us the operation (<code>mappend</code>) and the unit (<code>a</code>), but where are
the requirements of associativity and the unit acting neutrally? The Haskell
type system is unable to codify these requirements, so they are instead given
as a &ldquo;law&rdquo;, that is, any implementation of a monoid is supposed to have these
properties, to be manually checked by the programmer:</p><ul><li><code>mappend mempty x = x</code> (the unit is left-neutral)</li><li><code>mappend x mempty = x</code> (the unit is right-neutral)</li><li><code>mappend x (mappend y z) = mappend (mappend x y) z</code> (the operation is associative)</li></ul><h2 id=functors>Functors<a hidden class=anchor aria-hidden=true href=#functors>#</a></h2><p>I mentioned that category theory investigates the relationship between
categories - but so far, everything we&rsquo;ve seen only happens inside a single
category. Functors are, how we relate categories to each other. Given two
categories \(\mathcal{B}\) and \(\mathcal{C}\), a <em>functor</em>
\(F:\mathcal{B}\to \mathcal{C}\) assigns to every object \(X\) of
\(\mathcal{B}\), an object \(F(X)\) of \(\mathcal{C}\). It also assigns
to every arrow \(f:X\to Y\) in \(\mathcal{B}\) a corresponding arrow
\(F(f): F(X)\to F(Y)\) in \(\mathcal{C}\)<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. So, a functor transfers
arrows from one category to another, preserving domain and codomain. To
actually preserve the structure, we also need it to preserve the extra requirements
of a category, identities and composition. So we need, in total:</p><ol><li>An object map, \(F:O_\mathcal{B} \to O_\mathcal{C}\)</li><li>An arrow map, \(F:A_\mathcal{B}\to A_\mathcal{C}\), which preserves
start and end object, that is the image of an arrow \(X\to Y\) starts at
\(F(X)\) and ends at \(F(Y)\)</li><li>The arrow map has to preserve identities, that is \(F(\mathrm{id}_X) =
\mathrm{id}_{F(X)}\)</li><li>The arrow map has to preserve composition, that is \(F(g\circ f) =
F(g)\circ F(f)\).</li></ol><p>A trivial example of a functor is the <em>identity functor</em> (which we will call
\(I\)), which assigns each object to itself and each arrow to itself - that
is, it doesn&rsquo;t change the category at all.</p><p>A simple example is the construction of the <em>free monoid</em>, which maps from the
category of sets to the category of monoids. The Free monoid \(S^*\) on a
set \(S\) is the set of all finite length strings of elements of \(S\),
with concatenation as the operation and the empty string as the unit. Our
object map then assigns to each set \(S\) its free monoid \(S^*\). And our
arrow map assigns to each function \(f:S\to T\) the function \(f^*:S^*\to
T^*\), that applies \(f\) to each element of the input string.</p><p>There is an interesting side note here: Mathematicians love to abstract.
Categories arose from the observation, that in many branches of mathematics we
are researching some class of objects with some associated structure and those
maps between them, that preserve this structure. It turns out that category
theory is a branch of mathematics that is researching the objects of
categories, with some associated structure (identity arrows and composition)
and maps (functors) between them, that preserve that structure. So it seems
obvious that we should be able to view categories <em>as objects of a category</em>,
with functors as arrows. Functors can be composed (in the obvious way) and
every category has an identity functor, that just maps every object and arrow
to itself.</p><p>Now, in Haskell, Functors are again a type class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>fmap</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span>
</span></span></code></pre></div><p>This looks like our arrow map: It assigns to each function <code>g :: a -> b</code> a
function <code>fmap g :: f a -> f b</code>. The object map is implicit: When we write <code>f a</code>,
we are referring to a new type, that depends on <code>a</code> - so we &ldquo;map&rdquo; <code>a</code> to <code>f a</code>
<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>Again, there are additional requirements the type system of Haskell can not
capture. So we provide them as laws the programmer has to check manually:</p><ul><li><code>fmap id == id</code> (preserves identities)</li><li><code>fmap (f . g) == fmap f . fmap g</code> (preserves composition)</li></ul><p>There is one thing to note here: As mentioned, in Haskell we only really deal
with one category, the category of types. That means that a functor always maps
from the category of types to <em>itself</em>. In mathematics, we call such a functor,
that maps a category to itself, an <em>endofunctor</em>. So we can tell, that in
Haskell, every functor is automatically an endofunctor.</p><h2 id=natural-transformations>Natural transformations<a hidden class=anchor aria-hidden=true href=#natural-transformations>#</a></h2><p>We now understand categories and we understand functors. We also understand,
that we can look at something like the category of categories. But the
definition of a monad given to us talks about the <em>category of endofunctors</em>.
So we seem to have to step up yet another level in the abstraction hierarchy
and somehow build this category. As objects, we&rsquo;d like to have endofunctors -
and arrows will be <em>natural transformations</em>, which take one functor to
another, while preserving its internal structure (the mapping of arrows). If
that sounds complicated and abstract, that&rsquo;s because it is.</p><p>We need two functors \(F,G:\mathcal{B}\to \mathcal{C}\) of the same &ldquo;kind&rdquo;
(that is, mapping to and from the same categories). A natural transformation
\(\eta:F\dot\to G\) assigns an arrow<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> \(\eta_X: F(X)\to G(X)\) (called
a <em>component</em> of \(\eta\)) to every object in \(\mathcal{B}\). So a component
\(\eta_X\) describes, how we can translate the action of \(F\) on \(X\)
into the action of \(G\) on \(X\) - i.e. how to translate their object maps.
We also have to talk about the translation of the arrow maps. For that, we observe
that for any arrow \(f:X\to Y\) in \(\mathcal{B}\), we get four new arrows in
\(\mathcal{C}\):</p><div>\[
\begin{CD}
X \\
@V{f}VV \\
Y \\
\end{CD}
\hspace{1em}
\begin{CD}
F(X) @>{\eta_X}>> G(X) \\
@V{F(f)}VV @VV{G(f)}V \\
F(Y) @>>{\eta_Y}> G(Y) \\
\end{CD}
\]</div><p>For a natural transformation, we require the resulting square to commute.</p><p>So, to recap: To create a natural transformation, we need</p><ol><li>Two functors \(F,G:\mathcal{B}\to\mathcal{C}\)</li><li>For every object \(X\) in \(\mathcal{B}\), an arrow \(\eta_X: F(X)\to
G(X)\)</li><li>The components need to be compatible with the arrow maps of the functors:
\(\eta_Y\circ F(f) = G(f)\circ \eta_X\).</li></ol><p>In Haskell, we can define a natural transformation like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Functor</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Transformation</span> <span class=n>f</span> <span class=n>g</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>    <span class=n>eta</span> <span class=ow>::</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>g</span> <span class=n>a</span>
</span></span></code></pre></div><p><code>f</code> and <code>g</code> are functors and a natural transformation from <code>f</code> to <code>g</code> provides
a map <code>f a -> g a</code> for every type <code>a</code>. Again, the requirement of compatibility
with the actions of the functors is not expressible as a type signature, but we
can require it as a law:</p><ul><li><code>eta (fmap fn a) = fmap fn (eta a)</code></li></ul><h2 id=monads>Monads<a hidden class=anchor aria-hidden=true href=#monads>#</a></h2><p>This, finally, puts us in the position to define monads. Let&rsquo;s look at our quote above:</p><blockquote><p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p></blockquote><p>It should be clear, how we can <em>compose</em> endofunctors. But it is important,
that this is a different view of these things than if we&rsquo;d look at the category
of categories - there, objects are categories and functors are arrows, while
here, objects are <em>functors</em> and arrows are natural transformations. That
shows, how composition of functors can take the role of the cross-product of
sets: In a set-category, the cross product makes a new set out of two other
set. In the category of endofunctors, composition makes a new endofunctor out
of two other endofunctors.</p><p>When we defined monoids diagrammatically, we also needed a cross product of
mappings, that is, given a map \(f:X_1\to Y_1\) and a map \(g:X_2\to
Y_2\), we needed the map \(f\times g: X_1\times X_2\to Y_1\times
Y_2\), which operated on the individual constituents. If we want to replace
the cross product with composition of endofunctors, we need an equivalent for
natural transformations. That is, given two natural transformations
\(\eta:F\to G\) and \(\epsilon:J\to K\), we want to construct a natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This diagram
illustrates how we get there (working on components):</p><div>\[
\begin{CD}
F(X) @>{\eta_X}>> G(X) @. \\
@V{J}VV @VV{J}V @. \\
J(F(X)) @>{J(\eta_X)}>> J(G(X)) @>{\epsilon_{G(X)}}>> K(G(X)) \\
\end{CD}
\]</div><p>As we can see, we can build an arrow \(\epsilon_{G(X)}\circ J(\eta_X):
J(F(X)) \to K(G(X))\), which we can use as the components of our natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This construction is
called the <em>horizontal composition</em> of natural transformations. We should
verify that this is indeed a natural transformation - for now, let&rsquo;s just
accept that it follows from the naturality of \(\eta\) and \(\epsilon\).</p><p>Lastly, there is an obvious natural transformation taking a functor to itself;
each component being just the identity arrow. We call that natural
transformation \(\iota\), staying with the convention of using Greek letters
for natural transformations.</p><p>With this, we can redraw the diagram we used to define monoids above, the
replacements indicated by the quotes:</p><div>\[
\begin{CD}
I \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ I @>{\iota\ \eta}>> M\circ M @<{\eta\ \iota}<< I\circ M \\
@VVV @V{\mu}VV @VVV \\
M @>{\iota}>> M @<{\iota}<< M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M\circ M @>{\mu\ \iota}>> M\circ M \\
@V{\iota\ \mu}VV @V{\mu}VV \\
M\circ M @>{\mu}>> M \\
\end{CD}
\]</div><p>The vertical arrows in the middle diagram now simply apply the composition of
functors, using that the identity functor is a unit.</p><p>These diagrams encode these conditions on our natural transformations<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>:</p><ul><li>\(\mu\circ\eta\iota = \mu = \iota\eta\circ\mu\), that is \(\eta\) serves as a unit</li><li>\(\mu\circ\mu\iota = \mu\circ\iota\mu\), that is \(\mu\) is associative</li></ul><p>To recap, a monad, in category theory, is</p><ul><li>An endofunctor \(M\)</li><li>A natural transformation \(\eta: I\to M\), which serves as an identity for
horizontal composition.</li><li>A natural transformation \(\mu: M\circ M\to M\), which is associative in
respect to horizontal composition.</li></ul><p>Now, let&rsquo;s see, how this maps to Haskell monads.</p><p>First, what is the identity functor in Haskell? As we pointed out above, the
object function of functors is implicit, when we write <code>f a</code> instead of <code>a</code>. As
such, the identity functor is simply <code>a</code> - i.e. we map any type to itself.
<code>fmap</code> of that functor would thus also just be the identity
<code>fmap :: (a -> a) -> (a -> a)</code>.</p><p>So, what would our natural transformation \(\eta\) look like? As we said, a
natural transformation between two functors is just a map <code>f a -> g a</code>. So (if
we call our endofunctor <code>m</code>) the identity transformation of our monoid is
<code>eta :: a -> m a</code>
mapping the identity functor to <code>m</code>. We also need our monoidal operation, which
should map <code>m</code> applied twice to <code>m</code>:
<code>mu :: m (m a) -> m a</code>.</p><p>Now, Haskellers write <code>return</code> instead of <code>eta</code> and write <code>join</code> instead of
<code>mu</code>, giving us the type class<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Monad</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>  <span class=n>return</span> <span class=ow>::</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=n>join</span> <span class=ow>::</span> <span class=n>m</span> <span class=p>(</span><span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span></code></pre></div><p>As a last note, it is worth pointing out that you usually won&rsquo;t implement
<code>join</code>, but instead a different function, called &ldquo;monadic bind&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=o>&gt;&gt;=</span><span class=p>)</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span>
</span></span></code></pre></div><p>The reason is, that this more closely maps to what monads are actually <em>used</em>
for in functional programming. But we can move between <code>join</code> and <code>>>=</code> via</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=o>&gt;&gt;=</span><span class=p>)</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>v</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>join</span> <span class=p>((</span><span class=n>fmap</span> <span class=n>f</span><span class=p>)</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>join</span> <span class=ow>::</span> <span class=n>m</span> <span class=p>(</span><span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>join</span> <span class=n>v</span> <span class=ow>=</span> <span class=n>v</span> <span class=o>&gt;&gt;=</span> <span class=n>id</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This certainly was a bit of a long ride. It took me <em>much</em> longer than
anticipated both to understand all the steps necessary and to write them down.
I hope you found it helpful and I hope I didn&rsquo;t make too many, too glaring
mistakes. If so (either), feel free to let me know on
<a href=https://twitter.com/TheMerovius>Twitter</a>,
<a href=https://www.reddit.com/r/haskell/comments/7oudxd/monads_are_just_monoids_in_the_category_of/>reddit</a>
or <a href="https://news.ycombinator.com/item?id=16093508">Hacker News</a> - but please
remember to be kind :)</p><p><em>I want to thank <a href=https://twitter.com/r4dler>Tim Adler</a> and
<a href=https://twitter.com/9b17fe>mxf+</a> for proof-reading this absurdly long post
and for making many helpful suggestions for improvements</em></p><hr><p>The fact that we are not doing that is a completely justified criticism,
that is due to a historical accident - we write function application from
right to left, that is we write \(f(x)\), for applying \(f\) to \(x\).
Accordingly, we write \(g(f(x))\), when applying \(g\) to the result of
applying \(f\) to \(x\). And we chose to have the composite-notation be
consistent with <em>that</em>, instead of the arrow-notation.</p><p>I chose to just eat the unfortunate confusion, as it turns out Haskell is
doing exactly the same thing, so swapping things around would just increase
the confusion.</p><p>Sorry.</p><p>What was that? Oh, you thought Mathematicians where precise? Ha!</p><p>This is one of the things that was tripping me up for a while: I was trying to
figure out, how I would map types to other types in Haskell or even talk about
the object map. But the most useful answer is &ldquo;you don&rsquo;t&rdquo;.</p><script defer crossorigin=anonymous src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>It is often confusing to people, that the way the
arrows point in the notation and the order they are written seems to contradict
each other: When writing \(f:X\to Y\) and \(g:Y\to Z\) you might reasonably
expect their composite to work like \(f\circ g: X\to Z\), that is, you glue
together the arrows in the order you are writing them.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Keep in mind that this is a different notion from the
ones for monoids, which we come to a bit later: While the formulas seem the
same and the identities look like a unit, the difference is that only certain
arrows can be composed, not all. And that there are many identity arrows, not
just one. However, if we would have only <em>one</em> object, it would have to be the
domain and codomain of every arrow and there would be exactly one identity
arrow. In that case, the notions <em>would</em> be the same and indeed, &ldquo;a category
with exactly one object&rdquo; is yet another way to define monoids.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>It is customary, to use the same name for the object
and arrow map, even though that may seem confusing. A slight justification of
that would be, that the object map is already given by the arrow map anyway: If
\(F\) is the arrow map, we can define the object map as \(X\mapsto
\mathrm{dom}(F(\mathrm{id}_X))\). So, given that they are always occurring
together and you can make one from the other, we tend to just drop the
distinction and save some symbols.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>It is important to note, that this is not really a
<em>function</em>. Functions operate on values of a given type. But here, we are
operating on <em>types</em> and Haskell has no concept of a &ldquo;type of types&rdquo; built in
that a function could operate on. There are constructs operating on types to
construct new types, like <code>data</code>, <code>type</code>, <code>newtype</code> or even <code>deriving</code>. But
they are special syntactical constructs that exist outside of the realm of
functions.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>An important note here, is that the \(\eta_X\) are
<em>arrows</em>. Where the object map of a functor is just a general association which
could look anything we like, the components of a natural transformation need to
preserve the internal structure of the category we are working in.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>You will often see these conditions written
differently, namely written e.g. \(\mu M\) instead of \(\mu\iota\). You can
treat that as a notational shorthand, it really means the same thing.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>There is a technicality here, that Haskell also has
an intermediate between functor and monad called &ldquo;applicative&rdquo;. As I understand
it, this does not have a clear category theoretical analogue. I&rsquo;m not sure why
it exits, but I believe it has been added into the hierarchy after the fact.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/haskell/>haskell</a></li><li><a href=https://blog.merovius.de/tags/math/>math</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=/atom.xml target=_blank rel="noopener noreferrer me" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://www.tumblr.com/merovius target=_blank rel="noopener noreferrer me" title=Tumblr><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentcolor"><path d="M14.563 24c-5.093.0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941.0 9.999.0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>