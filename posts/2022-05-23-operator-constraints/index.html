<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operator constraints in Go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I describe four ways to express constraints for operators in generic Go code and the trade-offs involved."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2022-05-23-operator-constraints/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Operator constraints in Go"><meta property="og:description" content="I describe four ways to express constraints for operators in generic Go code and the trade-offs involved."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2022-05-23-operator-constraints/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-23T17:34:00+00:00"><meta property="article:modified_time" content="2022-05-23T17:34:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Operator constraints in Go"><meta name=twitter:description content="I describe four ways to express constraints for operators in generic Go code and the trade-offs involved."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Operator constraints in Go","item":"https://blog.merovius.de/posts/2022-05-23-operator-constraints/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Operator constraints in Go","name":"Operator constraints in Go","description":"I describe four ways to express constraints for operators in generic Go code and the trade-offs involved.","keywords":["golang","programming"],"articleBody":"Letâ€™s say you want to implement a sorting function in Go. Or perhaps a data structure like a binary search tree, providing ordered access to its elements. Because you want your code to be re-usable and type safe, you want to use type parameters. So you need a way to order user-provided types.\nThere are multiple methods of doing that, with different trade-offs. Letâ€™s talk about four in particular here:\n constraints.Ordered A method constraint Taking a comparison function Comparator types  constraints.Ordered Go 1.18 has a mechanism to constrain a type parameter to all types which have the  operator defined on them. The types which have this operator are exactly all types whose underlying type is string or one of the predeclared integer and float types. So we can write a type set expressing that:\ntype Integer interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr } type Float interface { ~float32 | ~float64 } type Ordered interface { Integer | Float | ~string } Because thatâ€™s a fairly common thing to want to do, there is already a package which contains these kinds of type sets.\nWith this, you can write the signature of your sorting function or the definition of your search tree as:\nfunc Sort[T constraints.Ordered](s []T) { // â€¦ } type SearchTree[T constraints.Ordered] struct { // â€¦ } The main advantage of this is that it works directly with predeclared types and simple types like time.Duration. It also is very clear.\nThe main disadvantage is that it does not allow composite types like structs. And what if a user wants a different sorting order than the one implied by ? For example if they want to reverse the order or want specialized string collation. A multimedia library might want to sort â€œThe Expanseâ€ under E. And some letters sort differently depending on the language setting.\nconstraints.Ordered is simple, but it also is inflexible.\nMethod constraints We can use method constraints to allow more flexibility. This allows a user to implement whatever sorting order they want as a method on their type.\nWe can write that constraint like this:\ntype Lesser[T any] interface { // Less returns if the receiver is less than v.  Less(v T) bool } The type parameter is necessary because we have to refer to the receiver type itself in the Less method. This is hopefully clearer when we look at how this is used:\nfunc Sort[T Lesser[T]](s []T) { // â€¦ } func SearchTree[T Lesser[T]](s []T) { // â€¦ } This allows the user of our library to customize the sorting order by defining a new type with a Less method:\ntype ReverseInt int func (i ReverseInt) Less(j ReverseInt) bool { return j  i // order is reversed } The disadvantage of this is that it requires some boiler plate on part of your user. Using a custom sorting order always requires defining a type with a method.\nThey canâ€™t use your code with predeclared types like int or string but always have to wrap it into a new type.\nLikewise if a type already has a natural comparison method but it is not called Less. For example time.Time is naturally sorted by time.Time.Before. For cases like that there needs to be a wrapper to rename the method.\nWhenever one of these wrappings happens your user might have to convert back and forth when passing data to or from your code.\nIt also is a little bit more confusing than constraints.Ordered, as your user has to understand the purpose of the extra type parameter on Lesser.\nPassing a comparison function A simple way to get flexibility is to have the user pass us a function used for comparison directly:\nfunc Sort[T any](s []T, less func(T, T) bool) { // â€¦ } type SearchTree[T any] struct { Less func(T, T) bool // â€¦ } func NewSearchTree(less func(T, T) bool) *SearchTree[T] { // â€¦  return \u0026SearchTree[T]{ Less: less, // â€¦  } } This essentially abandons the idea of type constraints altogether. Our code works with any type and we directly pass around the custom behavior as funcs. Type parameters are only used to ensure that the arguments to those funcs are compatible.\nThe advantage of this is maximum flexibility. Any type which already has a Less method like above can simply be used with this directly by using method expressions. Regardless of how the method is actually named:\nfunc main() { a := []time.Time{ /* â€¦ */ } Sort(a, time.Time.Before) } There is also no boilerplate needed to customize sorting behavior:\nfunc main() { a := []int{42,23,1337} Sort(a, func(i, j int) bool { return j  i // reversed order  }) } And you can provide helpers for common customizations:\nfunc Reversed[T any](less func(T, T) bool) (greater func(T, T) bool) { return func(a, b T) bool { return less(b, a) } } This approach is arguably also more correct than the one above because it decouples the type from the comparison used. If I use a SearchTree as a set datatype, there is no real reason why the elements in the set would be specific to the comparison used. It should be â€œa set of stringâ€ not â€œa set of MyCustomlyOrderedStringâ€. This reflects the fact that with the method constraint, we have to convert back-and-forth when putting things into the container or taking it out again.\nThe main disadvantage of this approach is that it means you can not have useful zero values. Your SearchTree type needs the Less field to be populated to work. So its zero value can not be used to represent an empty set.\nYou cannot even lazily initialize it (which is a common trick to make types which need initialization have a useful zero value) because you donâ€™t know what it should be.\nComparator types There is a way to pass a function â€œstaticallyâ€. That is, instead of passing around a func value, we can pass it as a type argument. The way to do that is to attach it as a method to a struct{} type:\nimport \"golang.org/x/exp/slices\" type IntComparator struct{} func (IntComparator) Less(a, b int) bool { return a  b } func main() { a := []int{42,23,1337} less := IntComparator{}.Less // has type func(int, int) bool  slices.SortFunc(a, less) } Based on this, we can devise a mechanism to allow custom comparisons:\n// Comparator is a helper type used to compare two T values. type Comparator[T any] interface { ~struct{} Less(a, b T) bool } func Sort[C Comparator[T], T any](a []T) { var c C less := c.Less // has type func(T, T) bool  // â€¦ } type SearchTree[C Comparator[T], T any] struct { // â€¦ } The ~struct{} constraints any implementation of Comparator[T] to have underlying type struct{}. It is not strictly necessary, but it serves two purposes here:\n It makes clear that Comparator[T] itself is not supposed to carry any state. It only exists to have its method called. It ensures (as much as possible) that the zero value of C is safe to use. In particular, Comparator[T] would be a normal interface type. And it would have a Less method of the right type, so it would implement itself. But a zero Comparator[T] is nil and would always panic, if its method is called.  An implication of this is that it is not possible to have a Comparator[T] which uses an arbitrary func value. The Less method can not rely on having access to a func to call, for this approach to work.\nBut you can provide other helpers. This can also be used to combine this approach with the above ones:\ntype LessOperator[T constraints.Ordered] struct{} func (LessOperator[T]) Less(a, b T) bool { return a  b } type LessMethod[T Lesser[T]] struct{} func (LessMethod[T]) Less(a, b T) bool { return a.Less(b) } type Reversed[C Comparator[T], T any] struct{} func (Reversed[C, T]) Less(a, b T) bool { var c C return c.Less(b, a) } The advantage of this approach is that it makes the zero value of SearchTree[C, T] useful. For example, a SearchTree[LessOperator[int], int] can be used directly, without extra initialization.\nIt also carries over the advantage of decoupling the comparison from the element type, which we got from accepting comparison functions.\nOne disadvantage is that the comparator can never be inferred. It always has to be specified in the instantiation explicitly1. Thatâ€™s similar to how we always had to pass a less function explicitly above.\nAnother disadvantage is that this always requires defining a type for comparisons. Where with the comparison function we could define customizations (like reversing the order) inline with a func literal, this mechanism always requires a method.\nLastly, this is arguably too clever for its own good. Understanding the purpose and idea behind the Comparator type is likely to trip up your users when reading the documentation.\nSummary We are left with these trade-offs:\n    constraints.Ordered Lesser[T] func(T,T) bool Comparator[T]     Predeclared types ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Composite types ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Custom order ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Reversal helpers ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Type boilerplate ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Useful zero value ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Type inference ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Coupled Type/Order ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘   Clarity ğŸ‘ ğŸ¤·2 ğŸ‘ ğŸ‘    One thing standing out in this table is that there is no way to both support predeclared types and support user defined types.\nIt would be great if there was a way to support multiple of these mechanisms using the same code. That is, it would be great if we could write something like\n// Ordered is a constraint to allow a type to be sorted. // If a Less method is present, it has precedent. type Ordered[T any] interface { constraints.Ordered | Lesser[T] } Unfortunately, allowing this is harder than one might think.\nUntil then, you might want to provide multiple APIs to allow your users more flexibility. The standard library currently seems to be converging on providing a constraints.Ordered version and a comparison function version. The latter gets a Func suffix to the name. See the experimental slices package for an example.\n  Though as we put the Comparator[T] type parameter first, we can infer T from the Comparator.Â â†©ï¸\n Itâ€™s a little bit worse, but probably fine.Â â†©ï¸\n   ","wordCount":"1717","inLanguage":"en","datePublished":"2022-05-23T17:34:00Z","dateModified":"2022-05-23T17:34:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2022-05-23-operator-constraints/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Operator constraints in Go</h1><div class=post-meta><span title="2022-05-23 17:34:00 +0000 UTC">May 23, 2022</span></div></header><div class=post-content><p>Let&rsquo;s say you want to implement a sorting function in Go. Or perhaps a data
structure like a
<a href=https://en.wikipedia.org/wiki/Binary_search_tree>binary search tree</a>,
providing ordered access to its elements. Because you want your code to be
re-usable and type safe, you want to use type parameters. So you need a way to
order user-provided types.</p><p>There are multiple methods of doing that, with different trade-offs. Let&rsquo;s talk
about four in particular here:</p><ol><li><code>constraints.Ordered</code></li><li>A method constraint</li><li>Taking a comparison function</li><li>Comparator types</li></ol><h2 id=constraintsordered><code>constraints.Ordered</code><a hidden class=anchor aria-hidden=true href=#constraintsordered>#</a></h2><p>Go 1.18 has a mechanism to constrain a type parameter to all types which have
the <code>&lt;</code> operator defined on them. The types which have this operator are
exactly all types whose underlying type is <code>string</code> or one of the predeclared
integer and float types. So we can write a type set expressing that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Integer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Float</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Ordered</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Integer</span> <span class=p>|</span> <span class=nx>Float</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Because that&rsquo;s a fairly common thing to want to do,
<a href=https://pkg.go.dev/golang.org/x/exp/constraints#Ordered>there is already a package which contains these kinds of type sets</a>.</p><p>With this, you can write the signature of your sorting function or the
definition of your search tree as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Sort</span><span class=p>[</span><span class=nx>T</span> <span class=nx>constraints</span><span class=p>.</span><span class=nx>Ordered</span><span class=p>](</span><span class=nx>s</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SearchTree</span><span class=p>[</span><span class=nx>T</span> <span class=nx>constraints</span><span class=p>.</span><span class=nx>Ordered</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The main advantage of this is that it works directly with predeclared types and
simple types like <code>time.Duration</code>. It also is very clear.</p><p>The main disadvantage is that it does not allow composite types like <code>struct</code>s.
And what if a user wants a different sorting order than the one implied by <code>&lt;</code>?
For example if they want to reverse the order or want specialized string
collation. A multimedia library might want to sort â€œThe Expanseâ€ under E. And
some letters sort differently depending on the language setting.</p><p><code>constraints.Ordered</code> is simple, but it also is inflexible.</p><h2 id=method-constraints>Method constraints<a hidden class=anchor aria-hidden=true href=#method-constraints>#</a></h2><p>We can use method constraints to allow more flexibility. This allows a user to
implement whatever sorting order they want as a method on their type.</p><p>We can write that constraint like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Lesser</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Less returns if the receiver is less than v.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Less</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The type parameter is necessary because we have to refer to the receiver type
itself in the <code>Less</code> method. This is hopefully clearer when we look at how this
is used:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Sort</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Lesser</span><span class=p>[</span><span class=nx>T</span><span class=p>]](</span><span class=nx>s</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>SearchTree</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Lesser</span><span class=p>[</span><span class=nx>T</span><span class=p>]](</span><span class=nx>s</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This allows the user of our library to customize the sorting order by defining
a new type with a <code>Less</code> method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ReverseInt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>i</span> <span class=nx>ReverseInt</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>j</span> <span class=nx>ReverseInt</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>i</span> <span class=c1>// order is reversed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The disadvantage of this is that it requires some boiler plate on part of your
user. Using a custom sorting order always requires defining a type with a method.</p><p>They can&rsquo;t use your code with predeclared types like <code>int</code> or <code>string</code> but
always have to wrap it into a new type.</p><p>Likewise if a type already has a natural comparison method but it is not
called <code>Less</code>. For example <code>time.Time</code> is naturally sorted by
<code>time.Time.Before</code>. For cases like that there needs to be a wrapper to rename
the method.</p><p>Whenever one of these wrappings happens your user might have to convert back
and forth when passing data to or from your code.</p><p>It also is a little bit more confusing than <code>constraints.Ordered</code>, as your user
has to understand the purpose of the extra type parameter on <code>Lesser</code>.</p><h2 id=passing-a-comparison-function>Passing a comparison function<a hidden class=anchor aria-hidden=true href=#passing-a-comparison-function>#</a></h2><p>A simple way to get flexibility is to have the user pass us a function used for
comparison directly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Sort</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>](</span><span class=nx>s</span> <span class=p>[]</span><span class=nx>T</span><span class=p>,</span> <span class=nx>less</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SearchTree</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Less</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewSearchTree</span><span class=p>(</span><span class=nx>less</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=o>*</span><span class=nx>SearchTree</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>SearchTree</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Less</span><span class=p>:</span> <span class=nx>less</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This essentially abandons the idea of type constraints altogether. Our code
works with <em>any</em> type and we directly pass around the custom behavior as
<code>func</code>s. Type parameters are only used to ensure that the arguments to those
<code>func</code>s are compatible.</p><p>The advantage of this is maximum flexibility. Any type which already has a
<code>Less</code> method like above can simply be used with this directly by using
<a href=https://go.dev/ref/spec#Method_expressions>method expressions</a>. Regardless of
how the method is actually named:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>{</span> <span class=cm>/* â€¦ */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Sort</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>.</span><span class=nx>Before</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There is also no boilerplate needed to customize sorting behavior:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>42</span><span class=p>,</span><span class=mi>23</span><span class=p>,</span><span class=mi>1337</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Sort</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>i</span> <span class=c1>// reversed order
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And you can provide helpers for common customizations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Reversed</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>](</span><span class=nx>less</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>(</span><span class=nx>greater</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>less</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This approach is arguably also more correct than the one above because it
decouples the type from the comparison used. If I use a <code>SearchTree</code> as a set
datatype, there is no real reason why the elements in the set would be specific
to the comparison used. It should be â€œa set of <code>string</code>â€ not â€œa set of
<code>MyCustomlyOrderedString</code>â€. This reflects the fact that with the method
constraint, we have to convert back-and-forth when putting things into the
container or taking it out again.</p><p>The main <em>disadvantage</em> of this approach is that it means you can not have
useful zero values. Your <code>SearchTree</code> type needs the <code>Less</code> field to be
populated to work. So its zero value can not be used to represent an empty set.</p><p>You cannot even lazily initialize it (which is a common trick to make types
which need initialization have a useful zero value) because <em>you don&rsquo;t know
what it should be</em>.</p><h2 id=comparator-types>Comparator types<a hidden class=anchor aria-hidden=true href=#comparator-types>#</a></h2><p>There is a way to pass a function â€œstaticallyâ€. That is, instead of passing
around a <code>func</code> value, we can pass it as a type argument. The way to do that is
to attach it as a method to a <code>struct{}</code> type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;golang.org/x/exp/slices&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IntComparator</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>IntComparator</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>42</span><span class=p>,</span><span class=mi>23</span><span class=p>,</span><span class=mi>1337</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>less</span> <span class=o>:=</span> <span class=nx>IntComparator</span><span class=p>{}.</span><span class=nx>Less</span> <span class=c1>// has type func(int, int) bool
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>slices</span><span class=p>.</span><span class=nf>SortFunc</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>less</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Based on this, we can devise a mechanism to allow custom comparisons:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Comparator is a helper type used to compare two T values.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Comparator</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>~</span><span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Less</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Sort</span><span class=p>[</span><span class=nx>C</span> <span class=nx>Comparator</span><span class=p>[</span><span class=nx>T</span><span class=p>],</span> <span class=nx>T</span> <span class=nx>any</span><span class=p>](</span><span class=nx>a</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>c</span> <span class=nx>C</span>
</span></span><span class=line><span class=cl>  <span class=nx>less</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>Less</span> <span class=c1>// has type func(T, T) bool
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SearchTree</span><span class=p>[</span><span class=nx>C</span> <span class=nx>Comparator</span><span class=p>[</span><span class=nx>T</span><span class=p>],</span> <span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// â€¦
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The <code>~struct{}</code> constraints any implementation of <code>Comparator[T]</code> to have
underlying type <code>struct{}</code>. It is not strictly necessary, but it serves two
purposes here:</p><ol><li>It makes clear that <code>Comparator[T]</code> itself is not supposed to carry any
state. It only exists to have its method called.</li><li>It ensures (as much as possible) that the zero value of <code>C</code> is safe to use.
In particular, <code>Comparator[T]</code> would be a normal interface type. And it
would have a <code>Less</code> method of the right type, so it would implement itself.
But a zero <code>Comparator[T]</code> is <code>nil</code> and would always panic, if its method is
called.</li></ol><p>An implication of this is that it is not possible to have a <code>Comparator[T]</code>
which uses an arbitrary <code>func</code> value. The <code>Less</code> method can not rely on having
access to a <code>func</code> to call, for this approach to work.</p><p>But you can provide other helpers. This can also be used to combine this approach
with the above ones:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>LessOperator</span><span class=p>[</span><span class=nx>T</span> <span class=nx>constraints</span><span class=p>.</span><span class=nx>Ordered</span><span class=p>]</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>LessOperator</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>LessMethod</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Lesser</span><span class=p>[</span><span class=nx>T</span><span class=p>]]</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>LessMethod</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nf>Less</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reversed</span><span class=p>[</span><span class=nx>C</span> <span class=nx>Comparator</span><span class=p>[</span><span class=nx>T</span><span class=p>],</span> <span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>Reversed</span><span class=p>[</span><span class=nx>C</span><span class=p>,</span> <span class=nx>T</span><span class=p>])</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>c</span> <span class=nx>C</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Less</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The advantage of this approach is that it makes the zero value of
<code>SearchTree[C, T]</code> useful. For example, a <code>SearchTree[LessOperator[int], int]</code>
can be used directly, without extra initialization.</p><p>It also carries over the advantage of decoupling the comparison from the
element type, which we got from accepting comparison functions.</p><p>One disadvantage is that the comparator can never be inferred. It always has to
be specified in the instantiation explicitly<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. That&rsquo;s similar to how we
always had to pass a <code>less</code> function explicitly above.</p><p>Another disadvantage is that this <em>always</em> requires defining a type for
comparisons. Where with the comparison function we could define customizations
(like reversing the order) inline with a <code>func</code> literal, this mechanism always
requires a method.</p><p>Lastly, this is arguably too clever for its own good. Understanding the purpose
and idea behind the <code>Comparator</code> type is likely to trip up your users when
reading the documentation.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>We are left with these trade-offs:</p><table><thead><tr><th></th><th><code>constraints.Ordered</code></th><th><code>Lesser[T]</code></th><th><code>func(T,T) bool</code></th><th><code>Comparator[T]</code></th></tr></thead><tbody><tr><td>Predeclared types</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Composite types</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Custom order</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Reversal helpers</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Type boilerplate</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Useful zero value</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Type inference</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Coupled Type/Order</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td><td>ğŸ‘</td></tr><tr><td>Clarity</td><td>ğŸ‘</td><td>ğŸ¤·<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></td><td>ğŸ‘</td><td>ğŸ‘</td></tr></tbody></table><p>One thing standing out in this table is that there is no way to <em>both</em> support
predeclared types <em>and</em> support user defined types.</p><p>It would be great if there was a way to support multiple of these mechanisms
using the same code. That is, it would be great if we could write something
like</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Ordered is a constraint to allow a type to be sorted.
</span></span></span><span class=line><span class=cl><span class=c1>// If a Less method is present, it has precedent.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Ordered</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constraints</span><span class=p>.</span><span class=nx>Ordered</span> <span class=p>|</span> <span class=nx>Lesser</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Unfortunately, allowing this
<a href=https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/>is harder than one might think</a>.</p><p>Until then, you might want to provide multiple APIs to allow your users more
flexibility. The standard library currently seems to be converging on providing
a <code>constraints.Ordered</code> version and a comparison function version. The latter
gets a <code>Func</code> suffix to the name. See
<a href=https://pkg.go.dev/golang.org/x/exp/slices>the experimental <code>slices</code> package</a>
for an example.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Though as we put the <code>Comparator[T]</code> type parameter first, we can infer
<code>T</code> from the <code>Comparator</code>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>It&rsquo;s a <em>little</em> bit worse, but probably fine.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>