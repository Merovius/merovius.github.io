<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Diminishing returns of static typing | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="When talking about static type systems, we often tend to focus on one side of the equation. I&rsquo;m trying to make explicit how I view the question as a tradeoff and why I neither agree with “more is always better”, nor with “a little is enough”."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-09-12-diminishing-returns-of-static-typing/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Diminishing returns of static typing"><meta property="og:description" content="When talking about static type systems, we often tend to focus on one side of the equation. I&rsquo;m trying to make explicit how I view the question as a tradeoff and why I neither agree with “more is always better”, nor with “a little is enough”."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-09-12-diminishing-returns-of-static-typing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-12T11:05:00+00:00"><meta property="article:modified_time" content="2017-09-12T11:05:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Diminishing returns of static typing"><meta name=twitter:description content="When talking about static type systems, we often tend to focus on one side of the equation. I&rsquo;m trying to make explicit how I view the question as a tradeoff and why I neither agree with “more is always better”, nor with “a little is enough”."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Diminishing returns of static typing","item":"https://blog.merovius.de/posts/2017-09-12-diminishing-returns-of-static-typing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Diminishing returns of static typing","name":"Diminishing returns of static typing","description":"When talking about static type systems, we often tend to focus on one side of the equation. I\u0026rsquo;m trying to make explicit how I view the question as a tradeoff and why I neither agree with “more is always better”, nor with “a little is enough”.","keywords":["golang","programming"],"articleBody":"I often get into discussions with people, where the matter of strictness and expressiveness of a static type system comes up. The most common one, by far, is Go’s lack of generics and the resulting necessity to use interface{} in container types (the container-subpackages are obvious cases, but also context). When I express my view, that the lack of static type-safety for containers isn’t a problem, I am treated with condescending reactions ranging from disbelief to patronizing.\nI also often take the other side of the argument. This happens commonly, when talking to proponents of dynamically typed languages. In particular I got into debates of whether Python would be suitable for a certain use-case. When the lack of static type-safety is brought up, the proponents of Python defend it by pointing out that it now features optional type hints. Which they say make it possible, to reap the benefits of static typing even in a conventionally dynamically typed language.\nThis is an attempt to write my thoughts on both of these (though they are not in any way novel or creative) down more thoroughly. Discussions usually don’t provide the space for that. They are also often charged and parties are more interested in “winning the argument”, than finding consensus.\n I don’t think it’s particularly controversial, that static typing in general has advantages, even though actual data about those seems to be surprisingly hard to come by. I certainly believe that, it is why I use Go in the first place. There is a difference of opinion though, in how large and important those benefits are and how much of the behavior of a program must be statically checked to reap those benefits.\nTo understand this, we should first make explicit what the benefits of static type checking are. The most commonly mentioned one is to catch bugs as early in the development process as possible. If a piece of code I write already contains a rigorous proof of correctness in the form of types, just writing it down and compiling it gives me assurance that it will work as intended in all circumstances. At the other end of the spectrum, in a fully dynamic language I will need to write tests exercising all of my code to find bugs. Running tests takes time. Writing good tests that actually cover all intended behavior is hard. And as it’s in general impossible to cover all possible execution paths, there will always be the possibility of a rare edge-case that we didn’t think of testing to trigger a bug in production.\nSo, we can think of static typing as increasing the proportion of bug-free lines of code deployed to production. This is of course a simplification. In practice, we would still catch a lot of the bugs via more rigorous testing, QA, canarying and other practices. To a degree we can still subsume these in this simplification though. If we catch a buggy line of code in QA or the canary phase, we are going to roll it back. So in a sense, the proportion of code we wrote that makes it as bug-free into production will still go down. Thus:\nThis is usually the understanding, that the “more static typing is always better” argument is based on. Checking more behavior at compile time means less bugs in production means more satisfied customers and less being woken up at night by your pager. Everybody’s happy.\nWhy then is it, that we don’t all code in Idris, Agda or a similarly strict language? Sure, the graph above is suggestively drawn to taper off, but it’s still monotonically increasing. You’d think that this implies more is better. The answer, of course, is that static typing has a cost and that there is no free lunch.\nThe costs of static typing again come in many forms. It requires more upfront investment in thinking about the correct types. It increases compile times and thus the change-compile-test-repeat cycle. It makes for a steeper learning curve. And more often than we like to admit, the error messages a compiler will give us will decline in usefulness as the power of a type system increases. Again, we can oversimplify and subsume these effects in saying that it reduces our speed:\nThis is what we mean when we talk about dynamically typed languages being good for rapid prototyping. In the end, however, what we are usually interested in, is what I’d like to call velocity: The speed with which we can deploy new features to our users. We can model that as the speed with which we can roll out bug-free code. Graphically, that is expressed as the product of the previous two graphs:\nIn practice, the product of these two functions will have a maximum, a sweet spot of maximum velocity. Designing a type system for a programming language is, at least in part, about finding that sweet spot1.\nNow if we are to accept all of this, that opens up a different question: If we are indeed searching for that sweet spot, how do we explain the vast differences in strength of type systems that we use in practice? The answer of course is simple (and I’m sure many of you have already typed it up in an angry response). The curves I drew above are completely made up. Given how hard it is to do empirical research in this space and to actually quantify the measures I used here, it stands to reason that their shape is very much up for interpretation.\nA Python developer might very reasonably believe that optional type-annotations are more than enough to achieve most if not all the advantages of static typing. While a Haskell developer might be much better adapted to static typing and not be slowed down by it as much (or even at all). As a result, the perceived sweet spot can vary widely:\nWhat’s more, the importance of these factors might vary a lot too. If you are writing avionics code or are programming the control unit for a space craft, you probably want to be pretty darn sure that the code you are deploying is correct. On the other hand, if you are a Silicon Valley startup in your growth-phase, user acquisition will be of a very high priority and you get users by deploying features quicker than your competitors. We can model that, by weighing the factors differently:\nYour use case will determine the sweet spot you are looking for and thus the language you will choose. But a language is also designed with a set of use cases in mind and will set its own sweet spot according to that.\nI think when we talk about how strict a type system should be, we need to acknowledge these subjective factors. And it is fine to believe that your perception of one of those curves or how they should be weighted is closer to a hypothetical objective reality than another persons. But you should make that belief explicit and provide a justification of why your perception is more realistic. Don’t just assume that other people view them the same way and then be confused that they do not come to the same conclusions as you.\n Back to Go’s type system. In my opinion, Go manages to hit a good sweet spot (that is, its design agrees with my personal preferences on this). To me it seems that Go reaps probably upwards of 90% of the benefits you can get from static typing while still being not too impeding. And while I definitely agree static typing is beneficial, the marginal benefit of making user-defined containers type-safe simply seems pretty low (even if it’s positive). In the end, it would probably be less than 1% of Go code that would get this additional type-checking and it is probably pretty obvious code. And meanwhile, I perceive generics as a language feature pretty costly. So I find it hard to justify a large perceived cost with a small perceived benefit.\nNow, that is not to say I’m not open to be convinced. Just that simply saying “but more type-safety!” is only looking at one side of the equation and isn’t enough. You need to acknowledge that there is no free lunch and that this is a tradeoff. You need to accept that your perceptions of how big the benefit of adding static typing is, how much it costs and how important it is are all subjective. If you want to convince me that my perception of their benefit is wrong, the best way would be to provide specific instances of bugs or production crashes caused by a type-assertion on an interface{} taken out of a container. Or a refactoring you couldn’t make because of the lack of type-safety with a specific container. Ideally, this takes the form of an experience report, which I consider an excellent way to talk about engineered tradeoffs.\nOf course you can continue to roll your eyes whenever someone questions your perception of the value-curve of static typing. Or pretend that when I say the marginal benefit of type-safe containers is small, I am implying that the total benefit of static typing is small. It’s an effective debate-tactic, if your goal is to shut up your opposition. But not if your goal is to convince them and build consensus.\n   There is a generous and broad exception for research languages here. If the point of your design is to explore the possibility space of type-systems, matters of practicality can of course often be ignored. ↩︎\n   ","wordCount":"1596","inLanguage":"en","datePublished":"2017-09-12T11:05:00Z","dateModified":"2017-09-12T11:05:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-09-12-diminishing-returns-of-static-typing/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Diminishing returns of static typing</h1><div class=post-meta><span title="2017-09-12 11:05:00 +0000 UTC">September 12, 2017</span></div></header><div class=post-content><p>I often get into discussions with people, where the matter of strictness and
expressiveness of a static type system comes up. The most common one, by far,
is Go&rsquo;s lack of generics and the resulting necessity to use <code>interface{}</code> in
container types (the <a href=https://godoc.org/container>container-subpackages</a> are
obvious cases, but also <a href=https://godoc.org/context>context</a>). When I express
my view, that the lack of static type-safety for containers isn&rsquo;t a problem, I
am treated with condescending reactions ranging from disbelief to patronizing.</p><p>I also often take the <em>other</em> side of the argument. This happens commonly, when
talking to proponents of dynamically typed languages. In particular I got into
debates of whether Python would be suitable for a certain use-case. When the
lack of static type-safety is brought up, the proponents of Python defend it by
pointing out that it now features optional type hints. Which they say make it
possible, to reap the benefits of static typing even in a conventionally
dynamically typed language.</p><p>This is an attempt to write my thoughts on both of these (though they are not
in any way novel or creative) down more thoroughly. Discussions usually don&rsquo;t
provide the space for that. They are also often charged and parties are more
interested in “winning the argument”, than finding consensus.</p><hr><p>I don&rsquo;t think it&rsquo;s particularly controversial, that static typing in general
has advantages, even though actual data about those seems to be <a href=https://danluu.com/empirical-pl/>surprisingly
hard to come by</a>. <em>I</em> certainly believe that,
it is why I use Go in the first place. There is a difference of opinion though,
in how large and important those benefits are and how much of the behavior of a
program must be statically checked to reap those benefits.</p><p>To understand this, we should first make explicit <em>what</em> the benefits of static
type checking are. The most commonly mentioned one is to catch bugs as early in
the development process as possible. If a piece of code I write already
contains a rigorous proof of correctness in the form of types, just writing it
down and compiling it gives me assurance that it will work as intended in all
circumstances. At the other end of the spectrum, in a fully dynamic language I
will need to write tests exercising all of my code to find bugs. Running tests
takes time. Writing <em>good</em> tests that actually cover all intended behavior is
hard. And as it&rsquo;s in general impossible to cover <em>all</em> possible execution
paths, there will always be the possibility of a rare edge-case that we didn&rsquo;t
think of testing to trigger a bug in production.</p><p>So, we can think of static typing as increasing the proportion of bug-free
lines of code deployed to production. This is of course a simplification. In
practice, we would still catch a lot of the bugs via more rigorous testing,
QA, canarying and other practices. To a degree we can still subsume these in
this simplification though. If we catch a buggy line of code in QA or the
canary phase, we are going to roll it back. So in a sense, the proportion of
code we wrote that makes it as bug-free into production will still go down.
Thus:</p><img class=small src=/assets/static_typing_v_good_code.png><p>This is usually the understanding, that the “more static typing is always
better” argument is based on. Checking more behavior at compile time means less
bugs in production means more satisfied customers and less being woken up at
night by your pager. Everybody&rsquo;s happy.</p><p>Why then is it, that we don&rsquo;t all code in Idris, Agda or a similarly strict
language? Sure, the graph above is suggestively drawn to taper off, but it&rsquo;s
still monotonically increasing. You&rsquo;d think that this implies more is better.
The answer, of course, is that static typing has a cost and that there is no
free lunch.</p><p>The costs of static typing again come in many forms. It requires more upfront
investment in thinking about the correct types. It increases compile times and
thus the change-compile-test-repeat cycle. It makes for a steeper learning
curve. And more often than we like to admit, the error messages a compiler will
give us will decline in usefulness as the power of a type system increases.
Again, we can oversimplify and subsume these effects in saying that it reduces
our speed:</p><img class=small src=/assets/static_typing_v_speed.png><p>This is what we mean when we talk about dynamically typed languages being good
for rapid prototyping. In the end, however, what we are usually interested in,
is what I&rsquo;d like to call <em>velocity</em>: The speed with which we can deploy new
features to our users. We can model that as the speed with which we can roll
out bug-free code. Graphically, that is expressed as the product of the
previous two graphs:</p><img class=small src=/assets/static_typing_v_velocity.png><p>In practice, the product of these two functions will have a maximum, a sweet
spot of maximum velocity. Designing a type system for a programming language
is, at least in part, about finding that sweet spot<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Now if we are to accept all of this, that opens up a different question: If we
are indeed searching for that sweet spot, how do we explain the vast
differences in strength of type systems that we use in practice? The answer of
course is simple (and I&rsquo;m sure many of you have already typed it up in an angry
response). The curves I drew above are completely made up. Given how hard it is
to do empirical research in this space and to actually quantify the measures I
used here, it stands to reason that their shape is very much up for
interpretation.</p><p>A Python developer might very reasonably believe that optional type-annotations
are more than enough to achieve most if not all the advantages of static
typing. While a Haskell developer might be much better adapted to static typing
and not be slowed down by it as much (or even at all). As a result, the
perceived sweet spot can vary widely:</p><img src=/assets/static_typing_pythonista_v_haskeller.png><p>What&rsquo;s more, the importance of these factors might vary a lot too. If you are
writing avionics code or are programming the control unit for a space craft,
you probably want to be pretty darn sure that the code you are deploying is
correct. On the other hand, if you are a Silicon Valley startup in your
growth-phase, user acquisition will be of a very high priority and you get
users by deploying features quicker than your competitors. We can model that,
by weighing the factors differently:</p><img src=/assets/static_typing_startup_v_nasa.png><p>Your use case will determine the sweet spot you are looking for and thus the
language you will choose. But a language is also designed with a set of use
cases in mind and will set its own sweet spot according to that.</p><p>I think when we talk about how strict a type system should be, we need to
acknowledge these subjective factors. And it is fine to believe that your
perception of one of those curves or how they should be weighted is closer to
a hypothetical objective reality than another persons. But you should make that
belief explicit and provide a justification of <em>why</em> your perception is more
realistic. Don&rsquo;t just assume that other people view them the same way and then
be confused that they do not come to the same conclusions as you.</p><hr><p>Back to Go&rsquo;s type system. In my opinion, Go manages to hit a good sweet spot
(that is, its design agrees with my personal preferences on this). To me it
seems that Go reaps probably upwards of 90% of the benefits you can get from
static typing while still being not too impeding. And while I definitely agree
static typing is beneficial, the <em>marginal</em> benefit of making user-defined
containers type-safe simply seems pretty low (even if it&rsquo;s positive). In the
end, it would probably be less than 1% of Go code that would get this additional
type-checking and it is probably pretty obvious code. And meanwhile, I perceive
generics as a language feature pretty costly. So I find it hard to justify a
large perceived cost with a small perceived benefit.</p><p>Now, that is not to say I&rsquo;m not open to be convinced. Just that simply saying
“but more type-safety!” is only looking at one side of the equation and isn&rsquo;t
enough. You need to acknowledge that there is no free lunch and that this is a
tradeoff. You need to accept that your perceptions of how big the benefit of
adding static typing is, how much it costs and how important it is are all
subjective. If you want to convince me that my perception of their benefit is
wrong, the best way would be to provide specific instances of bugs or
production crashes caused by a type-assertion on an <code>interface{}</code> taken out of
a container. Or a refactoring you couldn&rsquo;t make because of the lack of
type-safety with a specific container. Ideally, this takes the form of an
<a href=https://github.com/golang/go/wiki/ExperienceReports>experience report</a>, which
I consider an excellent way to talk about engineered tradeoffs.</p><p>Of course you can continue to roll your eyes whenever someone questions your
perception of the value-curve of static typing. Or pretend that when I say the
<em>marginal</em> benefit of type-safe containers is small, I am implying that the
<em>total</em> benefit of static typing is small. It&rsquo;s an effective debate-tactic, if
your goal is to shut up your opposition. But not if your goal is to convince
them and build consensus.</p><hr><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>There is a generous and broad exception for research
languages here. If the point of your design is to explore the possibility space
of type-systems, matters of practicality can of course often be ignored.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=Bookwyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>