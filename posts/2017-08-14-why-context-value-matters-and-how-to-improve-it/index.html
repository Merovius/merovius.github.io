<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Why context.Value matters and how to improve it | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="In light of recent discussions about its removal, I try to discuss what kinds of problems context.Value tries to solve. I then try to describe a design which would address most (but not all) of the criticism surrounding it."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Why context.Value matters and how to improve it"><meta property="og:description" content="In light of recent discussions about its removal, I try to discuss what kinds of problems context.Value tries to solve. I then try to describe a design which would address most (but not all) of the criticism surrounding it."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-14T00:17:25+00:00"><meta property="article:modified_time" content="2017-08-14T00:17:25+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why context.Value matters and how to improve it"><meta name=twitter:description content="In light of recent discussions about its removal, I try to discuss what kinds of problems context.Value tries to solve. I then try to describe a design which would address most (but not all) of the criticism surrounding it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Why context.Value matters and how to improve it","item":"https://blog.merovius.de/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Why context.Value matters and how to improve it","name":"Why context.Value matters and how to improve it","description":"In light of recent discussions about its removal, I try to discuss what kinds of problems context.Value tries to solve. I then try to describe a design which would address most (but not all) of the criticism surrounding it.","keywords":["golang","programming"],"articleBody":"tl;dr: I think context.Value solves the important use case of writing stateless - and thus scalable - abstractions. I believe dynamic scoping could provide the same benefits while solving most of the criticism of the current implementation. I thus try to steer the discussion away from the concrete implementation and towards the underlying problem.\nThis blog post is relatively long. I encourage you to skip sections you find boring\nUpdate: I wrote a new post, detailing how the type-safety concerns of context.Value in light of the new design for generics. You can check it out here\n Lately this blogpost has been discussed in several Go forums. It brings up several good arguments against the context-package:\n It requires every intermediate functions to include a context.Context even if they themselves do not use it. This introduces clutter into APIs and requires extensive plumbing. Additionally, ctx context.Context “stutters”. context.Value is not statically type-safe, requiring type-assertions. It does not allow you to express critical dependencies on context-contents statically. It’s susceptible to name collisions due to requiring a global namespace. It’s a map implemented as a linked list and thus inefficient.  However, I don’t think the post is doing a good enough job to discuss the problems context was designed to solve. It explicitly focuses on cancellation. Context.Value is discarded by simply stating that\n […] designing your APIs without ctx.Value in mind at all makes it always possible to come up with alternatives.\n I think this is not doing this question justice. To have a reasoned argument about context.Value there need to be consideration for both sides involved. No matter what your opinion on the current API is: The fact that seasoned, intelligent engineers felt the need - after significant thought - for Context.Value should already imply that the question deserves more attention.\nI’m going to try to describe my view on what kind of problems the context package tries to address, what alternatives currently exist and why I find them insufficient and I’m trying to describe an alternative design for a future evolution of the language. It would solve the same problems while avoiding some of the learned downsides of the context package. It is not meant as a specific proposal for Go 2 (I consider that way premature at this point) but just to show that a balanced view can show up alternatives in the design space and make it easier to consider all options.\n The problem context sets out to solve is one of abstracting a problem into independently executing units handled by different parts of a system. And how to scope data to one of these units in this scenario. It’s hard to clearly define the abstraction I am talking about. So I’m instead going to give some examples.\n When you build a scalable web service you will probably have a stateless frontend server that does things like authentication, verification and parsing for you. This allows you to scale up the external interface effortlessly and thus also gracefully fall back if the load increases past what the backends can handle. By treating requests as independent from each other you can load-balance them freely between your frontends. Microservices split a large application into small individual pieces that each process individual requests, each potentially branching out into more requests to other services. The requests will usually be independent, making it easy to scale individual microservices up and down based on demand, to load-balance between instances and to solve problems in transparent proxies. Functions as a Service goes one step further: You write single stateless functions that transform data and the platform will make them scale and execute efficiently. Even CSP, the concurrency model built into Go, can be viewed through that lens. The programmer expresses her problem as individually executing “processes” and the runtime will execute them efficiently. Functional Programming as a paradigm calls this “purity”. The concept that a functions result may only depend on its input parameters means not much more than the absence of shared state and independent execution. The design of a Request Oriented Collector for Go plays exactly into the same assumptions and ideas.  The idea in all these cases is to increase scaling (whether distributed among machines, between threads or just in code) by reducing shared state while maintaining shared usage of resources.\nGo takes a measured approach to this. It doesn’t go as far as some functional programming languages to forbid or discourage mutable state. It allows sharing memory between threads and synchronizing with mutexes instead of relying purely on channels. But it also definitely tries to be a (if not the) language to write modern, scalable services in. As such, it needs to be a good language to write this kind of stateless services. It needs to be able to make requests the level of isolation instead of the process. At least to a degree.\n(Side note: This seems to play into the statement of the author of above article, who claims that context is mainly useful for server authors. I disagree though. The general abstraction happens on many levels. E.g. a click in a GUI counts just as much as a “request” for this abstraction as an HTTP request)\nThis brings with it the requirement of being able to store some data on a request-level. A simple example for this would be authentication in an RPC framework. Different requests will have different capabilities. If a request originates from an administrator it should have higher privileges than if it originates from an unauthenticated user. This is fundamentally request scoped data. Not process, service or application scoped. And the RPC framework should treat this data as opaque. It is application specific not only how that data looks en détail but also what kinds of data it requires.\nJust like an HTTP proxy or framework should not need to know about request parameters or headers it doesn’t consume, an RPC framework shouldn’t know about request scoped data the application needs.\n Let’s try to look at specific ways this problem is (or could be) solved without involving context. As an example, let’s look at the problem of writing an HTTP middleware. We want to be able to wrap an http.Handler (or a variation thereof) in a way that allows the wrapper to attach data to a request.\nTo get static type-safety we could try to add some type to our handlers. We could have a type containing all the data we want to keep request scoped and pass that through our handlers:\ntype Data struct { Username string Log *log.Logger // … } func HandleA(d Data, res http.ResponseWriter, req *http.Request) { // … \td.Username = \"admin\" HandleB(d, req, res) // … } func HandleB(d Data, res http.ResponseWriter, req *http.Request) { // … } However, this would prevent us from writing reusable Middleware. Any such middleware would need to make it possible to wrap HandleA. But as it’s supposed to be reusable, it can’t know the type of the Data parameter. You could make the Data parameter an interface{} and require type-assertion. But that wouldn’t allow the middleware to inject its own data. You might think that interface type-assertions could solve this, but they have their own set of problems. In the end, this approach won’t bring you actual additional type safety.\nWe could store our state keyed by requests. For example, an authentication middleware could do\ntype Authenticator struct { mu sync.Mutex users map[*http.Request]string wrapped http.Handler } func (a *Authenticator) ServeHTTP(res http.ResponseWriter, req *http.Request) { // … \ta.mu.Lock() a.users[req] = \"admin\" a.mu.Unlock() defer func() { a.mu.Lock() delete(a.users, req) a.mu.Unlock() }() a.wrapped.ServeHTTP(res, req) } func (a *Authenticator) Username(req *http.Request) string { a.mu.Lock() defer a.mu.Unlock() return a.users[req] } This has some advantages over context:\n It is more type-safe. While we still can’t express a requirement on an authenticated user statically, we can express a requirement on an Authenticator It’s not susceptible to name-collisions anymore.  However, we bought this with shared mutable state and the associated lock contention. It can also break in subtle ways, if one of the intermediate handlers decides to create a new Request - as http.StripPrefix is going to do soon.\nLastly, we might consider to store this data in the *http.Request itself, for example by adding it as a stringified URL parameter. This too has several downsides, though. In fact it checks almost every single item from our list of downsides of context.Context. The exception is being a linked list. But even that advantage we buy with a lack of thread safety. If that request is passed to a handler in a different goroutine we get into trouble.\n(Side note: All of this also gives us a good idea of why the context package is implemented as a linked list. It allows all the data stored in it to be read-only and thus inherently thread-safe. There will never be any lock-contention around the shared state saved in a context.Context, because there will never be any need for locks)\nSo we see that it is really hard (if not impossible) to solve this problem of having data attached to requests in independently executing handlers while also doing significantly better than with context.Value. Whether you believe this a problem worth solving or not is debatable. But if you want to get this kind of scalable abstraction you will have to rely on something like context.Value.\n No matter whether you are now convinced of the usefulness of context.Value or still doubtful: The disadvantages can clearly not be ignored in either case. But we can try to find a way to improve on it. To eliminate some of the disadvantages while still keeping its useful attributes.\nOne way to do that (in Go 2) would be to introduce dynamically scoped variables. Semantically, each dynamically scoped variable represents a separate stack. Every time you change its value the new one is pushed to the stack. It is pop’ed off again after your function returns. For example:\n// Let's make up syntax! Only a tiny bit, though. dyn x = 23 func Foo() { fmt.Println(\"Foo:\", x) } func Bar() { fmt.Println(\"Bar:\", x) x = 42 fmt.Println(\"Bar:\", x) Baz() fmt.Println(\"Bar:\", x) } func Baz() { fmt.Println(\"Baz:\", x) x = 1337 fmt.Println(\"Baz:\", x) } func main() { fmt.Println(\"main:\", x) Foo() Bar() Baz() fmt.Println(\"main:\", x) } // Output: main: 23 Foo: 23 Bar: 23 Bar: 42 Baz: 42 Baz: 1337 Bar: 42 Baz: 23 Baz: 1337 main: 23 There are several notes about what I would imagine the semantics to be here.\n I would only allow dyn-declarations at package scope. Given that there is no way to refer to a local identifier of a different function, that seems logical. A newly spawned goroutine would inherit the dynamic values of its parent function. If we implement them (like context.Context) via linked lists, the shared data will be read-only. The head-pointer would need to be stored in some kind of goroutine-local storage. Thus, writes only ever modify this local storage (and the global heap), so wouldn’t need to be synchronized specifically. The dynamic scoping would be independent of the package the variable is declared in. That is, if foo.A modifies a dynamic bar.X, then that modification is visible to all subsequent callees of foo.A, whether they are in bar or not. Dynamically scoped variables would likely not be addressable. Otherwise we’d loose concurrency safety and the clear “down-stack” semantics of dynamic scoping. It would still be possible to declare dyn x *int though and thus get mutable state to pass on. The compiler would allocate the necessary storage for the stacks, initialized to their initializers and emit the necessary instructions to push and pop values on writes and returns. To account for panics and early returns, a mechanism like defer would be needed. There is some confusing overlap with package-scoped variables in this design. Most notably, from seeing foo.X = Y you wouldn’t be able to tell whether foo.X is dynamically scoped or not. Personally, I would address that by removing package-scoped variables from the language. They could still be emulated by declaring a dynamically-scoped pointer and never modifying it. Its pointee is then a shared variable. But most usages of package-scoped variables would probably just use dynamically scoped variables.  It is instructive to compare this design against the list of disadvantages identified for context.\n API clutter would be removed, as request-scoped data would now be part of the language without needing explicit passing. Dynamically scoped variables are statically type-safe. Every dyn declaration has an unambiguous type. It would still not be possible to express critical dependencies on dynamically scoped variables but they also couldn’t be absent. At worst they’ll have their zero value. Name collision is eliminated. Identifiers are, just like variable names, properly scoped. While a naive implementation would still use linked lists, they wouldn’t be inefficient. Every dyn declaration gets its own list and only the head-pointer ever needs to be operated on. The design is still “magic” to a degree. But that “magic” is problem-inherent (at least if I understand the criticism correctly). The magic is exactly the possibility to pass values transparently through API boundaries.  Lastly, I’d like to mention cancellation. While the author of above post dedicates most of it to cancellation, I have so far mostly ignored it. That’s because I believe cancellation to be trivially implementable on top of a good context.Value implementation. For example:\n// $GOROOT/src/done package done // C is closed when the current execution context (e.g. request) should be // cancelled. dyn C chan struct{} // CancelFunc returns a channel that gets closed, when C is closed or cancel is // called. func CancelFunc() (c chan struct, cancel func()) { // Note: We can't modify C here, because it is dynamically scoped, which is \t// why we return a new channel that the caller should store. \tch := make(chan struct) var o sync.Once cancel = func() { o.Do(close(ch)) } if C != nil { go func() { C cancel() }() } return ch, cancel } // $GOPATH/example.com/foo package foo func Foo() { var cancel func() done.C, cancel = done.CancelFunc() defer cancel() // Do things } This cancellation mechanism would now be usable from any library that wants it without needing any explicit support in its API. This would also make it easy to add cancellation capabilities retroactively.\n Whether you like this design or not, it demonstrates that we shouldn’t rush to calling for the removal of context. Removing it is only one possible solution to its downsides.\nIf the removal of context.Context actually comes up, the question we should ask is “do we want a canonical way to manage request-scoped values and at what cost”. Only then should we ask what the best implementation of this would be or whether to remove the current one.\n","wordCount":"2459","inLanguage":"en","datePublished":"2017-08-14T00:17:25Z","dateModified":"2017-08-14T00:17:25Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Why context.Value matters and how to improve it</h1><div class=post-meta><span title="2017-08-14 00:17:25 +0000 UTC">August 14, 2017</span></div></header><div class=post-content><p><strong>tl;dr: I think context.Value solves the important use case of writing
stateless - and thus scalable - abstractions. I believe
<a href=https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping>dynamic scoping</a>
could provide the same benefits while solving most of the criticism of the
current implementation. I thus try to steer the discussion away from the
concrete implementation and towards the underlying problem.</strong></p><p><em>This blog post is relatively long. I encourage you to skip sections you find boring</em></p><p><strong>Update: I wrote a new post, detailing how the type-safety concerns of
context.Value in light of the new design for generics. <a href=/posts/2020-07-20-parametric-context/>You can check it out
here</a></strong></p><hr><p>Lately <a href=https://faiface.github.io/posts/context-should-go-away-go2/>this
blogpost</a> has been
discussed in several Go forums. It brings up several good arguments against the
<a href=http://godoc.org/context>context-package</a>:</p><ul><li>It requires every intermediate functions to include a <code>context.Context</code> even
if they themselves do not use it. This introduces clutter into APIs and
requires extensive plumbing. Additionally, <code>ctx context.Context</code> &ldquo;stutters&rdquo;.</li><li><code>context.Value</code> is not statically type-safe, requiring type-assertions.</li><li>It does not allow you to express critical dependencies on context-contents
statically.</li><li>It&rsquo;s susceptible to name collisions due to requiring a global namespace.</li><li>It&rsquo;s a map implemented as a linked list and thus inefficient.</li></ul><p>However, I don&rsquo;t think the post is doing a good enough job to discuss the
problems context was designed to <em>solve</em>. It explicitly focuses on cancellation.
<code>Context.Value</code> is discarded by simply stating that</p><blockquote><p>[…] designing your APIs without ctx.Value in mind at all makes it always
possible to come up with alternatives.</p></blockquote><p>I think this is not doing this question justice. To have a reasoned argument
about context.Value there need to be consideration for both sides involved.
No matter what your opinion on the current API is: The fact that seasoned,
intelligent engineers felt the need - after significant thought - for
<code>Context.Value</code> should already imply that the question deserves more attention.</p><p>I&rsquo;m going to try to describe my view on what kind of problems the context
package tries to address, what alternatives currently exist and why I find them
insufficient and I&rsquo;m trying to describe an alternative design for a future
evolution of the language. It would solve the same problems while avoiding some
of the learned downsides of the context package. It is not meant as a specific
proposal for Go 2 (I consider that way premature at this point) but just to
show that a balanced view can show up alternatives in the design space and make
it easier to consider all options.</p><hr><p>The problem context sets out to solve is one of abstracting a problem into
independently executing units handled by different parts of a system. And how
to scope data to one of these units in this scenario. It&rsquo;s hard to clearly
define the abstraction I am talking about. So I&rsquo;m instead going to give some
examples.</p><ul><li>When you build a scalable web service you will probably have a stateless
frontend server that does things like authentication, verification and
parsing for you. This allows you to scale up the external interface
effortlessly and thus also gracefully fall back if the load increases past
what the backends can handle. By treating requests as independent from each
other you can load-balance them freely between your frontends.</li><li><a href=https://en.wikipedia.org/wiki/Microservices>Microservices</a> split a large
application into small individual pieces that each process individual
requests, each potentially branching out into more requests to other
services. The requests will usually be independent, making it easy to scale
individual microservices up and down based on demand, to load-balance between
instances and to solve problems in <a href=https://istio.io/>transparent proxies</a>.</li><li><a href=https://en.wikipedia.org/wiki/Serverless_computing>Functions as a Service</a>
goes one step further: You write single stateless functions that transform
data and the platform will make them scale and execute efficiently.</li><li>Even <a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP</a>,
the concurrency model built into Go, can be viewed through that lens. The
programmer expresses her problem as individually executing &ldquo;processes&rdquo; and
the runtime will execute them efficiently.</li><li><a href=https://en.wikipedia.org/wiki/Functional_programming>Functional Programming</a>
as a paradigm calls this &ldquo;purity&rdquo;. The concept that a functions result may
only depend on its input parameters means not much more than the absence of
shared state and independent execution.</li><li>The design of a <a href=https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit>Request Oriented Collector</a>
for Go plays exactly into the same assumptions and ideas.</li></ul><p>The idea in all these cases is to increase scaling (whether distributed among
machines, between threads or just in code) by reducing shared state while
maintaining shared usage of resources.</p><p>Go takes a measured approach to this. It doesn&rsquo;t go as far as some functional
programming languages to forbid or discourage mutable state. It allows sharing
memory between threads and synchronizing with mutexes instead of relying purely
on channels. But it also definitely tries to be a (if not <em>the</em>) language to
write modern, scalable services in. As such, it <em>needs</em> to be a good language
to write this kind of stateless services. It needs to be able to make
<em>requests</em> the level of isolation instead of the process. At least to a degree.</p><p><em>(Side note: This seems to play into the statement of the author of above
article, who claims that context is mainly useful for server authors. I
disagree though. The general abstraction happens on many levels. E.g. a click
in a GUI counts just as much as a &ldquo;request&rdquo; for this abstraction as an HTTP
request)</em></p><p>This brings with it the requirement of being able to store some data on a
request-level. A simple example for this would be authentication in an <a href=https://grpc.io/>RPC
framework</a>. Different requests will have different
capabilities. If a request originates from an administrator it should have
higher privileges than if it originates from an unauthenticated user. This is
fundamentally <em>request scoped</em> data. Not process, service or application
scoped. And the RPC framework should treat this data as opaque. It is
application specific not only how that data looks en détail but also <em>what
kinds</em> of data it requires.</p><p>Just like an HTTP proxy or framework should not need to know about request
parameters or headers it doesn&rsquo;t consume, an RPC framework shouldn&rsquo;t know about
request scoped data the application needs.</p><hr><p>Let&rsquo;s try to look at specific ways this problem is (or could be) solved without
involving context. As an example, let&rsquo;s look at the problem of writing an HTTP
middleware. We want to be able to wrap an
<a href=http://godoc.org/net/http#Handler>http.Handler</a> (or a variation thereof) in a
way that allows the wrapper to attach data to a request.</p><p>To get static type-safety we could try to add some type to our handlers. We
could have a type containing all the data we want to keep request scoped and
pass that through our handlers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Data</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Username</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Log</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl>	<span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>HandleA</span><span class=p>(</span><span class=nx>d</span> <span class=nx>Data</span><span class=p>,</span> <span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>d</span><span class=p>.</span><span class=nx>Username</span> <span class=p>=</span> <span class=s>&#34;admin&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nf>HandleB</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>HandleB</span><span class=p>(</span><span class=nx>d</span> <span class=nx>Data</span><span class=p>,</span> <span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>However, this would prevent us from writing reusable Middleware. Any such
middleware would need to make it possible to wrap <code>HandleA</code>. But as it&rsquo;s
supposed to be reusable, it can&rsquo;t know the type of the Data parameter. You
could make the <code>Data</code> parameter an <code>interface{}</code> and require type-assertion.
But that wouldn&rsquo;t allow the middleware to inject its own data. You might think
that interface type-assertions could solve this, but they have <a href=/posts/2017-07-30-the-trouble-with-optional-interfaces/>their own set
of problems</a>.
In the end, this approach won&rsquo;t bring you actual additional type safety.</p><p>We could store our state keyed by requests. For example, an authentication
middleware could do</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Authenticator</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>	<span class=nx>users</span> <span class=kd>map</span><span class=p>[</span><span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>wrapped</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>Authenticator</span><span class=p>)</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>users</span><span class=p>[</span><span class=nx>req</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;admin&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>delete</span><span class=p>(</span><span class=nx>a</span><span class=p>.</span><span class=nx>users</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>wrapped</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>Authenticator</span><span class=p>)</span> <span class=nf>Username</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>a</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nx>users</span><span class=p>[</span><span class=nx>req</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This has <em>some</em> advantages over context:</p><ul><li>It is more type-safe.</li><li>While we still can&rsquo;t express a requirement on an authenticated user
statically, we <em>can</em> express a requirement on an <code>Authenticator</code></li><li>It&rsquo;s not susceptible to name-collisions anymore.</li></ul><p>However, we bought this with shared mutable state and the associated lock
contention. It can also break in subtle ways, if one of the intermediate
handlers decides to create a new Request - as
<a href=https://github.com/golang/go/blob/816deacc70f48d14638104e284b3b75d5b1e8036/src/net/http/server.go#L1946>http.StripPrefix</a>
is going to do soon.</p><p>Lastly, we might consider to store this data in the
<a href=http://godoc.org/net/http#Request>*http.Request</a> itself, for example by
adding it as a stringified <a href=http://godoc.org/net/url#URL.RawQuery>URL parameter</a>.
This too has several downsides, though. In fact it checks almost every single
item from our list of downsides of <code>context.Context</code>. The exception is being a
linked list. But even that advantage we buy with a lack of thread safety. If
that request is passed to a handler in a different goroutine we get into
trouble.</p><p><em>(Side note: All of this also gives us a good idea of why the context package
is implemented as a linked list. It allows all the data stored in it to be
read-only and thus inherently thread-safe. There will never be any
lock-contention around the shared state saved in a context.Context, because
there will never be any need for locks)</em></p><p>So we see that it is really hard (if not impossible) to solve this problem of
having data attached to requests in independently executing handlers while also
doing significantly better than with <code>context.Value</code>. Whether you believe this
a problem worth solving or not is debatable. But <em>if</em> you want to get this kind
of scalable abstraction you will have to rely on <em>something</em> like
<code>context.Value</code>.</p><hr><p>No matter whether you are now convinced of the usefulness of <code>context.Value</code> or
still doubtful: The disadvantages can clearly not be ignored in either case.
But we can try to find a way to improve on it. To eliminate some of the
disadvantages while still keeping its useful attributes.</p><p>One way to do that (in Go 2) would be to introduce <a href=https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping>dynamically scoped</a>
variables. Semantically, each dynamically scoped variable represents a separate
stack. Every time you change its value the new one is pushed to the stack. It
is pop&rsquo;ed off again after your function returns. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Let&#39;s make up syntax! Only a tiny bit, though.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>dyn</span> <span class=nx>x</span> <span class=p>=</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Foo:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Bar:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=p>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Bar:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Baz</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Bar:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Baz</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Baz:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=p>=</span> <span class=mi>1337</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Baz:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;main:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>Baz</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;main:&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>main</span><span class=p>:</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>:</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl><span class=nx>Bar</span><span class=p>:</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl><span class=nx>Bar</span><span class=p>:</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nx>Baz</span><span class=p>:</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nx>Baz</span><span class=p>:</span> <span class=mi>1337</span>
</span></span><span class=line><span class=cl><span class=nx>Bar</span><span class=p>:</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nx>Baz</span><span class=p>:</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl><span class=nx>Baz</span><span class=p>:</span> <span class=mi>1337</span>
</span></span><span class=line><span class=cl><span class=nx>main</span><span class=p>:</span> <span class=mi>23</span>
</span></span></code></pre></div><p>There are several notes about what I would imagine the semantics to be here.</p><ul><li>I would only allow <code>dyn</code>-declarations at package scope. Given that there is
no way to refer to a local identifier of a different function, that seems
logical.</li><li>A newly spawned goroutine would inherit the dynamic values of its parent
function. If we implement them (like <code>context.Context</code>) via linked lists, the
shared data will be read-only. The head-pointer would need to be stored in
some kind of goroutine-local storage. Thus, writes only ever modify this
local storage (and the global heap), so wouldn&rsquo;t need to be synchronized
specifically.</li><li>The dynamic scoping would be independent of the package the variable is
declared in. That is, if <code>foo.A</code> modifies a dynamic <code>bar.X</code>, then that
modification is visible to all subsequent callees of <code>foo.A</code>, whether they
are in <code>bar</code> or not.</li><li>Dynamically scoped variables would likely not be addressable. Otherwise we&rsquo;d
loose concurrency safety and the clear &ldquo;down-stack&rdquo; semantics of dynamic
scoping. It would still be possible to declare <code>dyn x *int</code> though and thus
get mutable state to pass on.</li><li>The compiler would allocate the necessary storage for the stacks, initialized
to their initializers and emit the necessary instructions to push and pop
values on writes and returns. To account for panics and early returns, a
mechanism like <code>defer</code> would be needed.</li><li>There is some confusing overlap with package-scoped variables in this design.
Most notably, from seeing <code>foo.X = Y</code> you wouldn&rsquo;t be able to tell whether
<code>foo.X</code> is dynamically scoped or not. Personally, I would address that by
removing package-scoped variables from the language. They could still be
emulated by declaring a dynamically-scoped pointer and never modifying it.
Its pointee is then a shared variable. But most usages of package-scoped
variables would probably just use dynamically scoped variables.</li></ul><p>It is instructive to compare this design against the list of disadvantages
identified for <code>context</code>.</p><ul><li>API clutter would be removed, as request-scoped data would now be
part of the language without needing explicit passing.</li><li>Dynamically scoped variables are statically type-safe. Every <code>dyn</code>
declaration has an unambiguous type.</li><li>It would still not be possible to express critical dependencies on
dynamically scoped variables but they also couldn&rsquo;t be <em>absent</em>. At worst
they&rsquo;ll have their zero value.</li><li>Name collision is eliminated. Identifiers are, just like variable names,
properly scoped.</li><li>While a naive implementation would still use linked lists, they wouldn&rsquo;t be
inefficient. Every <code>dyn</code> declaration gets its own list and only the
head-pointer ever needs to be operated on.</li><li>The design is still &ldquo;magic&rdquo; to a degree. But that &ldquo;magic&rdquo; is problem-inherent
(at least if I understand the criticism correctly). The magic is exactly the
possibility to pass values transparently through API boundaries.</li></ul><p>Lastly, I&rsquo;d like to mention cancellation. While the author of above post
dedicates most of it to cancellation, I have so far mostly ignored it. That&rsquo;s
because I believe cancellation to be trivially implementable on top of a good
<code>context.Value</code> implementation. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// $GOROOT/src/done
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C is closed when the current execution context (e.g. request) should be
</span></span></span><span class=line><span class=cl><span class=c1>// cancelled.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>dyn</span> <span class=nx>C</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// CancelFunc returns a channel that gets closed, when C is closed or cancel is
</span></span></span><span class=line><span class=cl><span class=c1>// called.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>CancelFunc</span><span class=p>()</span> <span class=p>(</span><span class=nx>c</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>,</span> <span class=nx>cancel</span> <span class=kd>func</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Note: We can&#39;t modify C here, because it is dynamically scoped, which is
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// why we return a new channel that the caller should store.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>o</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>	<span class=nx>cancel</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>o</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>))</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>C</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=o>&lt;-</span><span class=nx>C</span>
</span></span><span class=line><span class=cl>			<span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ch</span><span class=p>,</span> <span class=nx>cancel</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $GOPATH/example.com/foo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>foo</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>cancel</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>done</span><span class=p>.</span><span class=nx>C</span><span class=p>,</span> <span class=nx>cancel</span> <span class=p>=</span> <span class=nx>done</span><span class=p>.</span><span class=nf>CancelFunc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Do things
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This cancellation mechanism would now be usable from any library that wants it
without needing any explicit support in its API. This would also make it easy
to add cancellation capabilities retroactively.</p><hr><p>Whether you <em>like</em> this design or not, it demonstrates that we shouldn&rsquo;t rush
to calling for the removal of <code>context</code>. Removing it is only one possible
solution to its downsides.</p><p>If the removal of <code>context.Context</code> actually comes up, the question we should
ask is &ldquo;do we want a canonical way to manage request-scoped values and at what
cost&rdquo;. Only then should we ask what the best implementation of this would be
or whether to remove the current one.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=Bookwyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>