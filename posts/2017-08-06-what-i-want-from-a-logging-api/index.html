<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What I want from a logging API | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="Logging in Go is a notoriously lacking topic in the standard library. There are 3rd-party libraries trying to work around this. I&rsquo;m trying to explain, why I find them still lacking"><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-08-06-what-i-want-from-a-logging-api/><link crossorigin=anonymous href=/assets/css/stylesheet.9c4f5aa85dab72ee82fc33b8dfb12a3f7459e6c1b389f9fae73095efa3ecb4d6.css integrity="sha256-nE9aqF2rcu6C/DO437EqP3RZ5sGzifn65zCV76PstNY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="What I want from a logging API"><meta property="og:description" content="Logging in Go is a notoriously lacking topic in the standard library. There are 3rd-party libraries trying to work around this. I&rsquo;m trying to explain, why I find them still lacking"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-08-06-what-i-want-from-a-logging-api/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-06T20:08:56+00:00"><meta property="article:modified_time" content="2017-08-06T20:08:56+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="What I want from a logging API"><meta name=twitter:description content="Logging in Go is a notoriously lacking topic in the standard library. There are 3rd-party libraries trying to work around this. I&rsquo;m trying to explain, why I find them still lacking"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"What I want from a logging API","item":"https://blog.merovius.de/posts/2017-08-06-what-i-want-from-a-logging-api/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What I want from a logging API","name":"What I want from a logging API","description":"Logging in Go is a notoriously lacking topic in the standard library. There are 3rd-party libraries trying to work around this. I\u0026rsquo;m trying to explain, why I find them still lacking","keywords":["golang","programming"],"articleBody":"This is intended as an Experience Report about logging in Go. There are many like it but this one is mine.\nI have been trying for a while now to find (or build) a logging API in Go that fills my needs. There are several things that make this hard to get “right” though. This is my attempt to describe them coherently in one place.\nWhen I say “logging”, I mean informational text messages for human consumption used to debug a specific problem. There is an idea currently gaining traction in the Go community called “structured logging”. logrus is a popular package that implements this idea. If you haven’t heard of it, you might want to skim its README. And while I definitely agree that log-messages should contain some structural information that is useful for later filtering (like the current time or a request ID), I believe the idea as often advocated is somewhat misguided and conflates different use cases that are better addressed otherwise. For example, if you are tempted to add a structured field to your log containing an HTTP response code to alert on too many errors, you probably want to use metrics and timeseries instead. If you want to follow a field through a variety of systems, you probably want to annotate a trace. If you want analytics like calculating daily active users or what used user-agents are used how often, you probably want what I like to call request annotations, as these are properties of a request, not of a log-line. If you exclude all these use cases, there isn’t a lot left for structured logging to address.\nThe logs I am talking about is to give a user or the operator of a software more insight into what is going on under the covers. The default assumption is, that they are not looked at until something goes wrong: Be it a test failing, an alerting system notifying of an issue or a bug report being investigated or a CLI not doing what the user expected. As such it is important that they are verbose to a certain degree. As an operator, I don’t want to find out that I can’t troubleshoot a problem because someone did not log a critical piece of information. An API that requires (or encourages) me to only log structured data will ultimately only discourage me from logging at all. In the end, some form of log.Debugf(\"Error reading foo: %v\", err) is the perfect API for my use case. Any structured information needed to make this call practically useful should be part of the setup phase of whatever log is.\nThe next somewhat contentious question is whether or not the API should support log levels (and if so, which). My personal short answer is “yes and the log levels should be Error, Info and Debug”. I could try and justify these specific choices but I don’t think that really helps; chalk it up to personal preference if you like. I believe having some variation on the verbosity of logs is very important. A CLI should be quiet by default but be able to tell the user more specifically where things went wrong on request. A service should be debuggable in depth, but unconditionally logging verbosely would have in unacceptable latency impact in production and too heavy storage costs. There need to be some logs by default though, to get quick insights during an emergency or in retrospect. So, those three levels seem fine to me.\nLastly what I need from a logging API, is the possibility to set up verbosity and log sinks both horizontally and vertically. What I mean by that is that software is usually build in layers. They could be individual microservices, Go packages or types. Requests will then traverse these layers vertically, possibly branching out and interleaved to various degrees.\nDepending on what and how I am debugging, it makes sense to increase the log verbosity of a particular layer (say I narrowed down the problem to shared state in a particular handler and want to see what happens to that state during multiple requests) or for a particular request (say, I narrowed down a problem to “requests which have header FOO set to BAR” and want to follow one of them to get a detailed view of what it does). Same with logging sinks, for example, a request initiated by a test should get logged to its *testing.T with maximum verbosity, so that I get a detailed context about it if and only if the test fails to immediately start debugging. These settings should be possible during runtime without a restart. If I am debugging a production issue, I don’t want to change a command line flag and restart the service.\nLet’s try to implement such an API.\nWe can first narrow down the design space a bit, because we want to use testing.T as a logging sink. A T has several methods that would suit our needs well, most notably Logf. This suggest an interface for logging sinks that looks somewhat like this:\ntype Logger interface { Logf(format string, v ...interface{}) } type simpleLogger struct { w io.Writer } func (l simpleLogger) Logf(format string, v ...interface{}) { fmt.Fprintf(l.w, format, v...) } func NewLogger(w io.Writer) Logger { return simpleLogger{w} } This has the additional advantage, that we can add easily implement a Discard-sink, that has minimal overhead (not even the allocations of formatting the message):\ntype Discard struct{} func (Discard) Logf(format string, v ...interface{}) {} The next step is to get leveled logging. The easiest way to achieve this is probably\ntype Logs struct { Debug Logger Info Logger Error Logger } func DiscardAll() Logs { return Logs{ Debug: Discard{}, Info: Discard{}, Error: Discard{}, } } By putting a struct like this (or its constituent fields) as members of a handler, type or package, we can get the horizontal configurability we are interested in.\nTo get vertical configurability we can use context.Value - as much as it’s frowned upon by some, it is the canonical way to get request-scoped behavior/data in Go. So, let’s add this to our API:\ntype ctxLogs struct{} func WithLogs(ctx context.Context, l Logs) context.Context { return context.WithValue(ctx, ctxLogs{}, l) } func GetLogs(ctx context.Context, def Logs) Logs { // If no Logs are in the context, we default to its zero-value, \t// by using the ,ok version of a type-assertion and throwing away \t// the ok. \tl, _ := ctx.Value(ctxLogs{}).(Logs) if l.Debug == nil { l.Debug = def.Debug } if l.Info == nil { l.Info = def.Info } if l.Error == nil { l.Error = def.Error } return l } So far, this is a sane, simple and easy to use logging API. For example:\ntype App struct { L log.Logs } func (a *App) ServeHTTP(res http.ResponseWriter, req *http.Request) { l := log.GetLogs(req.Context(), a.L) l.Debug.Logf(\"%s %s\", req.Method, req.URL.Path) // ... } The issue with this API, however, is that it is completely inflexible, if we want to preserve useful information like the file and line number of the caller. Say, I want to implement the equivalent of io.MultiWriter. For example, I want to write logs both to os.Stderr and to a file and to a network log service.\nI might try to implement that via\nfunc MultiLogger(ls ...Logger) Logger { return multiLog{ls} } type multiLog struct { loggers []Logger } func (m *multiLog) Logf(format string, v ...interface{}) { for _, l := range m.loggers { m.Logf(format, v...) } } However, now the caller of Logf of the individual loggers will be the line in (*multiLog).Logf, not the line of its caller. Thus, caller information will be useless. There are two APIs currently existing in the stdlib to work around this:\n (testing.T).Helper (from Go 1.9) lets you mark a frame as a test-helper. When the caller-information is then added to the log-output, all frames marked as a helper is skipped. So, theoretically, we could add a Helper method to our Logger interface and require that to be called in each wrapper. However, Helper itself uses the same caller-information. So all wrappers must call the Helper method of the underlying *testing.T, without any wrapping methods. Even embedding doesn’t help, as the Go compiler creates an implicit wrapper for that. (log.Logger).Output lets you specify a number of call-frames to skip. We could add a similar method to our log sink interface. And wrapping loggers would then need to increment the passed in number, when calling a wrapped sink. It’s possible to do this, but it wouldn’t help with test-logs.  This is a very similar problem to the ones I wrote about last week. For now, I am using the technique I described as Extraction Methods. That is, the modified API is now this:\n// Logger is a logging sink. type Logger interface { // Logf logs a text message with the given format and values to the sink. \tLogf(format string, v ...interface{}) // Helpers returns a list of Helpers to call into from all helper methods, \t// when wrapping this Logger. This is used to skip frames of logging \t// helpers when determining caller information. \tHelpers() []Helper } type Helper interface { // Helper marks the current frame as a helper method. It is then skipped \t// when determining caller information during logging. \tHelper() } // Callers can be used as a Helper for log sinks who want to log caller // information. An empty Callers is valid and ready for use. type Callers struct { // ... } // Helper marks the calling method as a helper. When using Callers in a // Logger, you should also call this to mark your methods as helpers. func (*Callers) Helper() { // ... } type Caller struct { Name string File string Line int } // Caller can be used to determine the caller of Logf in a Logger, skipping all // frames marked via Helper. func (*Callers) Caller() Caller { // ... } // TestingT is a subset of the methods of *testing.T, so that this package // doesn't need to import testing. type TestingT interface { Logf(format string, v ...interface{}) Helper() } // Testing returns a Logger that logs to t. Log lines are discarded, if the // test succeeds. func Testing(t TestingT) Logger { return testLogger{t} } type testLogger struct { t TestingT } func (l testLogger) Logf(format string, v ...interface{}) { l.t.Helper() l.t.Logf(format, v...) } func (l testLogger) Helpers() []Helper { return []Helper{l.t} } // New returns a logger writing to w, prepending caller-information. func New(w io.Writer) Logger { return simple{w, new(Callers)} } type simple struct { w io.Writer c *Callers } func (l *simple) Logf(format string, v ...interface{}) { l.c.Helper() c := l.c.Caller() fmt.Fprintf(l.w, \"%s:%d: \" + format, append([]interface{}{c.File, c.Line}, v...)...) } func (l *simple) Helpers() []Helper { return []Helper{l.c} } // Discard discards all logs. func Discard() Logger { return discard{} } type discard struct{} func (Discard) Logf(format string, v ...interface{}) { } func (Discard) Helpers() []Helper { return nil } // MultiLogger duplicates all Logf-calls to a list of loggers. func MultiLogger(ls ...Logger) Logger { var m multiLogger for _, l := range ls { m.helpers = append(m.helpers, l.Helpers()...) } m.loggers = ls return m } type multiLogger struct { loggers []Logger helpers []Helper } func (m multiLogger) Logf(format string, v ...interface{}) { for _, h := range m.helpers { h.Helper() } for _, l := range m.loggers { l.Logf(format, v...) } } func (m multiLogger) Helpers() []Helper { return m.helpers } It’s a kind of clunky API and I have no idea about the performance implications of all the Helper-code. But it does work, so it is, what I ended up with for now. Notably, it puts the implementation complexity into the implementers of Logger, in favor of making the actual consumers of them as simple as possible.\n","wordCount":"1970","inLanguage":"en","datePublished":"2017-08-06T20:08:56Z","dateModified":"2017-08-06T20:08:56Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-08-06-what-i-want-from-a-logging-api/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What I want from a logging API</h1><div class=post-meta><span title="2017-08-06 20:08:56 +0000 UTC">August 6, 2017</span></div></header><div class=post-content><p><strong>This is intended as an <a href=https://github.com/golang/go/wiki/ExperienceReports>Experience
Report</a> about logging in
Go. There are many like it but this one is mine.</strong></p><p>I have been trying for a while now to find (or build) a logging API in Go that
fills my needs. There are several things that make this hard to get &ldquo;right&rdquo;
though. This is my attempt to describe them coherently in one place.</p><p>When I say &ldquo;logging&rdquo;, I mean informational text messages for human consumption
used to debug a specific problem. There is an idea currently gaining traction
in the Go community called &ldquo;structured logging&rdquo;.
<a href=https://github.com/sirupsen/logrus>logrus</a> is a popular package that
implements this idea. If you haven&rsquo;t heard of it, you might want to skim its
README. And while I definitely agree that log-messages should
contain some structural information that is useful for later filtering (like
the current time or a request ID), I believe the idea as often advocated is
somewhat misguided and conflates different use cases that are better addressed
otherwise. For example, if you are tempted to add a structured field to your
log containing an HTTP response code to alert on too many errors, you probably
want to use <a href=https://landing.google.com/sre/book/chapters/practical-alerting.html>metrics and
timeseries</a>
instead. If you want to follow a field through a variety of systems, you
probably want to <a href=https://research.google.com/pubs/pub36356.html>annotate a
trace</a>. If you want analytics
like calculating daily active users or what used user-agents are used how
often, you probably want what I like to call <a href=https://research.google.com/pubs/pub36632.html>request
annotations</a>, as these are
properties of a request, not of a log-line. If you exclude all these use cases,
there isn&rsquo;t a lot left for structured logging to address.</p><p>The logs I am talking about is to give a user or the operator of a software
more insight into what is going on under the covers. The default assumption is,
that they are not looked at until something goes wrong: Be it a test failing,
an alerting system notifying of an issue or a bug report being investigated or
a CLI not doing what the user expected. As such it is important that they are
verbose to a certain degree. As an operator, I don&rsquo;t want to find out that I
can&rsquo;t troubleshoot a problem because someone did not log a critical piece of
information. An API that requires (or encourages) me to only log structured
data will ultimately only discourage me from logging at all. In the end, some
form of <code>log.Debugf("Error reading foo: %v", err)</code> is the perfect API for my use
case. Any structured information needed to make this call practically useful
should be part of the setup phase of whatever <code>log</code> is.</p><p>The next somewhat contentious question is whether or not the API should support
log levels (and if so, which). My personal short answer is &ldquo;yes and the log
levels should be Error, Info and Debug&rdquo;. I could try and justify these specific
choices but I don&rsquo;t think that really helps; chalk it up to personal
preference if you like. I believe having <em>some</em> variation on the
verbosity of logs is very important. A CLI should be quiet by default but be
able to tell the user more specifically where things went wrong on request. A
service should be debuggable in depth, but unconditionally logging verbosely
would have in unacceptable latency impact in production and too heavy storage
costs. There need to be <em>some</em> logs by default though, to get quick insights
during an emergency or in retrospect. So, those three levels seem fine to me.</p><p>Lastly what I need from a logging API, is the possibility to set up verbosity
and log sinks both horizontally <em>and</em> vertically. What I mean by that is that
software is usually build in layers. They could be individual microservices,
Go packages or types. Requests will then traverse these layers vertically,
possibly branching out and interleaved to various degrees.</p><p><img loading=lazy src=/assets/request_forest.svg alt="Request forest"></p><p>Depending on what and how I am debugging, it makes sense to increase the log
verbosity of a particular layer (say I narrowed down the problem to shared
state in a particular handler and want to see what happens to that state during
multiple requests) or for a particular request (say, I narrowed down a problem
to &ldquo;requests which have header FOO set to BAR&rdquo; and want to follow one of them
to get a detailed view of what it does). Same with logging sinks, for example,
a request initiated by a test should get logged to its <code>*testing.T</code> with
maximum verbosity, so that I get a detailed context about it if and only if the
test fails to immediately start debugging. These settings should be possible
during runtime without a restart. If I am debugging a production issue, I
don&rsquo;t want to change a command line flag and restart the service.</p><p>Let&rsquo;s try to implement such an API.</p><p>We can first narrow down the design space a bit, because we want to use
<code>testing.T</code> as a logging sink. A <code>T</code> has several methods that would suit our
needs well, most notably <a href=http://godoc.org/testing#T.Logf>Logf</a>. This suggest
an interface for logging sinks that looks somewhat like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Logger</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>simpleLogger</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>simpleLogger</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>l</span><span class=p>.</span><span class=nx>w</span><span class=p>,</span> <span class=nx>format</span><span class=p>,</span> <span class=nx>v</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewLogger</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>simpleLogger</span><span class=p>{</span><span class=nx>w</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This has the additional advantage, that we can add easily implement a
Discard-sink, that has minimal overhead (not even the allocations of
formatting the message):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Discard</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>Discard</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{}</span>
</span></span></code></pre></div><p>The next step is to get leveled logging. The easiest way to achieve this is
probably</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Logs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Debug</span> <span class=nx>Logger</span>
</span></span><span class=line><span class=cl>	<span class=nx>Info</span> <span class=nx>Logger</span>
</span></span><span class=line><span class=cl>	<span class=nx>Error</span> <span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DiscardAll</span><span class=p>()</span> <span class=nx>Logs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>Logs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Debug</span><span class=p>:</span> <span class=nx>Discard</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>		<span class=nx>Info</span><span class=p>:</span> <span class=nx>Discard</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>		<span class=nx>Error</span><span class=p>:</span> <span class=nx>Discard</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By putting a struct like this (or its constituent fields) as members of a
handler, type or package, we can get the horizontal configurability we are
interested in.</p><p>To get vertical configurability we can use
<a href=http://godoc.org/context#Context.Value>context.Value</a> - as much as it&rsquo;s
frowned upon by some, it is the canonical way to get request-scoped
behavior/data in Go. So, let&rsquo;s add this to our API:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ctxLogs</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithLogs</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>l</span> <span class=nx>Logs</span><span class=p>)</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>ctxLogs</span><span class=p>{},</span> <span class=nx>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GetLogs</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>def</span> <span class=nx>Logs</span><span class=p>)</span> <span class=nx>Logs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// If no Logs are in the context, we default to its zero-value,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// by using the ,ok version of a type-assertion and throwing away
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// the ok.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>l</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>ctxLogs</span><span class=p>{}).(</span><span class=nx>Logs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>l</span><span class=p>.</span><span class=nx>Debug</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>Debug</span> <span class=p>=</span> <span class=nx>def</span><span class=p>.</span><span class=nx>Debug</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>l</span><span class=p>.</span><span class=nx>Info</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>Info</span> <span class=p>=</span> <span class=nx>def</span><span class=p>.</span><span class=nx>Info</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>l</span><span class=p>.</span><span class=nx>Error</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>Error</span> <span class=p>=</span> <span class=nx>def</span><span class=p>.</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>l</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So far, this is a sane, simple and easy to use logging API. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>App</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>L</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Logs</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>App</span><span class=p>)</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span> <span class=o>:=</span> <span class=nx>log</span><span class=p>.</span><span class=nf>GetLogs</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nf>Context</span><span class=p>(),</span> <span class=nx>a</span><span class=p>.</span><span class=nx>L</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>Debug</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=s>&#34;%s %s&#34;</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>Method</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The issue with this API, however, is that it is completely inflexible, if we
want to preserve useful information like the file and line number of the
caller. Say, I want to implement the equivalent of
<a href=http://godoc.org/io#MultiWriter>io.MultiWriter</a>. For example, I want to write
logs both to <code>os.Stderr</code> and to a file and to a network log service.</p><p>I might try to implement that via</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MultiLogger</span><span class=p>(</span><span class=nx>ls</span> <span class=o>...</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>multiLog</span><span class=p>{</span><span class=nx>ls</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>multiLog</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>loggers</span> <span class=p>[]</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>multiLog</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>l</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span><span class=p>.</span><span class=nx>loggers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>v</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, now the caller of <code>Logf</code> of the individual loggers will be the line in
<code>(*multiLog).Logf</code>, <em>not</em> the line of its caller. Thus, caller information will
be useless. There are two APIs currently existing in the stdlib to work around this:</p><ol><li><a href=https://tip.golang.org/pkg/testing/#T.Helper>(testing.T).Helper</a> (from
Go 1.9) lets you mark a frame as a test-helper. When the caller-information
is then added to the log-output, all frames marked as a helper is skipped.
So, theoretically, we could add a <code>Helper</code> method to our Logger interface
and require that to be called in each wrapper. However, <code>Helper</code> <em>itself</em>
uses the same caller-information. So all wrappers must call the <code>Helper</code>
method of the <em>underlying <code>*testing.T</code></em>, without any wrapping methods. Even
embedding doesn&rsquo;t help, as the Go compiler creates an <a href=https://play.golang.org/p/Z8MHOrGAAt>implicit wrapper</a>
for that.</li><li><a href=http://godoc.org/log#Logger.Output>(log.Logger).Output</a> lets you
specify a number of call-frames to skip. We could add a similar method to
our log sink interface. And wrapping loggers would then need to increment
the passed in number, when calling a wrapped sink. It&rsquo;s possible to do this,
but it wouldn&rsquo;t help with test-logs.</li></ol><p>This is a very similar problem to the ones I wrote about
<a href=/posts/2017-07-30-the-trouble-with-optional-interfaces/>last week</a>.
For now, I am using the technique I described as <a href=/posts/2017-07-30-the-trouble-with-optional-interfaces/#extraction-methods>Extraction
Methods</a>.
That is, the modified API is now this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Logger is a logging sink.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Logger</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Logf logs a text message with the given format and values to the sink.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Helpers returns a list of Helpers to call into from all helper methods,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// when wrapping this Logger. This is used to skip frames of logging
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// helpers when determining caller information.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Helpers</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Helper</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Helper</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Helper marks the current frame as a helper method. It is then skipped
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// when determining caller information during logging.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Callers can be used as a Helper for log sinks who want to log caller
</span></span></span><span class=line><span class=cl><span class=c1>// information. An empty Callers is valid and ready for use.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Callers</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Helper marks the calling method as a helper. When using Callers in a
</span></span></span><span class=line><span class=cl><span class=c1>// Logger, you should also call this to mark your methods as helpers.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>Callers</span><span class=p>)</span> <span class=nf>Helper</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Caller</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>File</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Line</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Caller can be used to determine the caller of Logf in a Logger, skipping all
</span></span></span><span class=line><span class=cl><span class=c1>// frames marked via Helper.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>Callers</span><span class=p>)</span> <span class=nf>Caller</span><span class=p>()</span> <span class=nx>Caller</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// TestingT is a subset of the methods of *testing.T, so that this package
</span></span></span><span class=line><span class=cl><span class=c1>// doesn&#39;t need to import testing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>TestingT</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Testing returns a Logger that logs to t. Log lines are discarded, if the
</span></span></span><span class=line><span class=cl><span class=c1>// test succeeds.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Testing</span><span class=p>(</span><span class=nx>t</span> <span class=nx>TestingT</span><span class=p>)</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>testLogger</span><span class=p>{</span><span class=nx>t</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>testLogger</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span> <span class=nx>TestingT</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>testLogger</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>t</span><span class=p>.</span><span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>t</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>v</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>testLogger</span><span class=p>)</span> <span class=nf>Helpers</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Helper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>[]</span><span class=nx>Helper</span><span class=p>{</span><span class=nx>l</span><span class=p>.</span><span class=nx>t</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// New returns a logger writing to w, prepending caller-information.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>simple</span><span class=p>{</span><span class=nx>w</span><span class=p>,</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Callers</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>simple</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>*</span><span class=nx>Callers</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>simple</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nf>Caller</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>l</span><span class=p>.</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;%s:%d: &#34;</span> <span class=o>+</span> <span class=nx>format</span><span class=p>,</span> <span class=nb>append</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{}{</span><span class=nx>c</span><span class=p>.</span><span class=nx>File</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>Line</span><span class=p>},</span> <span class=nx>v</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>simple</span><span class=p>)</span> <span class=nf>Helpers</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Helper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>[]</span><span class=nx>Helper</span><span class=p>{</span><span class=nx>l</span><span class=p>.</span><span class=nx>c</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Discard discards all logs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Discard</span><span class=p>()</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>discard</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>discard</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>Discard</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>Discard</span><span class=p>)</span> <span class=nf>Helpers</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Helper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// MultiLogger duplicates all Logf-calls to a list of loggers.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>MultiLogger</span><span class=p>(</span><span class=nx>ls</span> <span class=o>...</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m</span> <span class=nx>multiLogger</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>l</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>.</span><span class=nx>helpers</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>helpers</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Helpers</span><span class=p>()</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>loggers</span> <span class=p>=</span> <span class=nx>ls</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>multiLogger</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>loggers</span> <span class=p>[]</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl>	<span class=nx>helpers</span> <span class=p>[]</span><span class=nx>Helper</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>multiLogger</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>v</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>h</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span><span class=p>.</span><span class=nx>helpers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>h</span><span class=p>.</span><span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>l</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span><span class=p>.</span><span class=nx>loggers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>v</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>multiLogger</span><span class=p>)</span> <span class=nf>Helpers</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Helper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>helpers</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It&rsquo;s a kind of clunky API and I have no idea about the performance implications
of all the Helper-code. But it <em>does</em> work, so it is, what I ended up with for
now. Notably, it puts the implementation complexity into the <em>implementers</em> of
Logger, in favor of making the actual consumers of them as simple as possible.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=/atom.xml target=_blank rel="noopener noreferrer me" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://www.tumblr.com/merovius target=_blank rel="noopener noreferrer me" title=Tumblr><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentcolor"><path d="M14.563 24c-5.093.0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941.0 9.999.0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>