<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What even is error handling? | Mero's Blog</title><meta name=keywords content="golang,programming,thoughtleading"><meta name=description content="I philosophize about error handling, what it actually means and how to characterize Go&rsquo;s approach to it."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="What even is error handling?"><meta property="og:description" content="I philosophize about error handling, what it actually means and how to characterize Go&rsquo;s approach to it."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-21T23:40:00+00:00"><meta property="article:modified_time" content="2018-01-21T23:40:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="What even is error handling?"><meta name=twitter:description content="I philosophize about error handling, what it actually means and how to characterize Go&rsquo;s approach to it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"What even is error handling?","item":"https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What even is error handling?","name":"What even is error handling?","description":"I philosophize about error handling, what it actually means and how to characterize Go\u0026rsquo;s approach to it.","keywords":["golang","programming","thoughtleading"],"articleBody":"tl;dr: Error handling shouldn’t be about how to best propagate an error value, but how to make it destroy it (or make it irrelevant). To encourage myself to do that, I started removing errors from function returns wherever I found it at all feasible\nError handling in Go is a contentious and often criticized issue. There is no shortage on articles criticizing the approach taken, no shortage on articles giving advice on how to deal with it (or defending it) and also no shortage on proposals on how to improve it.\nDuring these discussion, I always feel there is something missing. The proposals for improvement usually deal with syntactical issues, how to avoid boilerplate. Then there is the other school of thought - where it’s not about syntax, but about how to best pass errors around. Dave Chaney wrote an often quoted blog post on the subject, where he lists all the ways error information can be mapped into the Go type system, why he considers them flawed and what he suggests instead. This school of thought regularly comes up with helper packages, to make wrapping or annotating errors easier. pkg/errors is very popular (and is grown out of the approach of above blog post) but upspin’s incarnation also gathered some attention.\nI am dissatisfied with both schools of thought. Overall, neither seems to explicitly address, what to me is the underlying question: What is error handling? In this post, I’m trying to describe how I interpret the term and why, to me, the existing approaches and discussions mostly miss the mark. Note, that I don’t claim this understanding to be universal - just how I would put into words my understanding of the topic.\n Let’s start with a maybe weird question: Why is the entry point into the program func main() and not func main() error? Personally, I start most of my programs writing\nfunc main() { if err := run(); err != nil { log.Fatal(err) } } func run() error { // … } This allows me to use defer, pass on errors and all that good stuff. So, why doesn’t the language just do that for me?\nWe can find part of the answer in this old golang-nuts thread. It is about return codes, instead of an error, but the principle is the same. And the best answer - in my opinion - is this:\n I think the returned status is OS-specific, and so Go the language should not define its type (Maybe some OS can only report 8-bit result while some other OS support arbitrary string as program status, there is considerable differences between that; there might even be environment that don’t support returning status code or the concept of status code simply doesn’t exist)\nI imagine some Plan 9 users might be disagree with the signature of os.Exit().\n So, in essence: Not all implementations would necessarily be able to assign a reasonable meaning to a return code (or error) from main. For example, an embedded device likely couldn’t really do anything with it. It thus seems preferable to not couple the language to this decision which only really makes semantic sense on a limited subset of implementations. Instead, we provide mechanisms in the standard library to exit the program or take any other reasonable action and then let the developer decide, under what circumstances they want to exit the program and with what code. Being coupled to a decision in the standard library is better than being coupled in the language itself. And a developer who targets a platform where an exit code doesn’t make sense, can take a different action instead.\nOf course, this leaves the programmer with a problem: What to do with errors? We could write it to stderr, but fmt.Fprintf also returns an error, so what to do with that one? Above I used log.Fatal, which does not return an error. What happens if the underlying io.Writer fails to write, though? What does log do with the resulting error? The answer is, of course: It ignores any errors.\nThe point is, that passing on the error is not a solution. Eventually every program will return to main (or os.Exit or panic) and the buck stops there. It needs to get handled and the signature of main enforces that the only way to do that is via side-effects - and if they fail, you just have to deal with that one too.\n Let’s continue with a similar question, that has a similar answer, that occasionally comes up: Why doesn’t ServeHTTP return an error? Sooner or later, people face the question of what to do with errors in their HTTP Handlers. For example, what if you are writing out a JSON object and Marshal fails? In fact, a lot of HTTP frameworks out there will define their own handler-type, which differs from http.Handler in exactly that way. But if everyone wants to return an error from their handler, why doesn’t the interface just add that error return itself? Was that just an oversight?\nI’m strongly arguing that no, this was not an oversight, but the correct design decision. Because the HTTP Server package can not handle any errors. An HTTP server is supposed to stay running, every request demands a response. If ServeHTTP would return an error, the server would have to do something with it, but what to do is highly application-specific. You might respond that it should serve a 500 error code, but in 99% of cases, that is the wrong thing to do. Instead you should serve a more specific error code, so the client knows (for example) whether to retry or if the response is cacheable. http.Server could also just ignore the error and instead drop the request on the floor, but that’s even worse. Or it could propagate it up the stack. But as we determined, eventually it would have to reach main and the buck stops there. You probably don’t want your server to come down, every time a request contains an invalid parameter.\nSo, given that a) every request needs an answer and b) the right answer is highly application-specific, the translation from errors into status codes has to happen in application code. And just like main enforces you to handle any errors via side-effects by not allowing you to return an error, so does http force you to handle any errors via writing a response by not allowing you to return an error.1\nSo, what are you supposed to do, when json.Marshal fails? Well, that depends on our application. Increment a metric. Log the error. panic. Write out a 500. Ignore it and write a 200. Commit to the uncomfortable knowledge, that sometimes, you can’t just pass the decision on what to do with an error to someone else.\n These two examples distill, I think, pretty well, what I view as error handling: An error is handled, when you destroy the error value. In that parlance, log.Error handles any errors of the underlying writer by not returning them. Every program needs to handle any error in some way, because main can’t return anything and the values need to go somewhere. Any HTTP handler needs to actually handle errors, by translating them into HTTP responses.\nAnd in that parlance, packages like pkg/errors have little, really, to do with error handling - instead, they provides you with a strategy for the case where you are not handling your errors. In the same vein, proposals that address the repetitive checking of errors via extra syntax do not really simplify their handling at all - they just move it around a bit. I would term that error propagation, instead - no doubt important, but keep in mind, that an error that was handled, doesn’t need to be propagated at all. So to me, a good approach to error handling would be characterized by mostly obviating the need for convenient error propagation mechanisms.\nAnd to me, at least, it seems that we talk too little about how to handle errors, in the end.\n Does Go encourage explicit error handling? This is the phrasing very often used to justify the repetitive nature, but I tend to disagree. Compare, for example, Go’s approach to checked exceptions in Java: There, errors are propagated via exceptions. Every exception that could be thrown (theoretically) must be annotated in the method signature. Any exception that you handle, has to be mentioned in a try-catch-statement. And the compiler will refuse to compile a program which does not explicitly mention how exceptions are handled. This, to me, seems like the pinnacle of explicit error handling. Rust, too, requires this - it introduces a ? operator to signify propagating an error, but that, still, is an explicit annotation. And apart from that, you can’t use the return value of a function that might propagate an error, without explicitly handling that error first.\nIn Go, on the other hand, it is not only perfectly acceptable to ignore errors when it makes sense (for example, I will always ignore errors created from writing to a *bytes.Buffer), it is actually often the only sensible thing to do. It is fundamentally not only okay, but 99% of times correct to just completely ignore the error returned by fmt.Println. And while it makes sense to check the error returned from json.Marshal in your HTTP handler against *json.MarshalError (to panic/log/complain loudly, because your code is buggy), any other errors should 99% of the time just be ignored. And that’s fine.\nI believe that to say Go encourages explicit error handling, it would need some mechanism of checked exceptions, Result types, or a requirement to pass an errcheck like analysis in the compiler.\nI think it would be closer to say, that Go encourages local error handling. That is, the code that handles an error, is close to the code that produced it. Exceptions encourages the two to be separated: There are usually several or many lines of code in a single try-block, all of which share one catch-block and it is hard to tell which of the lines produced it. And very often, the actual error location is several stack frames deep. You could contrast this with Go, where the error return is immediately obvious from the code and if you have a line of error handling, it is usually immediately attached to the function call that produced it.\nHowever, that still seems to come short, in my view. After all, there is nothing to force you to do that. And in fact, one of the most often cited articles about Go error handling is often interpreted to encourage exactly that. Plus, a lot of people end up writing return err far too often, simply propagating the error to be handled elsewhere. And the proliferation of error-wrapping libraries happens in the same vein: What their proponents phrase as “adding context to the error value”, I interpret as “adding back some of the information as a crutch, that you removed when passing the error to non-local handling code”. Sadly, far too often, the error then ends up not being handled at all, as everyone just takes advantage of that crutch. This leaves the end-user with an error message that is essentially a poorly formatted, non-contiguous stacktrace.\nPersonally, I’d characterize Go’s approach like this: In Go, error handling is simply first-class code. By forcing you to use exactly the same control-flow mechanisms and treat errors like any other data, Go encourages you to code your error handling. Often that means a bunch of control flow to catch and recover from any errors where they occur. But that’s not “clutter”, just as it is not “clutter” to write if n when writing a Fibonacci function (to choose a trivial example). It is just code. And yes, sometimes that code might also store the error away or propagate it out-of-band to reduce repetition where it makes sense - like in above blog post. But focussing on the “happy path” is a bit of a distraction: Your users will definitely be more happy about those parts of the control flow that make the errors disappear or transform them into clean, actionable advise on how to solve the problem.\nSo, in my reading, the title of the Go blog post puts the emphasis in slightly the wrong place - and often, people take the wrong message from it, in my opinion. Not “errors are values”, but “error handling is code”.\n So, what would be my advise for handling errors? To be honest, I don’t know yet - and I’m probably in no place to lecture anyone anyway.\nPersonally, I’ve been trying for the last couple of months to take a page out of http.Handlers playbook and try, as much as possible, to completely avoid returning an error. Instead of thinking “I should return an error here, in case I ever do any operation that fails”, I instead think “is there any way at all I can get away with not returning an error here?”. It doesn’t always work and sometimes you do have to pass errors around or wrap them. But I am forcing myself to think very hard about handling my errors and it encourages a programming-style of isolating failing components. The constraint of not being able to return an error tends to make you creative in how to handle it.\n I think this particular pattern is fine, though, personally, I don’t really see the point. Anything that builds an appError needs to provide the complete response anyway, so you might as well just write it out directly. YMMV.\n  You might be tempted to suggest, that you could define an HTTPError, containing the necessary info. Indeed, that’s what the official Go blog does, so it can’t be bad? And indeed, that is what they do, but note that they do not actually return an error in the end - they return an appError, which contains the necessary information. Exactly because they don’t know how to deal with general errors. So they translate any errors into a domain specific type that carries the response. So, that is not the same as returning an error. ↩︎\n   ","wordCount":"2369","inLanguage":"en","datePublished":"2018-01-21T23:40:00Z","dateModified":"2018-01-21T23:40:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What even is error handling?</h1><div class=post-meta><span title="2018-01-21 23:40:00 +0000 UTC">January 21, 2018</span></div></header><div class=post-content><p><strong>tl;dr: Error handling shouldn&rsquo;t be about how to best propagate an error
value, but how to make it destroy it (or make it irrelevant). To encourage
myself to do that, I started removing errors from function returns wherever I
found it at all feasible</strong></p><p>Error handling in Go is a contentious and often criticized issue. There is no
shortage on articles criticizing the approach taken, no shortage on articles
giving advice on how to deal with it (or defending it) and also no shortage on
proposals on how to improve it.</p><p>During these discussion, I always feel there is something missing. The
proposals for improvement usually deal with syntactical issues, how to avoid
boilerplate. Then there is the other school of thought - where it&rsquo;s not about
syntax, but about how to best pass errors around. Dave Chaney wrote <a href=https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully>an often
quoted blog post on the
subject</a>,
where he lists all the ways error information can be mapped into the Go type
system, why he considers them flawed and what he suggests instead.
This school of thought regularly comes up with helper packages, to make
wrapping or annotating errors easier.
<a href=https://github.com/pkg/errors>pkg/errors</a> is very popular (and is grown out
of the approach of above blog post) but <a href=https://godoc.org/github.com/upspin/upspin/errors#Error>upspin&rsquo;s
incarnation</a> also
gathered some attention.</p><p>I am dissatisfied with both schools of thought. Overall, neither seems to
explicitly address, what to me is the underlying question: What <em>is</em> error
handling? In this post, I&rsquo;m trying to describe how I interpret the term and
why, to me, the existing approaches and discussions mostly miss the mark. Note,
that I don&rsquo;t claim this understanding to be universal - just how <em>I</em> would put
into words my understanding of the topic.</p><hr><p>Let&rsquo;s start with a maybe weird question: Why is the entry point into the
program <code>func main()</code> and not <code>func main() error</code>? Personally, I start most of
my programs writing</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>run</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This allows me to use <code>defer</code>, pass on errors and all that good stuff. So, why
doesn&rsquo;t the language just do that for me?</p><p>We can find part of the answer in <a href=https://groups.google.com/d/topic/golang-nuts/6xl02B_MxdA/discussion>this old golang-nuts thread</a>.
It is about return codes, instead of an <code>error</code>, but the principle is the
same. And the best answer - in my opinion - is this:</p><blockquote><p>I think the returned status is OS-specific, and so Go the language should not
define its type (Maybe some OS can only report 8-bit result while some other
OS support arbitrary string as program status, there is considerable
differences between that; there might even be environment that don&rsquo;t support
returning status code or the concept of status code simply doesn&rsquo;t exist)</p><p>I imagine some Plan 9 users might be disagree with the signature of
<code>os.Exit()</code>.</p></blockquote><p>So, in essence: Not all implementations would necessarily be able to assign a
reasonable meaning to a return code (or error) from <code>main</code>. For example, an
embedded device likely couldn&rsquo;t really do anything with it. It thus seems
preferable to not couple the language to this decision which only <em>really</em> makes
semantic sense on a limited subset of implementations. Instead, we provide
mechanisms in the standard library to exit the program or take any other
reasonable action and then let the developer decide, under what circumstances
they want to exit the program and with what code. Being coupled to a decision
in the standard library is better than being coupled in the language itself.
And a developer who targets a platform where an exit code doesn&rsquo;t make sense,
can take a different action instead.</p><p>Of course, this leaves the programmer with a problem: What to do with errors?
We could write it to stderr, but <code>fmt.Fprintf</code> <em>also</em> returns an error, so what
to do with that one? Above I used <code>log.Fatal</code>, which does <em>not</em> return an error.
What happens if the underlying <code>io.Writer</code> fails to write, though? What
does <code>log</code> do with the resulting error? The answer is, of course: It ignores
any errors.</p><p>The point is, that passing on the error is not a solution. <em>Eventually</em> every
program will return to <code>main</code> (or <code>os.Exit</code> or panic) and the buck stops there.
It needs to get <em>handled</em> and the signature of <code>main</code> enforces that the only
way to do that is via side-effects - and if they fail, you just have to deal
with that one too.</p><hr><p>Let&rsquo;s continue with a similar question, that has a similar answer, that
occasionally comes up: Why doesn&rsquo;t <code>ServeHTTP</code> return an <code>error</code>? Sooner or
later, people face the question of what to do with errors in their HTTP
Handlers. For example, what if you are writing out a JSON object and
<code>Marshal</code> fails? In fact, a lot of HTTP frameworks out there will define their
own handler-type, which differs from <code>http.Handler</code> in exactly that way. But if
everyone wants to return an <code>error</code> from their handler, why doesn&rsquo;t the
interface just add that error return itself? Was that just an oversight?</p><p>I&rsquo;m strongly arguing that no, this was not an oversight, but the correct design
decision. Because the HTTP Server package <em>can not handle any errors</em>. An HTTP
server is supposed to stay running, every request demands a response. If
<code>ServeHTTP</code> would return an <code>error</code>, the server would have to do <em>something</em>
with it, but what to do is highly application-specific. You might respond that
it should serve a 500 error code, but in 99% of cases, that is the wrong thing
to do. Instead you should serve a more specific error code, so the client
knows (for example) whether to retry or if the response is cacheable.
<code>http.Server</code> could also just ignore the error and instead drop the request on
the floor, but that&rsquo;s even worse. Or it could propagate it up the stack. But as
we determined, eventually it would have to reach <code>main</code> and the buck stops
there. You probably don&rsquo;t want your server to come down, every time a request
contains an invalid parameter.</p><p>So, given that a) every request needs an answer and b) the right answer is
highly application-specific, the translation from errors into status codes
<em>has</em> to happen in application code. And just like <code>main</code> enforces you to
handle any errors via side-effects by not allowing you to return an <code>error</code>, so
does <code>http</code> force you to handle any errors via writing a response by not
allowing you to return an <code>error</code>.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>So, what are you supposed to do, when <code>json.Marshal</code> fails? Well, that depends
on our application. Increment a metric. Log the error. panic. Write out a 500.
Ignore it and write a 200. Commit to the uncomfortable knowledge, that
sometimes, you can&rsquo;t just pass the decision on what to do with an error to
someone else.</p><hr><p>These two examples distill, I think, pretty well, what I view as error
<em>handling</em>: An error is handled, when you destroy the error value. In that
parlance, <code>log.Error</code> handles any errors of the underlying writer by not
returning them. Every program needs to handle any error in <em>some</em> way, because
<code>main</code> can&rsquo;t return anything and the values need to go <em>somewhere</em>. Any HTTP
handler needs to actually <em>handle</em> errors, by translating them into HTTP
responses.</p><p>And in that parlance, packages like <code>pkg/errors</code> have little, really, to do with
error <em>handling</em> - instead, they provides you with a strategy for the case where
you are <em>not</em> handling your errors. In the same vein, proposals that address
the repetitive checking of errors via extra syntax do not really simplify their
handling at all - they just move it around a bit. I would term that <em>error
propagation</em>, instead - no doubt important, but keep in mind, that an error
that was <em>handled</em>, doesn&rsquo;t need to be propagated at all. So to me, a good
approach to error handling would be characterized by mostly obviating the need
for convenient error propagation mechanisms.</p><p>And to me, at least, it seems that we talk too little about how to handle
errors, in the end.</p><hr><p>Does Go encourage explicit error handling? This is the phrasing very often used
to justify the repetitive nature, but I tend to disagree. Compare, for example,
Go&rsquo;s approach to checked exceptions in Java: There, errors are propagated via
exceptions. Every exception that could be thrown (theoretically) must be
annotated in the method signature. Any exception that you handle, has to be
mentioned in a try-catch-statement. And the compiler will refuse to compile a
program which does not explicitly mention how exceptions are handled. This, to
me, seems like the pinnacle of <em>explicit</em> error handling. Rust, too, requires
this - it introduces a <code>?</code> operator to signify propagating an error, but that,
still, is an explicit annotation. And apart from that, you can&rsquo;t use the return
value of a function that might propagate an error, without explicitly handling
that error first.</p><p>In Go, on the other hand, it is not only perfectly acceptable to ignore errors
when it makes sense (for example, I will always ignore errors created from
writing to a <a href=https://godoc.org/bytes#Buffer.Write><code>*bytes.Buffer</code></a>), it is
actually often the only sensible thing to do. It is fundamentally not only
okay, but 99% of times <em>correct</em> to just completely ignore the error returned
by <code>fmt.Println</code>. And while it makes sense to check the error returned from
<code>json.Marshal</code> in your HTTP handler against <code>*json.MarshalError</code> (to
panic/log/complain loudly, because your code is buggy), any other errors
<em>should 99% of the time just be ignored</em>. And that&rsquo;s fine.</p><p>I believe that to say Go encourages explicit error handling, it would need some
mechanism of checked exceptions, Result types, or a requirement to pass an
<a href=https://github.com/kisielk/errcheck>errcheck</a> like analysis in the compiler.</p><p>I think it would be closer to say, that Go encourages <em>local</em> error handling.
That is, the code that handles an error, is close to the code that produced it.
Exceptions encourages the two to be separated: There are usually several
or many lines of code in a single <code>try</code>-block, all of which share one
<code>catch</code>-block and it is hard to tell which of the lines produced it. And very
often, the actual error location is several stack frames deep. You could
contrast this with Go, where the error return is immediately obvious from the
code and if you have a line of error handling, it is usually immediately
attached to the function call that produced it.</p><p>However, that still seems to come short, in my view. After all, there is
nothing to force you to do that. And in fact, one of the most often <a href=https://blog.golang.org/errors-are-values>cited
articles about Go error handling</a> is
often interpreted to encourage exactly that. Plus, a lot of people end up
writing <code>return err</code> far too often, simply propagating the error to be
<em>handled</em> elsewhere. And the proliferation of error-wrapping libraries happens
in the same vein: What their proponents phrase as &ldquo;adding context to the error
value&rdquo;, I interpret as &ldquo;adding back some of the information as a crutch, that
you removed when passing the error to non-local handling code&rdquo;. Sadly, far too
often, the error then ends up not being handled at all, as everyone just takes
advantage of that crutch. This leaves the end-user with an error message that is
essentially a poorly formatted, non-contiguous stacktrace.</p><p>Personally, I&rsquo;d characterize Go&rsquo;s approach like this: In Go, error handling is
simply first-class code. By forcing you to use exactly the same control-flow
mechanisms and treat errors like any other data, Go encourages you to code your
error handling. Often that means a bunch of control flow to catch and recover
from any errors where they occur. But that&rsquo;s not &ldquo;clutter&rdquo;, just as it is not
&ldquo;clutter&rdquo; to write <code>if n &lt; 1 { return 1 }</code> when writing a Fibonacci function
(to choose a trivial example). It is just code. And yes, sometimes that code
might also store the error away or propagate it out-of-band to reduce
repetition <em>where it makes sense</em> - like in above blog post. But focussing on
the &ldquo;happy path&rdquo; is a bit of a distraction: Your <em>users</em> will definitely be
more happy about those parts of the control flow that make the errors disappear
or transform them into clean, actionable advise on how to solve the problem.</p><p>So, in my reading, the title of the Go blog post puts the emphasis in slightly
the wrong place - and often, people take the wrong message from it, in my
opinion. Not &ldquo;errors are values&rdquo;, but &ldquo;error handling is code&rdquo;.</p><hr><p>So, what <em>would</em> be my advise for handling errors? To be honest, I don&rsquo;t know
yet - and I&rsquo;m probably in no place to lecture anyone anyway.</p><p>Personally, I&rsquo;ve been trying for the last couple of months to take a page out
of <code>http.Handler</code>s playbook and try, as much as possible, to completely avoid
returning an error. Instead of thinking &ldquo;I should return an error here, in case
I ever do any operation that fails&rdquo;, I instead think &ldquo;is there <em>any way at
all</em> I can get away with not returning an error here?&rdquo;. It doesn&rsquo;t always work
and sometimes you <em>do</em> have to pass errors around or wrap them. But I am
forcing myself to think very hard about handling my errors and it encourages a
programming-style of isolating failing components. The constraint of not being
able to return an error tends to make you creative in how to handle it.</p><hr><p>I think <em>this</em> particular pattern is fine, though, personally, I don&rsquo;t
really see the point. Anything that builds an <code>appError</code> needs to provide
the complete response anyway, so you might as well just write it out
directly. YMMV.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>You might be tempted to suggest, that you could
define an <code>HTTPError</code>, containing the necessary info. Indeed, that&rsquo;s what the
<a href=https://blog.golang.org/error-handling-and-go#TOC_3.>official Go blog</a> does,
so it can&rsquo;t be bad? And indeed, that <em>is</em> what they do, but note that they do
<em>not</em> actually return an <code>error</code> in the end - they return an <code>appError</code>, which
contains the necessary information. Exactly <em>because</em> they don&rsquo;t know how to
deal with general errors. So they translate any errors into a domain specific
type that carries the response. So, that is <em>not</em> the same as returning an
<code>error</code>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li><li><a href=https://blog.merovius.de/tags/thoughtleading/>thoughtleading</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>