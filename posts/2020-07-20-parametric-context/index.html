<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Parametric context | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2020-07-20-parametric-context/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Parametric context"><meta property="og:description" content="Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2020-07-20-parametric-context/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Parametric context"><meta name=twitter:description content="Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Parametric context","item":"https://blog.merovius.de/posts/2020-07-20-parametric-context/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Parametric context","name":"Parametric context","description":"Go\u0026rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft.","keywords":["golang","programming"],"articleBody":"tl;dr: Go’s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft.\nIf you are following what’s happening with Go, you are aware that recently an updated design draft for generics has dropped. What makes this particularly notable is that it comes with an actual prototype implementation of the draft, including a playground. This means for the first time, people get to actually try out how a Go with generics might feel, once they get in. It is a good opportunity to look at common Go code lacking type-safety and evaluate if and how generics can help address them.\nOne area I’d like to look at here is Context.Value. It is often criticized for not being explicit enough about the dependencies a function has and some people even go so far as to discourage its use altogether. On the other hand, I’m on record saying that it is too useful to ignore. Generics might be a way to bring together these viewpoints.\nWe want to be able to declare dependency on a functionality in context.Context via a function’s signature and make it impossible to call it without providing that functionality, while also preserving the ability to pass it through APIs that don’t know anything about it. As an example of such functionality, I will use logging. Let’s start by creating a fictional little library to do that (the names are not ideal, but let’s not worry about that):\npackage logctx import ( \"context\" \"log\" ) type LogContext interface { // We embed a context.Context, to say that we are augmenting it with  // additional functionality.  context.Context // Logf logs the given values in the given format.  Logf(format string, values ...interface{}) } func WithLog(ctx context.Context, l *log.Logger) LogContext { return logContext{ctx, l} } // logContext is unexported, to ensure it can't be modified. type logContext struct { context.Context l *log.Logger } func (ctx logContext) Logf(format string, values ...interface{}) { ctx.l.Printf(format, values...) } You might notice that we are not actually using Value() here. This is fundamental to the idea of getting compiler-checks - we need some compiler-known way to “tag” functionality and that can’t be Value. However, we provide the same functionality, by essentially adding an optional interface to context.Context.\nIf we want to use this, we could write\nfunc Foo(ctx logctx.LogContext, v int) { ctx.Logf(\"Foo(%v)\", v) } func main() { ctx := logctx.WithLog(context.Background(), log.New(os.Stderr, \"\", log.LstdFlags)) Foo(ctx, 42) } However, this has a huge problem: What if we want more than one functionality (each not knowing about the other)? We might try the same trick, say\npackage tracectx import ( \"context\" \"github.com/opentracing/opentracing-go\" ) type TraceContext interface { context.Context Tracer() opentracing.Tracer } func WithTracer(ctx context.Context, t opentracing.Tracer) TraceContext { return traceContext{ctx, t} } type traceContext struct { context.Context t opentracing.Tracer } func (ctx traceContext) Tracer() opentracing.Tracer { return ctx.t } But because a context.Context is embedded, only those methods explicitly mentioned in that interface are added to traceContext. The Logf method is erased. After all, that is the trouble with optional interfaces.\nThis is where generics come in. We can change our wrapper-types and -functions like this:\ntype LogContext(type parent context.Context) struct { // the type-parameter is lower case, so the field is not exported.  parent l *log.Logger } func WithLog(type Parent context.Context) (ctx Parent, l *log.Logger) LogContext(Parent) { return LogContext(parent){ctx, l} } By adding a type-parameter and embedding it, we actually get all methods of the parent context on LogContext. We are no longer erasing them. After giving the tracectx package the same treatment, we can use them like this:\n// FooContext encapsulates all the dependencies of Foo in a context.Context. type FooContext interface { context.Context Logf(format string, values ...interface{}) Tracer() opentracing.Tracer } func Foo(ctx FooContext, v int) { span := ctx.Tracer().StartSpan(\"Foo\") defer span.Finish() ctx.Logf(\"Foo(%v)\", v) } func main() { l := log.New(os.Stderr, \"\", log.LstdFlags) t := opentracing.GlobalTracer() // ctx has type TraceContext(LogContext(context.Context)),  // which embeds a LogContext(context.Context),  // which embeds a context.Context  // So it has all the required methods  ctx := tracectx.WithTracer(logctx.WithLog(context.Background(), l), t) Foo(ctx, 42) } Foo has now fully declared its dependencies on a logger and a tracectx, without requiring any type-assertions or runtime-checks. The logging- and tracing-libraries don’t know about each other and yet are able to wrap each other without loss of type-information. Constructing the context is not particularly ergonomic though. We require a long chained function call, because the values returned by the functions have no longer a unified type context.Context (so the ctx variable can’t be re-used).\nAnother thing to note is that we exported LogContext as a struct, instead of an interface. This is necessary, because we can’t embed type-parameters into interfaces, but we can embed them as struct-fields. So this is the only way we can express that the returned type has all the methods the parameter type has. The downside is that we are making this a concrete type, which isn’t always what we want1.\nWe have now succeeded in annotating context.Context with dependencies, but this alone is not super useful of course. We also need to be able to pass it through agnostic APIs (the fundamental problem Context.Value solves). However, this is easy enough to do.\nFirst, let’s change the context API to use the same form of generic wrappers. This isn’t backwards compatible, of course, but this entire blog post is a thought experiment, so we are ignoring that. I don’t provide the full code here, for brevity’s sake, but the basic API would change into this:\npackage context // CancelContext is the generic version of the currently unexported cancelCtx. type CancelContext(type parent context.Context) struct { parent // other fields } func WithCancel(type Parent context.Context) (ctx Parent) (ctx CancelContext(Parent), cancel CancelFunc) { // ... } This change is necessary to enable WithCancel to also preserve methods of the parent context. We can now use this in an API that passes through a parametric context. For example, say we want to have an errgroup package, that passes the context through to the argument to (*Group).Go, instead of returning it from WithContext:\n// Derived from the current errgroup code.  // A Group is a collection of goroutines working on subtasks that are part of the same overall task. // // A zero Group is invalid (as opposed to the original errgroup). type Group(type Context context.Context) struct { ctx Context cancel func() wg sync.WaitGroup errOnce sync.Once err error } func WithContext(type C context.Context) (ctx C) *Group(C) { ctx, cancel := context.WithCancel(ctx) return \u0026Group(C){ctx: ctx, cancel: cancel} } func (g *Group(Context)) Wait() error { g.wg.Wait() return g.err } func (g *Group(Context)) Go(f func(Context) error) { g.wg.Add(1) go func() { defer g.wg.Done() if err := f(g.ctx); err != nil { g.errOnce.Do(func() { g.err = err }) } }() } Note that the code here has barely changed. It can be used as\nfunc Foo(ctx FooContext) error { span := ctx.Tracer().StartSpan(\"Foo\") defer span.Finish() ctx.Logf(\"Foo was called\") } func main() { var ctx FooContext = newFooContext() eg := errgroup.WithContext(ctx) for i := 0; i  20; i++ { eg.Go(Foo) } if err := eg.Wait(); err != nil { log.Fatal(err) } } After playing around with this for a couple of days, I feel pretty confident that these patterns make it possible to get a fully type-safe version of context.Context, while preserving the ability to have APIs that pass it through untouched or augmented.\nA completely different question, of course, is whether all of this is a good idea. Personally, I am on the fence about it. It is definitely valuable, to have a type-safe version of context.Context. And I think it is impressive how small the impact of it is on the users of APIs written this way. The type-argument can almost always be inferred and writing code to make use of this is very natural - you just declare a suitable context-interface and take it as an argument. You can also freely pass it to functions taking a pure context.Context unimpeded.\nOn the other hand, I am not completely convinced the cost is worth it. As soon as you do non-trivial things with a context, it becomes a pretty “infectious” change. For example, I played around with a mock gRPC API to allow interceptors to take a parametric context and it requires almost all types and functions involved to take a type-parameter. And this doesn’t even touch on the fact that gRPC itself might want to add annotations to the context, which adds even more types. I am not sure if the additional machinery is really worth the benefit of some type-safety - especially as it’s not always super intuitive and easily understandable. And even more so, if it needs to be combined with other type-parameters, to achieve other goals.\nI think this is an example of what I tend to dislike about generics and powerful type-systems in general. They tempt you to write a lot of extra machinery and types in a way that isn’t necessarily semantically meaningful, but only used to encode some invariant in a way the compiler understands.\n I don’t actually think there is much of a performance problem with context.Value in practice, but if there is, this could solve that.\n  One upside however, is that this could actually address the other criticism of context.Value: Its performance. If we consequently embed the parent-context as values in struct fields, the final context will be a flat struct. The interface-table of all the extra methods we add will point at the concrete implementations. There’s no longer any need for a linear search to find a context value. ↩︎\n   ","wordCount":"1598","inLanguage":"en","datePublished":"2020-07-20T00:00:00Z","dateModified":"2020-07-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2020-07-20-parametric-context/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Parametric context</h1><div class=post-meta><span title="2020-07-20 00:00:00 +0000 UTC">July 20, 2020</span></div></header><div class=post-content><p><strong>tl;dr: Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft.</strong></p><p>If you are following what&rsquo;s happening with Go, you are aware that recently
<a href=https://blog.golang.org/generics-next-step>an updated design draft for generics has dropped</a>.
What makes this particularly notable is that it comes with an actual prototype
implementation of the draft, including a <a href=https://go2goplay.golang.org/>playground</a>.
This means for the first time, people get to actually try out how a Go with
generics might feel, once they get in. It is a good opportunity to look at
common Go code lacking type-safety and evaluate if and how generics can help
address them.</p><p>One area I&rsquo;d like to look at here is <a href=https://godoc.org/context#Context.Value>Context.Value</a>. It is often criticized
for not being explicit enough about the dependencies a function has and some
people even go so far as to discourage its use altogether. On the other hand,
I&rsquo;m on record <a href=/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/>saying that it is too useful to ignore</a>. Generics
might be a way to bring together these viewpoints.</p><p>We want to be able to declare dependency on a functionality in
<code>context.Context</code> via a function&rsquo;s signature and make it impossible to call it
without providing that functionality, while also preserving the ability to pass
it through APIs that don&rsquo;t know anything about it. As an example of such
functionality, I will use logging. Let&rsquo;s start by creating a fictional little
library to do that (the names are not ideal, but let&rsquo;s not worry about that):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>logctx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>LogContext</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We embed a context.Context, to say that we are augmenting it with
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// additional functionality.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Logf logs the given values in the given format.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>values</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithLog</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>l</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>LogContext</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>logContext</span><span class=p>{</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>l</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// logContext is unexported, to ensure it can&#39;t be modified.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>logContext</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>logContext</span><span class=p>)</span> <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>values</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>.</span><span class=nx>l</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>values</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You might notice that we are not actually using <code>Value()</code> here. This is
fundamental to the idea of getting compiler-checks - we need some
compiler-known way to &ldquo;tag&rdquo; functionality and that can&rsquo;t be <code>Value</code>. However,
we provide the same functionality, by essentially adding an <a href=/posts/2017-07-30-the-trouble-with-optional-interfaces/>optional
interface</a> to <code>context.Context</code>.</p><p>If we want to use this, we could write</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>logctx</span><span class=p>.</span><span class=nx>LogContext</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=s>&#34;Foo(%v)&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>logctx</span><span class=p>.</span><span class=nf>WithLog</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>log</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>log</span><span class=p>.</span><span class=nx>LstdFlags</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>Foo</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, this has a huge problem: What if we want more than one functionality
(each not knowing about the other)? We might try the same trick, say</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>tracectx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/opentracing/opentracing-go&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TraceContext</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=nf>Tracer</span><span class=p>()</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nx>Tracer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithTracer</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>t</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nx>Tracer</span><span class=p>)</span> <span class=nx>TraceContext</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>traceContext</span><span class=p>{</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>t</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>traceContext</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nx>Tracer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>traceContext</span><span class=p>)</span> <span class=nf>Tracer</span><span class=p>()</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nx>Tracer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But because a <code>context.Context</code> is embedded, only those methods explicitly
mentioned in that interface are added to <code>traceContext</code>. The <code>Logf</code> method is
erased. After all, that is <a href=/posts/2017-07-30-the-trouble-with-optional-interfaces/>the trouble with optional interfaces</a>.</p><p>This is where generics come in. We can change our wrapper-types and -functions like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nf>LogContext</span><span class=p>(</span><span class=kd>type</span> <span class=nx>parent</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// the type-parameter is lower case, so the field is not exported.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>parent</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithLog</span><span class=p>(</span><span class=kd>type</span> <span class=nx>Parent</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Parent</span><span class=p>,</span> <span class=nx>l</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=nf>LogContext</span><span class=p>(</span><span class=nx>Parent</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>LogContext</span><span class=p>(</span><span class=nx>parent</span><span class=p>){</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>l</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By adding a type-parameter and embedding it, we actually get <em>all</em> methods of
the parent context on <code>LogContext</code>. We are no longer erasing them. After giving
the <code>tracectx</code> package the same treatment, we can use them like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// FooContext encapsulates all the dependencies of Foo in a context.Context.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>FooContext</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=nf>Logf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>values</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=nf>Tracer</span><span class=p>()</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nx>Tracer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>FooContext</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>span</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Tracer</span><span class=p>().</span><span class=nf>StartSpan</span><span class=p>(</span><span class=s>&#34;Foo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>span</span><span class=p>.</span><span class=nf>Finish</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=s>&#34;Foo(%v)&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span> <span class=o>:=</span> <span class=nx>log</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>log</span><span class=p>.</span><span class=nx>LstdFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>opentracing</span><span class=p>.</span><span class=nf>GlobalTracer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ctx has type TraceContext(LogContext(context.Context)),
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    which embeds a LogContext(context.Context),
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    which embeds a context.Context
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// So it has all the required methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>tracectx</span><span class=p>.</span><span class=nf>WithTracer</span><span class=p>(</span><span class=nx>logctx</span><span class=p>.</span><span class=nf>WithLog</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>l</span><span class=p>),</span> <span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Foo</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>Foo</code> has now fully declared its dependencies on a logger and a tracectx, without
requiring any type-assertions or runtime-checks. The logging- and
tracing-libraries don&rsquo;t know about each other and yet are able to wrap each
other without loss of type-information. Constructing the context is not
particularly ergonomic though. We require a long chained function call, because
the values returned by the functions have no longer a unified type
<code>context.Context</code> (so the <code>ctx</code> variable can&rsquo;t be re-used).</p><p>Another thing to note is that we exported <code>LogContext</code> as a struct, instead of
an interface. This is necessary, because we can&rsquo;t embed type-parameters into
interfaces, but we <em>can</em> embed them as struct-fields. So this is the only way
we can express that the returned type has all the methods the parameter type
has. The downside is that we are making this a concrete type, which isn&rsquo;t
always what we want<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>We have now succeeded in annotating <code>context.Context</code> with dependencies, but
this alone is not super useful of course. We also need to be able to pass it
through agnostic APIs (the fundamental problem <code>Context.Value</code> solves).
However, this is easy enough to do.</p><p>First, let&rsquo;s change the <code>context</code> API to use the same form of generic wrappers.
This isn&rsquo;t backwards compatible, of course, but this entire blog post is a
thought experiment, so we are ignoring that. I don&rsquo;t provide the full code
here, for brevity&rsquo;s sake, but the basic API would change into this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>context</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// CancelContext is the generic version of the currently unexported cancelCtx.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nf>CancelContext</span><span class=p>(</span><span class=kd>type</span> <span class=nx>parent</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>parent</span>
</span></span><span class=line><span class=cl>    <span class=c1>// other fields
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithCancel</span><span class=p>(</span><span class=kd>type</span> <span class=nx>Parent</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>Parent</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nf>CancelContext</span><span class=p>(</span><span class=nx>Parent</span><span class=p>),</span> <span class=nx>cancel</span> <span class=nx>CancelFunc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This change is necessary to enable <code>WithCancel</code> to also preserve methods of the
parent context. We can now use this in an API that passes through a parametric
context. For example, say we want to have an <a href=https://godoc.org/golang.org/x/sync/errgroup>errgroup</a> package, that passes
the context through to the argument to <code>(*Group).Go</code>, instead of returning it
from <code>WithContext</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Derived from the current errgroup code.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// A Group is a collection of goroutines working on subtasks that are part of the same overall task.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// A zero Group is invalid (as opposed to the original errgroup).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nf>Group</span><span class=p>(</span><span class=kd>type</span> <span class=nx>Context</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span>    <span class=nx>Context</span>
</span></span><span class=line><span class=cl>    <span class=nx>cancel</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>errOnce</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span>     <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WithContext</span><span class=p>(</span><span class=kd>type</span> <span class=nx>C</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>C</span><span class=p>)</span> <span class=o>*</span><span class=nf>Group</span><span class=p>(</span><span class=nx>C</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nf>Group</span><span class=p>(</span><span class=nx>C</span><span class=p>){</span><span class=nx>ctx</span><span class=p>:</span> <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span><span class=p>:</span> <span class=nx>cancel</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nf>Group</span><span class=p>(</span><span class=nx>Context</span><span class=p>))</span> <span class=nf>Wait</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>g</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nf>Group</span><span class=p>(</span><span class=nx>Context</span><span class=p>))</span> <span class=nf>Go</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>g</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>f</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>g</span><span class=p>.</span><span class=nx>errOnce</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>g</span><span class=p>.</span><span class=nx>err</span> <span class=p>=</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that the code here has barely changed. It can be used as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>FooContext</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>span</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Tracer</span><span class=p>().</span><span class=nf>StartSpan</span><span class=p>(</span><span class=s>&#34;Foo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>span</span><span class=p>.</span><span class=nf>Finish</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>.</span><span class=nf>Logf</span><span class=p>(</span><span class=s>&#34;Foo was called&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>ctx</span> <span class=nx>FooContext</span> <span class=p>=</span> <span class=nf>newFooContext</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>eg</span> <span class=o>:=</span> <span class=nx>errgroup</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>20</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>eg</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=nx>Foo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>eg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After playing around with this for a couple of days, I feel pretty confident
that these patterns make it possible to get a fully type-safe version of
<code>context.Context</code>, while preserving the ability to have APIs that pass it
through untouched or augmented.</p><p>A completely different question, of course, is whether all of this is a good
idea. Personally, I am on the fence about it. It is definitely valuable, to
have a type-safe version of <code>context.Context</code>. And I think it is impressive how
small the impact of it is on the <em>users</em> of APIs written this way. The
type-argument can almost always be inferred and writing code to make use of this
is very natural - you just declare a suitable context-interface and take it as
an argument. You can also freely pass it to functions taking a pure
<code>context.Context</code> unimpeded.</p><p>On the other hand, I am not completely convinced the cost is worth it. As soon
as you do non-trivial things with a context, it becomes a pretty &ldquo;infectious&rdquo;
change. For example, I played around with a <a href=https://go2goplay.golang.org/p/9-xQZufcGp_k>mock gRPC API</a> to allow
interceptors to take a parametric context and it requires almost all types and
functions involved to take a type-parameter. And this doesn&rsquo;t even touch on the
fact that gRPC itself might want to add annotations to the context, which adds
even more types. I am not sure if the additional machinery is really worth the
benefit of some type-safety - especially as it&rsquo;s not always super intuitive and
easily understandable. And even more so, if it needs to be combined with other
type-parameters, to achieve other goals.</p><p>I think this is an example of what I tend to dislike about generics and powerful
type-systems in general. They tempt you to write a lot of extra machinery and
types in a way that isn&rsquo;t necessarily semantically meaningful, but only used to
encode some invariant in a way the compiler understands.</p><hr><p>I don&rsquo;t actually think there is much of a performance problem with
<code>context.Value</code> in practice, but if there is, this could solve that.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>One <em>upside</em> however, is that this could actually address
the <em>other</em> criticism of <code>context.Value</code>: Its performance. If we consequently embed the
parent-context as values in struct fields, the final context will be a flat
struct. The interface-table of all the extra methods we add will point at the
concrete implementations. There&rsquo;s no longer any need for a linear search to
find a context value.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>