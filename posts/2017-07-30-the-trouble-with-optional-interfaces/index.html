<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The trouble with optional interfaces | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I take a look at the pattern of optional interfaces in Go: what they are used for, why they are bad and what we can do about it."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-07-30-the-trouble-with-optional-interfaces/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="The trouble with optional interfaces"><meta property="og:description" content="I take a look at the pattern of optional interfaces in Go: what they are used for, why they are bad and what we can do about it."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-07-30-the-trouble-with-optional-interfaces/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-07-30T18:39:00+00:00"><meta property="article:modified_time" content="2017-07-30T18:39:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The trouble with optional interfaces"><meta name=twitter:description content="I take a look at the pattern of optional interfaces in Go: what they are used for, why they are bad and what we can do about it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"The trouble with optional interfaces","item":"https://blog.merovius.de/posts/2017-07-30-the-trouble-with-optional-interfaces/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The trouble with optional interfaces","name":"The trouble with optional interfaces","description":"I take a look at the pattern of optional interfaces in Go: what they are used for, why they are bad and what we can do about it.","keywords":["golang","programming"],"articleBody":"tl;dr: I take a look at the pattern of optional interfaces in Go: what they are used for, why they are bad and what we can do about it.\nNote: I wrote most of this article on Wednesday, with the intention to finish and publish it on the weekend. While I was sleeping, Jack Lindamood published this post, which talks about much of the same problems. This was the exact moment I saw that post :) I decided, to publish this anyway; it contains, in my opinion, enough additional content, to be worth it. But I do encourage to (also?) read his post.\nWhat are optional interfaces? Optional interfaces are interfaces which can optionally be extended by implementing some other interface. A good example is http.Flusher (and similar), which is optionally implemented by an http.ResponseWriter. If a request comes in via HTTP/2, the ResponseWriter will implement this interface to support HTTP/2 Server Push. But as not all requests will be over HTTP/2, this isn’t part of the normal ResponseWriter interface and instead provided via an optional interface that needs to be type-asserted at runtime.\nIn general, whenever some piece of code is doing a type-assertion with an interface type (that is, use an expression v.(T), where T is an interface type), it is very likely offering an optional interface.\nA far from exhaustive list of where the optional interface pattern is used (to roughly illustrate the scope of the pattern):\n io net/http database/sql/driver go/types Dave Chaney’s errors package  What are people using them for? There are multiple reasons to use optional interfaces. Let’s find examples for them. Note that this list neither claims to be exhaustive (there are probably use cases I don’t know about) nor disjunct (in some cases, optional interfaces will carry more than one of these use cases). But I think it’s a good rough partition to discuss.\nPassing behavior through API boundaries This is the case of ResponseWriter and its optional interfaces. The API, in this case, is the http.Handler interface that users of the package implement and that the package accepts. As features like HTTP/2 Push or connection hijacking are not available to all connections, this interface needs to use the lowest common denominator between all possible behaviors. So, if more features need to be supported, we must somehow be able to pass this optional behavior through the http.Handler interface.\nEnabling optional optimizations/features io.Copy serves as a good example of this. The required interfaces for it to work are just io.Reader and io.Writer. But it can be made more efficient, if the passed values also implement io.WriterTo or io.ReaderFrom, respectively. For example, a bytes.Reader implements WriteTo. This means, you need less copying if the source of an io.Copy is a bytes.Reader. Compare these two (somewhat naive) implementations:\nfunc Copy(w io.Writer, r io.Reader) (n int64, err error) { buf := make([]byte, 4096) for { rn, rerr := r.Read(buf) wn, werr := w.Write(buf[:rn]) n += int64(wn) if rerr == io.EOF { return n, nil } if rerr != nil { return n, rerr } if werr != nil { return n, werr } } } func CopyTo(w io.Writer, r io.WriterTo) (n int64, err error) { return r.WriteTo(w) } type Reader []byte func (r *Reader) Read(b []byte) (n int, err error) { n = copy(b, *r) *r = (*r)[n:] if n == 0 { err = io.EOF } return n, err } func (r *Reader) WriteTo(w io.Writer) (int64, error) { n, err := w.Write(*r) *r = (*r)[n:] return int64(n), err } Copy needs to first allocate a buffer, then copy all the data from the *Reader to that buffer, then pass it to the Writer. CopyTo, on the other hand, can directly pass the byte-slice to the Writer, saving an allocation and a copy.\nSome of that cost can be amortized, but in general, its existence is a forced consequence of the API. By using optional interfaces, io.Copy can use the more efficient method, if supported, and fall back to the slow method, if not.\nBackwards compatible API changes When database/sql upgraded to use context, it needed help from the drivers to actually implement cancellation and the like. So it needed to add contexts to the methods of driver.Conn. But it can’t just do that change; it would be a backwards incompatible API change, violating the Go1 compatibility guarantee. It also can’t add a new method to the interface to be used, as there are third-party implementations for drivers, which would be broken as they don’t implement the new method.\nSo it instead resorted to deprecate the old methods and instead encourage driver implementers to add optional methods including the context.\nWhy are they bad? There are several problems with using optional interfaces. Some of them have workarounds (see below), but all of them have drawbacks on their own.\nThey violate static type safety In a lot of cases, the consumer of an optional interface can’t really treat it as optional. For example, http.Hijacker is usually used to support WebSockets. A handler for WebSockets will, in general, not be able to do anything useful, when called with a ResponseWriter that does not implement Hijacker. Even when it correctly does a comma-ok type assertion to check for it, it can’t do anything but serve an error in that case.\nThe http.Hijacker type conveys the necessity of hijacking a connection, but since it is provided as an optional interface, there is no possibility to require this type statically. In that way, optional interfaces hide static type information.\nThey remove a lot of the power of interfaces Go’s interfaces are really powerful by being very small; in general, the advice is to only add one method, maybe a small handful. This advice enables easy and powerful composition. io.Reader and io.Writer have a myriad of implementations inside and outside of the standard library. This makes it really easy to, say, read uncompressed data from a compressed network connection, while streaming it to a file and hashing it at the same time to write to some content-addressed blob storage.\nNow, this composition will, in general, destroy any optional interfaces of those values. Say, we have an HTTP middleware to log requests. It wants to wrap an http.Handler and log the requests method, path, response code and duration (or, equivalently, collect them as metrics to export). This is, in principle, easy to do:\ntype logResponder struct { http.ResponseWriter code int set bool } func (rw *logResponder) WriteHeader(code int) { rw.code = code rw.set = bool rw.ResponseWriter.WriteHeader(code) } func LogRequests(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { lr := \u0026logResponder{ResponseWriter: w} m, p, start := r.Method, r.Path, time.Now() defer func() { log.Printf(\"%s %s - %d (%v)\", m, p, lr.code, time.Now().Sub(start)) }() h(lr, r) }) } But *logResponder will now only support the methods declared by http.ResponseWriter, even if the wrapped ResponseWriter also supports some of the optional interfaces. That is because method sets of a type are determined at compile time.\nThus, by using this middleware, the wrapped handler is suddenly unable to use websockets, or HTTP/2 server push or any of the other use cases of optional interfaces. Even worse: this deficiency will only be discovered at runtime.\nOptimistically adding the optional interface’s methods and type-asserting the underlying ResponseWriter at runtime doesn’t work either: handlers would incorrectly conclude the optional interface is always present. If the underlying ResponseWriter does not support adding at the underlying connection there just is no useful way to implement http.Hijacker.\nThere is one way around this, which is to dynamically check the wrapped interface and create a type with the correct method set, e.g.:\nfunc Wrap(wrap, with http.ResponseWriter) http.ResponseWriter { var ( flusher http.Flusher pusher http.Pusher // ... \t) flusher, _ = wrap.(http.Flusher) pusher, _ = wrap.(http.Pusher) // ... \tif flusher == nil \u0026\u0026 pusher == nil { return with } if flusher == nil \u0026\u0026 pusher != nil { return struct{ http.ResponseWriter http.Pusher }{with, pusher} } if flusher != nil \u0026\u0026 pusher == nil { return struct{ http.ResponseWriter http.Flusher }{with, flusher} } return struct{ http.ResponseWriter http.Flusher http.Pusher }{with, flusher, pusher} } This has two major drawbacks:\n Both code-size and running time of this will increase exponentially with the number of optional interfaces you have to support (even if you generate the code). You need to know every single optional interface that might be used. While supporting everything in net/http is certainly tenable, there might be other optional interfaces, defined by some framework unbeknownst to you. If you don’t know about it, you can’t wrap it.  What can we use instead? My general advice is, to avoid optional interfaces as much as possible. There are alternatives, though they also are not entirely satisfying.\nContext.Value context was added after most of the optional interfaces where already defined, but its Value method was meant exactly for this kind of thing: to pass optional behavior past API boundaries. This will still not solve the static type safety issue of optional interfaces, but it does mean you can easily wrap them.\nFor example, net/http could instead do\nvar ctxFlusher = ctxKey(\"flusher\") func GetFlusher(ctx context.Context) (f Flusher, ok bool) { f, ok = ctx.Value(ctxFlusher).(Flusher) return f, ok } This would enable you to do\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) { f, ok := http.GetFlusher(r.Context()) if ok { f.Flush() } } If now a middleware wants to wrap ResponseWriter, that’s not a problem, as it will not touch the Context. If a middleware wants to add some other optional behavior, it can do so easily:\ntype Frobnicator interface{ Frobnicate() } var ctxFrobnicator = ctxKey(\"frobnicator\") func GetFrobnicator(ctx context.Context) (f Frobnicator, ok bool) { f, ok = ctx.Value(ctxFrobnicator).(Frobnicator) return f, ok } As contexts form a linked list of key-value-pairs, this will interact nicely with whatever optional behavior is already defined.\nThere are good reasons to frown upon the usage of Context.Value; but they apply just as much to optional interfaces.\nExtraction methods If you know an interface type that is probable to be wrapped and also has optional interfaces associated it is possible to enforce the possibility of dynamic extension in the optional type. So, e.g.:\npackage http type ResponseWriter interface { // Methods… } type ResponseWriterWrapper interface { ResponseWriter WrappedResponseWriter() ResponseWriter } // GetFlusher returns an http.Flusher, if res wraps one. // Otherwise, it returns nil. func GetFlusher(res ResponseWriter) Flusher { if f, ok := res.(Flusher); ok { return f } if w, ok := res.(ResponseWriterWrapper); ok { return GetFlusher(w.WrappedResponseWriter()) } return nil } package main type logger struct { res ResponseWriter req *http.Request log *log.Logger start time.Time } func (l *logger) WriteHeader(code int) { d := time.Now().Since(l.start) l.log.Write(\"%s %s - %d (%v)\",\tl.req.Method, l.req.Path, code, d) l.res.WriteHeader(code) } func (l *logger) WrappedResponseWriter() http.ResponseWriter { return l.res } func LogRequests(h http.Handler, l *log.Logger) http.Hander { return http.HandlerFunc(res http.ResponseWriter, req *http.Request) { res = \u0026logger{ res: res, req: req, log: l, start: time.Now(), } h.ServeHTTP(res, req) } } func ServeHTTP(res http.ResponseWriter, req *http.Request) { if f := http.GetFlusher(res); f != nil { f.Flush() } } This still doesn’t address the static typing issue and explicit dependencies, but at least it enables you to wrap the interface conveniently.\nNote, that this is conceptually similar to the errors package, which calls the wrapper-method “Cause”. This package also shows an issue with this pattern; it only works if all wrappers use it. That’s why I think it’s important for the wrapping interface to live in the same package as the wrapped interface; it provides an authoritative way to do that wrapping, preventing fragmentation.\nProvide statically typed APIs net/http could provide alternative APIs for optional interfaces that explicitly include them. For example:\ntype Hijacker interface { ResponseWriter Hijack() (net.Conn, *bufio.ReadWriter, error) } type HijackHandler interface{ ServeHijacker(w Hijacker, r *http.Request) } func HandleHijacker(pattern string, h HijackHandler) { // ... } For some use cases, this provides a good way to side-step the issue of unsafe types. Especially if you can come up with a limited set of scenarios that would rely on the optional behavior, putting them into their own type would be viable.\nThe net/http package could, for example, provide separate ResponseWriter types for different connection types (for example HTTP2Response). It could then provide a func(HTTP2Handler) http.Handler, that serves an error if it is asked to serve an unsuitable connection and otherwise delegates to the passed Handler. Now, the programmer needs to explicitly wire a handler that requires HTTP/2 up accordingly. They can rely on the additional features, while also making clear what paths must be used over HTTP/2.\nGradual repair I think the use of optional interfaces as in database/sql/driver is perfectly fine - if you plan to eventually remove the original interface. Otherwise, users will have to continue to implement both interfaces to be usable with your API, which is especially painful when wrapping interfaces. For example, I recently wanted to wrap importer.Default to add behavior and logging. I also needed ImporterFrom, which required separate implementations, depending on whether the importer returned by Default implements it or not. Most modern code, however, shouldn’t need that.\nSo, for third party packages (the stdlib can’t do that, because of compatibility guarantees), you should consider using the methodology described in Russ Cox’ excellent Codebase Refactoring article and actually deprecate and eventually remove the old interface. Use optional interfaces as a transition mechanism, not a fix.\nHow could Go improve the situation? Make it possible for reflect to create methods There are currently at least two GitHub issues which would make it possible to do extend interfaces dynamically: reflect: NamedOf, reflect: MakeInterface. I believe this would be the easiest solution - it is backwards compatible and doesn’t require any language changes.\nProvide a language mechanism for extension The language could provide a native mechanism to express extension, either by adding a keyword for it or, for Go2, by considering to make extension the default behavior for interface-struct embedding. I’m not sure either is a good idea, though. I would probably prefer the latter, because of my distaste for keywords. Note, that it would still be possible to then compose an interface into a struct, just not via embedding but by adding a field and delegation-methods. Personally, I’m not a huge fan of embedding interfaces in structs anyway except when I’m explicitly trying to extend them with additional behavior. Their zero-value is not usable, so it requires additional hoops to jump through.\nConclusion I recommend:\n If at all possible, avoid optional interfaces in APIs you provide. They are just too inconvenient and un-Go-ish. Be careful when wrapping interfaces, in particular when there are known optional interfaces for them.  Using optional interfaces correctly is inconvenient and cumbersome. That should signal that you are fighting the language. The workarounds needed all try to circumvent one or more design decision of Go: to value composition over inheritance, to prefer static typing and to make computation and behavior obvious from code. To me, that signifies that optional interfaces are fundamentally not a good fit for the language.\n","wordCount":"2492","inLanguage":"en","datePublished":"2017-07-30T18:39:00Z","dateModified":"2017-07-30T18:39:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-07-30-the-trouble-with-optional-interfaces/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The trouble with optional interfaces</h1><div class=post-meta><span title="2017-07-30 18:39:00 +0000 UTC">July 30, 2017</span></div></header><div class=post-content><p><strong>tl;dr: I take a look at the pattern of optional interfaces in Go: what they
are used for, why they are bad and what we can do about it.</strong></p><p><em>Note: I wrote most of this article on Wednesday, with the intention to finish
and publish it on the weekend. While I was sleeping, Jack Lindamood published
<a href=https://medium.com/@cep21/interface-wrapping-method-erasure-c523b3549912>this
post</a>,
which talks about much of the same problems.
<a href=https://twitter.com/TheMerovius/status/890472264931708928>This</a> was the exact
moment I saw that post :) I decided, to publish this anyway; it contains, in my
opinion, enough additional content, to be worth it. But I do encourage to
(also?) read his post.</em></p><h2 id=what-are-optional-interfaces>What are optional interfaces?<a hidden class=anchor aria-hidden=true href=#what-are-optional-interfaces>#</a></h2><p>Optional interfaces are interfaces which can optionally be extended by
implementing some other interface. A good example is
<a href=http://godoc.org/net/http#Flusher>http.Flusher</a> (and similar), which is
optionally implemented by an
<a href=http://godoc.org/net/http#ResponseWriter>http.ResponseWriter</a>. If a request
comes in via HTTP/2, the ResponseWriter will implement this interface to
support <a href=https://en.wikipedia.org/wiki/HTTP/2_Server_Push>HTTP/2 Server Push</a>.
But as not all requests will be over HTTP/2, this isn&rsquo;t part of the normal
ResponseWriter interface and instead provided via an optional interface that
needs to be type-asserted at runtime.</p><p>In general, whenever some piece of code is doing a type-assertion with an
interface type (that is, use an expression <code>v.(T)</code>, where <code>T</code> is an interface
type), it is very likely offering an optional interface.</p><p>A far from exhaustive list of where the optional interface pattern is used (to
roughly illustrate the scope of the pattern):</p><ul><li><a href=http://godoc.org/io#Copy>io</a></li><li><a href=http://godoc.org/net/http#ResponseWriter#Flusher>net/http</a></li><li><a href=http://godoc.org/database/sql/driver#ConnBeginTx>database/sql/driver</a></li><li><a href=http://godoc.org/go/types#Importer>go/types</a></li><li>Dave Chaney&rsquo;s <a href=http://godoc.org/github.com/pkg/errors#Cause>errors package</a></li></ul><h2 id=what-are-people-using-them-for>What are people using them for?<a hidden class=anchor aria-hidden=true href=#what-are-people-using-them-for>#</a></h2><p>There are multiple reasons to use optional interfaces. Let&rsquo;s find examples for
them. Note that this list neither claims to be exhaustive (there are probably
use cases I don&rsquo;t know about) nor disjunct (in some cases, optional interfaces
will carry more than one of these use cases). But I think it&rsquo;s a good rough
partition to discuss.</p><h3 id=passing-behavior-through-api-boundaries>Passing behavior through API boundaries<a hidden class=anchor aria-hidden=true href=#passing-behavior-through-api-boundaries>#</a></h3><p>This is the case of <code>ResponseWriter</code> and its optional interfaces. The API, in
this case, is the <code>http.Handler</code> interface that users of the package implement
and that the package accepts. As features like HTTP/2 Push or connection
hijacking are not available to all connections, this interface needs to use the
lowest common denominator between all possible behaviors. So, if more features
need to be supported, we must somehow be able to pass this optional behavior
through the <code>http.Handler</code> interface.</p><h3 id=enabling-optional-optimizationsfeatures>Enabling optional optimizations/features<a hidden class=anchor aria-hidden=true href=#enabling-optional-optimizationsfeatures>#</a></h3><p><a href=http://godoc.org/io#Copy>io.Copy</a> serves as a good example of this. The
required interfaces for it to work are just <code>io.Reader</code> and <code>io.Writer</code>. But it
can be made more efficient, if the passed values also implement <code>io.WriterTo</code>
or <code>io.ReaderFrom</code>, respectively. For example, a
<a href=http://godoc.org/bytes#Reader.WriteTo>bytes.Reader</a> implements <code>WriteTo</code>.
This means, you need less copying if the source of an <code>io.Copy</code> is a
<code>bytes.Reader</code>. Compare these two (somewhat naive) implementations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Copy</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>4096</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rn</span><span class=p>,</span> <span class=nx>rerr</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>wn</span><span class=p>,</span> <span class=nx>werr</span> <span class=o>:=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>[:</span><span class=nx>rn</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span> <span class=o>+=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>wn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rerr</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rerr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>rerr</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>werr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>werr</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CopyTo</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>WriterTo</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>WriteTo</span><span class=p>(</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reader</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=p>=</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=o>*</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>r</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>r</span><span class=p>)[</span><span class=nx>n</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>WriteTo</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>)</span> <span class=p>(</span><span class=kt>int64</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=o>*</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>r</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>r</span><span class=p>)[</span><span class=nx>n</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>n</span><span class=p>),</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>Copy</code> needs to first allocate a buffer, then copy all the data from the
<code>*Reader</code> to that buffer, then pass it to the Writer. <code>CopyTo</code>, on the other
hand, can directly pass the byte-slice to the Writer, saving an allocation and
a copy.</p><p>Some of that cost can be amortized, but in general, its existence is a forced
consequence of the API. By using optional interfaces, <code>io.Copy</code> can use the
more efficient method, if supported, and fall back to the slow method, if not.</p><h3 id=backwards-compatible-api-changes>Backwards compatible API changes<a hidden class=anchor aria-hidden=true href=#backwards-compatible-api-changes>#</a></h3><p>When <code>database/sql</code> upgraded to use <code>context</code>, it needed help from the drivers
to actually implement cancellation and the like. So it needed to add contexts
to the methods of <a href=http://godoc.org/database/sql/driver#Conn>driver.Conn</a>. But
it can&rsquo;t just do that change; it would be a backwards incompatible API change,
violating the Go1 compatibility guarantee. It also can&rsquo;t add a new method to
the interface to be used, as there are third-party implementations for drivers,
which would be broken as they don&rsquo;t implement the new method.</p><p>So it instead resorted to
<a href=https://golang.org/src/database/sql/driver/driver.go#L159>deprecate</a> the old
methods and instead encourage driver implementers to add optional methods
including the context.</p><h2 id=why-are-they-bad>Why are they bad?<a hidden class=anchor aria-hidden=true href=#why-are-they-bad>#</a></h2><p>There are several problems with using optional interfaces. Some of them have
workarounds (see below), but all of them have drawbacks on their own.</p><h3 id=they-violate-static-type-safety>They violate static type safety<a hidden class=anchor aria-hidden=true href=#they-violate-static-type-safety>#</a></h3><p>In a lot of cases, the consumer of an optional interface can&rsquo;t really treat it
as optional. For example, <code>http.Hijacker</code> is usually used to support
WebSockets. A handler for WebSockets will, in general, not be able to do
anything useful, when called with a <code>ResponseWriter</code> that does not implement
<code>Hijacker</code>. Even when it correctly does a comma-ok type assertion to check
for it, it can&rsquo;t do anything but serve an error in that case.</p><p>The http.Hijacker type conveys the necessity of hijacking a connection, but
since it is provided as an optional interface, there is no possibility to
require this type statically. In that way, optional interfaces hide static type
information.</p><h3 id=they-remove-a-lot-of-the-power-of-interfaces>They remove a lot of the power of interfaces<a hidden class=anchor aria-hidden=true href=#they-remove-a-lot-of-the-power-of-interfaces>#</a></h3><p>Go&rsquo;s interfaces are really powerful by being very small; in general, the
advice is to only add one method, maybe a small handful. This advice enables
easy and powerful composition. <code>io.Reader</code> and <code>io.Writer</code> have a myriad of
implementations inside and outside of the standard library. This makes it
really easy to, say, read uncompressed data from a compressed network
connection, while streaming it to a file and hashing it at the same time to
write to some content-addressed blob storage.</p><p>Now, this composition will, in general, destroy any optional interfaces of
those values. Say, we have an HTTP middleware to log requests. It wants to wrap
an <code>http.Handler</code> and log the requests method, path, response code and duration
(or, equivalently, collect them as metrics to export). This is, in principle,
easy to do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>logResponder</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>	<span class=nx>code</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>set</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>logResponder</span><span class=p>)</span> <span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>code</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rw</span><span class=p>.</span><span class=nx>code</span> <span class=p>=</span> <span class=nx>code</span>
</span></span><span class=line><span class=cl>	<span class=nx>rw</span><span class=p>.</span><span class=nx>set</span> <span class=p>=</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>rw</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>code</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LogRequests</span><span class=p>(</span><span class=nx>h</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>lr</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>logResponder</span><span class=p>{</span><span class=nx>ResponseWriter</span><span class=p>:</span> <span class=nx>w</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>,</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>start</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Method</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s %s -&gt; %d (%v)&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>,</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>lr</span><span class=p>.</span><span class=nx>code</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>start</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=nf>h</span><span class=p>(</span><span class=nx>lr</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But <code>*logResponder</code> will now <em>only</em> support the methods declared by
<code>http.ResponseWriter</code>, even if the wrapped <code>ResponseWriter</code> also supports some
of the optional interfaces. That is because method sets of a type are
determined at compile time.</p><p>Thus, by using this middleware, the wrapped handler is suddenly unable to use
websockets, or HTTP/2 server push or any of the other use cases of optional
interfaces. Even worse: this deficiency will only be discovered at runtime.</p><p>Optimistically adding the optional interface&rsquo;s methods and type-asserting the
underlying ResponseWriter at runtime doesn&rsquo;t work either: handlers would
incorrectly conclude the optional interface is always present. If the
underlying <code>ResponseWriter</code> does not support adding at the underlying
connection there just is no useful way to implement <code>http.Hijacker</code>.</p><p>There is one way around this, which is to dynamically check the wrapped
interface and create a type with the correct method set, e.g.:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Wrap</span><span class=p>(</span><span class=nx>wrap</span><span class=p>,</span> <span class=nx>with</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>flusher</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Flusher</span>
</span></span><span class=line><span class=cl>		<span class=nx>pusher</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Pusher</span>
</span></span><span class=line><span class=cl>		<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>flusher</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>wrap</span><span class=p>.(</span><span class=nx>http</span><span class=p>.</span><span class=nx>Flusher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>pusher</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>wrap</span><span class=p>.(</span><span class=nx>http</span><span class=p>.</span><span class=nx>Pusher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>flusher</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>pusher</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>with</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>flusher</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>pusher</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nx>Pusher</span>
</span></span><span class=line><span class=cl>		<span class=p>}{</span><span class=nx>with</span><span class=p>,</span> <span class=nx>pusher</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>flusher</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>pusher</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>			<span class=nx>http</span><span class=p>.</span><span class=nx>Flusher</span>
</span></span><span class=line><span class=cl>		<span class=p>}{</span><span class=nx>with</span><span class=p>,</span> <span class=nx>flusher</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nx>Flusher</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nx>Pusher</span>
</span></span><span class=line><span class=cl>	<span class=p>}{</span><span class=nx>with</span><span class=p>,</span> <span class=nx>flusher</span><span class=p>,</span> <span class=nx>pusher</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This has two major drawbacks:</p><ul><li>Both code-size and running time of this will increase exponentially with the
number of optional interfaces you have to support (even if you generate the
code).</li><li>You need to know every single optional interface that might be used. While
supporting everything in <code>net/http</code> is certainly tenable, there might be
other optional interfaces, defined by some framework unbeknownst to you. If
you don&rsquo;t know about it, you can&rsquo;t wrap it.</li></ul><h2 id=what-can-we-use-instead>What can we use instead?<a hidden class=anchor aria-hidden=true href=#what-can-we-use-instead>#</a></h2><p>My general advice is, to avoid optional interfaces as much as possible. There
are alternatives, though they also are not entirely satisfying.</p><h3 id=contextvalue>Context.Value<a hidden class=anchor aria-hidden=true href=#contextvalue>#</a></h3><p><code>context</code> was added after most of the optional interfaces where already
defined, but its <code>Value</code> method was meant exactly for this kind of thing: to
pass optional behavior past API boundaries. This will still not solve the
static type safety issue of optional interfaces, but it does mean you can
easily wrap them.</p><p>For example, <code>net/http</code> could instead do</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ctxFlusher</span> <span class=p>=</span> <span class=nf>ctxKey</span><span class=p>(</span><span class=s>&#34;flusher&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GetFlusher</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>f</span> <span class=nx>Flusher</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>ctxFlusher</span><span class=p>).(</span><span class=nx>Flusher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This would enable you to do</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>GetFlusher</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nf>Context</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>f</span><span class=p>.</span><span class=nf>Flush</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If now a middleware wants to wrap <code>ResponseWriter</code>, that&rsquo;s not a problem, as it
will not touch the Context. If a middleware wants to add some other optional
behavior, it can do so easily:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Frobnicator</span> <span class=kd>interface</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Frobnicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ctxFrobnicator</span> <span class=p>=</span> <span class=nf>ctxKey</span><span class=p>(</span><span class=s>&#34;frobnicator&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GetFrobnicator</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>f</span> <span class=nx>Frobnicator</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>ctxFrobnicator</span><span class=p>).(</span><span class=nx>Frobnicator</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As contexts form a linked list of key-value-pairs, this will interact nicely
with whatever optional behavior is already defined.</p><p>There are good reasons to frown upon the usage of <code>Context.Value</code>; but they
apply just as much to optional interfaces.</p><h3 id=extraction-methods>Extraction methods<a hidden class=anchor aria-hidden=true href=#extraction-methods>#</a></h3><p>If you know an interface type that is probable to be wrapped and <em>also</em> has
optional interfaces associated it is possible to enforce the possibility of
dynamic extension in the optional type. So, e.g.:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>http</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ResponseWriter</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Methods…
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ResponseWriterWrapper</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>WrappedResponseWriter</span><span class=p>()</span> <span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// GetFlusher returns an http.Flusher, if res wraps one.
</span></span></span><span class=line><span class=cl><span class=c1>// Otherwise, it returns nil.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>GetFlusher</span><span class=p>(</span><span class=nx>res</span> <span class=nx>ResponseWriter</span><span class=p>)</span> <span class=nx>Flusher</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>res</span><span class=p>.(</span><span class=nx>Flusher</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>f</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>w</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>res</span><span class=p>.(</span><span class=nx>ResponseWriterWrapper</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>GetFlusher</span><span class=p>(</span><span class=nx>w</span><span class=p>.</span><span class=nf>WrappedResponseWriter</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>logger</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>res</span> <span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>	<span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl>	<span class=nx>start</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>logger</span><span class=p>)</span> <span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>code</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Since</span><span class=p>(</span><span class=nx>l</span><span class=p>.</span><span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>log</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=s>&#34;%s %s -&gt; %d (%v)&#34;</span><span class=p>,</span>	<span class=nx>l</span><span class=p>.</span><span class=nx>req</span><span class=p>.</span><span class=nx>Method</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nx>req</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span> <span class=nx>code</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>res</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>code</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>logger</span><span class=p>)</span> <span class=nf>WrappedResponseWriter</span><span class=p>()</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>l</span><span class=p>.</span><span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LogRequests</span><span class=p>(</span><span class=nx>h</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>,</span> <span class=nx>l</span> <span class=o>*</span><span class=nx>log</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Hander</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>logger</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>res</span><span class=p>:</span> <span class=nx>res</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>req</span><span class=p>:</span> <span class=nx>req</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>:</span> <span class=nx>l</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>start</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>h</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>res</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>f</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>GetFlusher</span><span class=p>(</span><span class=nx>res</span><span class=p>);</span> <span class=nx>f</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>f</span><span class=p>.</span><span class=nf>Flush</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This still doesn&rsquo;t address the static typing issue and explicit dependencies,
but at least it enables you to wrap the interface conveniently.</p><p>Note, that this is conceptually similar to the <a href=https://github.com/pkg/errors>errors
package</a>, which calls the wrapper-method
&ldquo;Cause&rdquo;. This package also shows an issue with this pattern; it only
works if <em>all</em> wrappers use it. That&rsquo;s why I think it&rsquo;s important for the
wrapping interface to live in the same package as the wrapped interface; it
provides an authoritative way to do that wrapping, preventing fragmentation.</p><h3 id=provide-statically-typed-apis>Provide statically typed APIs<a hidden class=anchor aria-hidden=true href=#provide-statically-typed-apis>#</a></h3><p><code>net/http</code> could provide alternative APIs for optional interfaces that
explicitly include them. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Hijacker</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>	<span class=nf>Hijack</span><span class=p>()</span> <span class=p>(</span><span class=nx>net</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=o>*</span><span class=nx>bufio</span><span class=p>.</span><span class=nx>ReadWriter</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HijackHandler</span> <span class=kd>interface</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>ServeHijacker</span><span class=p>(</span><span class=nx>w</span> <span class=nx>Hijacker</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>HandleHijacker</span><span class=p>(</span><span class=nx>pattern</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>h</span> <span class=nx>HijackHandler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>For some use cases, this provides a good way to side-step the issue of unsafe
types. Especially if you can come up with a limited set of scenarios that would
rely on the optional behavior, putting them into their own type would be
viable.</p><p>The <code>net/http</code> package could, for example, provide separate <code>ResponseWriter</code>
types for different connection types (for example <code>HTTP2Response</code>). It could
then provide a <code>func(HTTP2Handler) http.Handler</code>, that serves an error if it is
asked to serve an unsuitable connection and otherwise delegates to the passed
Handler. Now, the programmer needs to explicitly wire a handler that requires
HTTP/2 up accordingly. They can rely on the additional features, while also
making clear what paths must be used over HTTP/2.</p><h3 id=gradual-repair>Gradual repair<a hidden class=anchor aria-hidden=true href=#gradual-repair>#</a></h3><p>I think the use of optional interfaces as in <code>database/sql/driver</code> is perfectly
fine - <em>if</em> you plan to eventually remove the original interface. Otherwise,
users will have to continue to implement both interfaces to be usable with your
API, which is especially painful when wrapping interfaces. For example, I
recently wanted to wrap
<a href=http://godoc.org/go/importer#Default>importer.Default</a> to add behavior and
logging. I also needed <a href=http://godoc.org/go/types#ImporterFrom>ImporterFrom</a>,
which required separate implementations, depending on whether the importer
returned by Default implements it or not. Most modern code, however, shouldn&rsquo;t
need that.</p><p>So, for third party packages (the stdlib can&rsquo;t do that, because of
compatibility guarantees), you should consider using the methodology described
in Russ Cox&rsquo; excellent <a href=https://talks.golang.org/2016/refactor.article>Codebase Refactoring</a>
article and actually <em>deprecate</em> and eventually <em>remove</em> the old interface. Use
optional interfaces as a transition mechanism, not a fix.</p><h2 id=how-could-go-improve-the-situation>How could Go improve the situation?<a hidden class=anchor aria-hidden=true href=#how-could-go-improve-the-situation>#</a></h2><h3 id=make-it-possible-for-reflect-to-create-methods>Make it possible for reflect to create methods<a hidden class=anchor aria-hidden=true href=#make-it-possible-for-reflect-to-create-methods>#</a></h3><p>There are currently at least two GitHub issues which would make it possible to
do extend interfaces dynamically:
<a href=https://github.com/golang/go/issues/16522>reflect: NamedOf</a>, <a href=https://github.com/golang/go/issues/4146>reflect: MakeInterface</a>.
I believe this would be the easiest solution - it is backwards compatible and
doesn&rsquo;t require any language changes.</p><h3 id=provide-a-language-mechanism-for-extension>Provide a language mechanism for extension<a hidden class=anchor aria-hidden=true href=#provide-a-language-mechanism-for-extension>#</a></h3><p>The language could provide a native mechanism to express extension, either by
adding a
<a href=https://medium.com/@cep21/interface-wrapping-method-erasure-c523b3549912#13bc>keyword</a>
for it or, for Go2, by considering to make extension the default behavior for
<code>interface->struct</code> embedding. I&rsquo;m not sure either is a good idea, though. I
would probably prefer the latter, because of my distaste for keywords. Note,
that it would still be possible to then compose an interface into a struct,
just not via embedding but by adding a field and delegation-methods.
Personally, I&rsquo;m not a huge fan of embedding interfaces in structs anyway except
when I&rsquo;m explicitly trying to extend them with additional behavior. Their
zero-value is not usable, so it requires additional hoops to jump through.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I recommend:</p><ul><li>If at all possible, avoid optional interfaces in APIs you provide. They are
just too inconvenient and un-Go-ish.</li><li>Be careful when wrapping interfaces, in particular when there are known
optional interfaces for them.</li></ul><p>Using optional interfaces correctly is inconvenient and cumbersome. That should
signal that you are fighting the language. The workarounds needed all try to
circumvent one or more design decision of Go: to value composition over
inheritance, to prefer static typing and to make computation and behavior
obvious from code. To me, that signifies that optional interfaces are
fundamentally not a good fit for the language.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=Bookwyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>