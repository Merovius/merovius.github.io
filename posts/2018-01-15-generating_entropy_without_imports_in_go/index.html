<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generating entropy without imports in Go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Generating entropy without imports in Go"><meta property="og:description" content="I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-15T01:04:30+00:00"><meta property="article:modified_time" content="2018-01-15T01:04:30+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generating entropy without imports in Go"><meta name=twitter:description content="I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Generating entropy without imports in Go","item":"https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generating entropy without imports in Go","name":"Generating entropy without imports in Go","description":"I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages.","keywords":["golang","programming"],"articleBody":"tl;dr: I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages.\nThis post is inspired by a comment on reddit, saying\n […]given the constraints of no imports and the function signature:\nfunc F(map[string]string) map[string]string { ... }\nF must use a deterministic algorithm, since it is a deterministic algorithm it can be represented in a finite state machine.\n Now, the point of this comment was to talk about how to then compile such a function into a deterministic finite state machine, but it got me thinking about a somewhat different question. If we disallow any imports and assume a standard (gc) Go implementation - how many ways can we find to create a non-deterministic function?\nSo, the challenge I set to myself was: Write a function func() string that a) can not refer to any qualified identifier (i.e. no imports) and b) is non-deterministic, that is, produces different outputs on each run. To start me off, I did add a couple of helpers, to accumulate entropy, generate random numbers from it and to format strings as hex, without any imports:\ntype rand uint32 func (r *rand) mix(v uint32) { *r = ((*r  5) + *r) + rand(v) } func (r *rand) rand() uint32 { mx := rand(int32(*r)31) \u0026 0xa8888eef *r = *r1 ^ mx return uint32(*r) } func hex(v uint32) string { var b []byte for v != 0 { if x := byte(v \u0026 0xf); x  10 { b = append(b, '0'+x) } else { b = append(b, 'a'+x-10) } v = 4 } return string(b) } Obviously, these could be inlined, but separating them allows us to reuse them for our different functions. Then I set about the actual task at hand.\nMethod 1: Map iteration In Go, the iteration order of maps is not specified:\n The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next.\n But gc, the canonical Go implementation, actively randomizes the map iteration order to prevent programs from depending on it. We can use this, to receive some of entropy from the runtime, by creating a map and iterating over it:\nfunc MapIteration() string { var r rand m := make(map[uint32]bool) for i := uint32(0); i  100; i++ { m[i] = true } for i := 0; i  1000; i++ { for k := range m { r.mix(k) break // the rest of the loop is deterministic  } } return hex(r.rand()) } We first create a map with a bunch of keys. We then iterate over it a bunch of times; each map iteration gives us a different start index, which we mix into our entropy pool.\nMethod 2: Select Go actually defines a way in which the runtime is giving us access to entropy directly:\n If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection.\n So the spec guarantees that if we have multiple possible communications in a select, the case has to be chosen non-deterministically. We can, again, extract that non-determinism:\nfunc Select() string { var r rand ch := make(chan bool) close(ch) for i := 0; i  1000; i++ { select { case ch: r.mix(1) case ch: r.mix(2) } } return hex(r.rand()) } We create a channel and immediately close it. We then create a select-statement with two cases and depending on which was taken, we mix a different value into our entropy pool. The channel is closed, to guarantee that communication can always proceed. This way, we extract one bit of entropy per iteration.\nNote, that there is no racing or concurrency involved here: This is simple, single-threaded Go code. The randomness comes directly from the runtime. Thus, this should work in any compliant Go implementation. The playground, however, is not compliant with the spec in this regard, strictly speaking. It is deliberately deterministic.\nMethod 3: Race condition This method exploits the fact, that on a multi-core machine at least, the Go scheduler is non-deterministic. So, if we let two goroutines race to write a value to a channel, we can extract some entropy from which one wins this race:\nfunc RaceCondition() string { var r rand for i := 0; i  1000; i++ { ch := make(chan uint32, 2) start := make(chan bool) go func() { start ch  1 }() go func() { start ch  2 }() close(start) r.mix(ch) } return hex(r.rand()) } The start channel is there to make sure that both goroutines become runnable concurrently. Otherwise, the first goroutine would be relatively likely to write the value before the second is even spawned.\nMethod 4: Allocation/data races Another thought I had, was to try to extract some entropy from the allocator or GC. The basic idea is, that the address of an allocated value might be non-deterministic - in particular, if we allocate a lot. We can then try use that as entropy.\nHowever, I could not make this work very well, for the simple reason that Go does not allow you to actually do anything with pointers - except dereferencing and comparing them for equality. So while you might get non-deterministic values, those values can’t be used to actually generate random numbers.\nI thought I might be able to somehow get a string or integer representation of some pointer without any imports. One way I considered was inducing a runtime-panic and recovering that, in the hope that the error string would contain a stacktrace or offending values. However, none of the error strings created by the runtime actually seem to contain any values that could be used here.\nI also tried a workaround to interpret the pointer as an integer, by exploiting race conditions to do unsafe operations:\nfunc DataRace() string { var r rand var data *uintptr var addr *uintptr var i, j, k interface{} i = (*uintptr)(nil) j = \u0026data done := false go func() { for !done { k = i k = j } }() for { if p, ok := k.(*uintptr); ok \u0026\u0026 p != nil { addr = p done = true break } } data = new(uintptr) r.mix(uint32(*addr)) return hex(r.rand()) } It turns out, however, that at least this particular instance of a data race has been fixed since Russ Cox wrote that blog post. In Go 1.9, this code just loops endlessly. I tried it in Go 1.5, though, and it works there - but we don’t get a whole lot of entropy (addresses are not that random). With other methods, we could re-run the code to collect more entropy, but in this case, I believe the escape analysis gets into our way by stack-allocating the pointer, so it will be the same one on each run.\nI like this method, because it uses several obscure steps to work, but on the other hand, it’s the least reliable and it requires an old Go version.\nYour Methods? These are all the methods I could think of; but I’m sure I missed a couple. If you can think of any, feel free to let me know on Twitter, reddit or hackernews :) I also posted the code in a gist, so you can download and run it yourself, but keep in mind, that the last method busy-loops in newer Go versions.\n","wordCount":"1233","inLanguage":"en","datePublished":"2018-01-15T01:04:30Z","dateModified":"2018-01-15T01:04:30Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Generating entropy without imports in Go</h1><div class=post-meta><span title="2018-01-15 01:04:30 +0000 UTC">January 15, 2018</span></div></header><div class=post-content><p><strong>tl;dr: I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages.</strong></p><p>This post is inspired by a <a href=https://www.reddit.com/r/golang/comments/7qb74r/can_golang_package_source_with_no_imports_be/dso7xsc/>comment on reddit</a>,
saying</p><blockquote><p>[…]given the constraints of no imports and the function signature:</p><p><code>func F(map[string]string) map[string]string { ... }</code></p><p>F must use a deterministic algorithm, since it is a deterministic algorithm
it can be represented in a finite state machine.</p></blockquote><p>Now, the point of this comment was to talk about how to then compile such a
function into a deterministic finite state machine, but it got me thinking
about a somewhat different question. If we disallow any imports and assume a
standard (gc) Go implementation - how many ways can we find to create a
non-deterministic function?</p><p>So, the challenge I set to myself was: Write a function <code>func() string</code> that a)
can not refer to any qualified identifier (i.e. no imports) and b) is
non-deterministic, that is, produces different outputs on each run. To start me
off, I did add a couple of helpers, to accumulate entropy, generate random
numbers from it and to format strings as hex, without any imports:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>rand</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>rand</span><span class=p>)</span> <span class=nf>mix</span><span class=p>(</span><span class=nx>v</span> <span class=kt>uint32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>r</span> <span class=p>=</span> <span class=p>((</span><span class=o>*</span><span class=nx>r</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span><span class=p>)</span> <span class=o>+</span> <span class=o>*</span><span class=nx>r</span><span class=p>)</span> <span class=o>+</span> <span class=nf>rand</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>rand</span><span class=p>)</span> <span class=nf>rand</span><span class=p>()</span> <span class=kt>uint32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mx</span> <span class=o>:=</span> <span class=nf>rand</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=o>*</span><span class=nx>r</span><span class=p>)</span><span class=o>&gt;&gt;</span><span class=mi>31</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xa8888eef</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>r</span> <span class=p>=</span> <span class=o>*</span><span class=nx>r</span><span class=o>&lt;&lt;</span><span class=mi>1</span> <span class=p>^</span> <span class=nx>mx</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>uint32</span><span class=p>(</span><span class=o>*</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hex</span><span class=p>(</span><span class=nx>v</span> <span class=kt>uint32</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>v</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>x</span> <span class=o>:=</span> <span class=nb>byte</span><span class=p>(</span><span class=nx>v</span> <span class=o>&amp;</span> <span class=mh>0xf</span><span class=p>);</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>10</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=sc>&#39;0&#39;</span><span class=o>+</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=sc>&#39;a&#39;</span><span class=o>+</span><span class=nx>x</span><span class=o>-</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>v</span> <span class=o>&gt;&gt;=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Obviously, these could be inlined, but separating them allows us to reuse them
for our different functions. Then I set about the actual task at hand.</p><h3 id=method-1-map-iteration>Method 1: Map iteration<a hidden class=anchor aria-hidden=true href=#method-1-map-iteration>#</a></h3><p>In Go, the iteration order of maps is <a href=https://golang.org/ref/spec#For_range>not specified</a>:</p><blockquote><p>The iteration order over maps is not specified and is not guaranteed to be
the same from one iteration to the next.</p></blockquote><p>But <code>gc</code>, the canonical Go implementation, actively
<a href=https://golang.org/doc/go1.3#map>randomizes</a> the map iteration order to
prevent programs from depending on it. We can use this, to receive some of
entropy from the runtime, by creating a map and iterating over it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MapIteration</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>r</span> <span class=nx>rand</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>uint32</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uint32</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>r</span><span class=p>.</span><span class=nf>mix</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span> <span class=c1>// the rest of the loop is deterministic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>hex</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nf>rand</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We first create a map with a bunch of keys. We then iterate over it a bunch of
times; each map iteration gives us a different start index, which we mix into
our entropy pool.</p><h3 id=method-2-select>Method 2: Select<a hidden class=anchor aria-hidden=true href=#method-2-select>#</a></h3><p>Go actually defines <a href=https://golang.org/ref/spec#Select_statements>a way</a> in
which the runtime is giving us access to entropy directly:</p><blockquote><p>If one or more of the communications can proceed, a single one that can
proceed is chosen via a uniform pseudo-random selection.</p></blockquote><p>So the spec guarantees that if we have multiple possible communications in a
select, the case <em>has</em> to be chosen non-deterministically. We can, again,
extract that non-determinism:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Select</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>r</span> <span class=nx>rand</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>r</span><span class=p>.</span><span class=nf>mix</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>r</span><span class=p>.</span><span class=nf>mix</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>hex</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nf>rand</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We create a channel and immediately close it. We then create a select-statement
with two cases and depending on which was taken, we mix a different value into
our entropy pool. The channel is closed, to guarantee that communication can
always proceed. This way, we extract one bit of entropy per iteration.</p><p>Note, that there is no racing or concurrency involved here: This is simple,
single-threaded Go code. The randomness comes directly from the runtime. Thus,
this should work in any compliant Go implementation. The <a href=https://play.golang.org/>playground</a>,
however, is not compliant with the spec in this regard, strictly speaking. It
is deliberately deterministic.</p><h3 id=method-3-race-condition>Method 3: Race condition<a hidden class=anchor aria-hidden=true href=#method-3-race-condition>#</a></h3><p>This method exploits the fact, that on a multi-core machine at least, the Go
scheduler is non-deterministic. So, if we let two goroutines race to write a
value to a channel, we can extract some entropy from which one wins this race:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RaceCondition</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>r</span> <span class=nx>rand</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint32</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>start</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=o>&lt;-</span><span class=nx>start</span>
</span></span><span class=line><span class=cl>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=o>&lt;-</span><span class=nx>start</span>
</span></span><span class=line><span class=cl>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nf>mix</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>hex</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nf>rand</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>start</code> channel is there to make sure that both goroutines become runnable
concurrently. Otherwise, the first goroutine would be relatively likely to
write the value before the second is even spawned.</p><h3 id=method-4-allocationdata-races>Method 4: Allocation/data races<a hidden class=anchor aria-hidden=true href=#method-4-allocationdata-races>#</a></h3><p>Another thought I had, was to try to extract some entropy from the allocator or
GC. The basic idea is, that the address of an allocated value might be
non-deterministic - in particular, if we allocate a lot. We can then try use
that as entropy.</p><p>However, I could not make this work very well, for the simple reason that Go
does not allow you to actually do anything with pointers - except dereferencing
and comparing them for equality. So while you might get non-deterministic
values, those values can&rsquo;t be used to actually generate random numbers.</p><p>I thought I might be able to somehow get a string or integer representation of
some pointer without any imports. One way I considered was inducing a
runtime-panic and recovering that, in the hope that the error string would
contain a stacktrace or offending values. However, none of the error strings
created by the runtime actually seem to contain any values that could be used
here.</p><p>I also tried a workaround to interpret the pointer as an integer, by exploiting
<a href=https://research.swtch.com/gorace>race conditions</a> to do unsafe operations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DataRace</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>r</span> <span class=nx>rand</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>data</span> <span class=o>*</span><span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>addr</span> <span class=o>*</span><span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>k</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>i</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>j</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>k</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>			<span class=nx>k</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>k</span><span class=p>.(</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>);</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>p</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>addr</span> <span class=p>=</span> <span class=nx>p</span>
</span></span><span class=line><span class=cl>			<span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>data</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>uintptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nf>mix</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=o>*</span><span class=nx>addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>hex</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nf>rand</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It turns out, however, that at least this particular instance of a data race
has been fixed since Russ Cox wrote that blog post. In Go 1.9, this code just
loops endlessly. I tried it in Go 1.5, though, and it works there - but we
don&rsquo;t get a whole lot of entropy (addresses are not <em>that</em> random). With other
methods, we could re-run the code to collect more entropy, but in this case,
I believe the escape analysis gets into our way by stack-allocating the
pointer, so it will be the same one on each run.</p><p>I like this method, because it uses several obscure steps to work, but on the
other hand, it&rsquo;s the least reliable and it requires an old Go version.</p><h3 id=your-methods>Your Methods?<a hidden class=anchor aria-hidden=true href=#your-methods>#</a></h3><p>These are all the methods I could think of; but I&rsquo;m sure I missed a couple. If
you can think of any, feel free to let me know on
<a href=https://twitter.com/TheMerovius>Twitter</a>,
<a href=https://www.reddit.com/r/golang/comments/7qfvzu/generating_entropy_without_imports_in_go/>reddit</a>
or <a href="https://news.ycombinator.com/item?id=16147475">hackernews</a> :) I also posted
the code in a
<a href=https://gist.github.com/Merovius/283ff12a1186d001815485fca1094968>gist</a>, so
you can download and run it yourself, but keep in mind, that the last method
busy-loops in newer Go versions.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>