<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using Hilbert Curves to 100% Zelda | Mero's Blog</title><meta name=keywords content="games,math,programming,zelda"><meta name=description content="Using math, I made it a lot easier to find the last undiscovered parts of my Zelda - Breath Of The Wild map."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-07-22-using-hilbert-curves-to-100-zelda/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Using Hilbert Curves to 100% Zelda"><meta property="og:description" content="Using math, I made it a lot easier to find the last undiscovered parts of my Zelda - Breath Of The Wild map."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-07-22-using-hilbert-curves-to-100-zelda/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-07-22T23:56:00+00:00"><meta property="article:modified_time" content="2017-07-22T23:56:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Hilbert Curves to 100% Zelda"><meta name=twitter:description content="Using math, I made it a lot easier to find the last undiscovered parts of my Zelda - Breath Of The Wild map."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Using Hilbert Curves to 100% Zelda","item":"https://blog.merovius.de/posts/2017-07-22-using-hilbert-curves-to-100-zelda/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using Hilbert Curves to 100% Zelda","name":"Using Hilbert Curves to 100% Zelda","description":"Using math, I made it a lot easier to find the last undiscovered parts of my Zelda - Breath Of The Wild map.","keywords":["games","math","programming","zelda"],"articleBody":"tl;dr: I used Hilbert Curves to make it quicker to walk through a list of locations on a map, so I could could fully complete a video game.\nAs you probably know recently the question of what the best Zelda Game is was finally settled by Breath Of The Wild. Like most people I know I ended up playing. And to keep me engaged I early on decided that I would get as close as possible to 100% of the game before finishing it. That is I wanted to finish all shrines, find all Korok Seeds, max out all armor and do all quests before killing Ganon. I recently finished that and finally killed Ganon. Predictably, I was in for a disappointment:\n98.59 percent! I did expect that though. The reason is that only certain things count into the percentage as displayed; Korok Seeds are one of them, Shrines are another. But it also counts landmarks and locations as shown on the map. Each contributes 1/12% to the total.\nSo I started on the onerous task of finding the last 17 locations. I’m not above using help for that so I carefully scrolled through an online map of the BotW universe, maticulously comparing the locations on it with the ones already on my in-game map. Anything I haven’t visited was marked and visited. But that only put me to 99.58%; I was still missing 5 locations. apparently I didn’t compare carefully enough.\nI needed a more systematic approach. I started to instead go through an alphabetical list of locations, looking up each on the map and see if I already had it mapped. But that got old really quickly. Alphabetical just wasn’t a great way to organize these; I wanted a list that I could systematically check. But I didn’t want it alphabetically but geographically. I didn’t want to have to jump around the map to try and find the next one. Which is when I realized that this would be the perfect application for a Hilbert curve.\nIf you don’t know (though you should really just read the Wikipedia Article), the Hilbert curve is a space filling fractal curve, that is a continuous bijective map from the real number line to the plane. It is iteratively defined as the limit of finite curves that get denser and denser. One of the most interesting properties of the curve and its finite approximations is that points that are close on the real number line get mapped to points that are close in the plane. So if we could extract all locations from the online map, figure out for each what real number gets mapped to that point and order the locations by those numbers, we’d get a list of locations where neighbors in the list are close to each other on the map. Presumably, that would make for easy checking of the list: The next location should be pretty much neighbouring the previous one and if I can’t find a location nearby, chances are that I didn’t visit it yet (and I can then look it up specifically).\n[edit] Commentors on reddit and Hacker news have pointed out correctly, that all curves satisfy the property that near point on the line map to near points on the plane. What makes the Hilbert Curve special, is that we work on finite approximations and with the Hilbert Curve, we don’t have to worry about the “correct” level of discrete approximation.\nTo see what that means, we can look at a zig-zag curve. Say, we split our map into a 100000x100000 grid and move in a zig-zag, left-to-right, top-to-bottom. Given how sparse our point-set is, this would mean that most of the rows are empty and some of them would have only one point on them. So we wozuld have to constantly move along the entire width of the map. On the other hand, if we split it into a 2x2 grid, it wouldn’t be very helpful; a lot of points would end up in the same quadrant, which would be very large, so we wouldn’t have won anything. So there would have to be some fineness of the grid that’s “just right” somewhere in the middle, which we’d need to find.\nOn the other hand with Hilbert Curves, this isn’t a problem. That’s because the limit of the finite approximations is continuous (which isn’t the case with the limit of zig-zag curves). What that means, in essence, is that where a point falls on the curve won’t jump around a lot when we make our grid finer, it will “home in” to its final location on the continuous curve. A first order Hilbert Curve is just a zig-zag curve, so it has the same problem as the 2x2-grid zig-zag line. But as we increase it’s order, the points will just become more and more local, instead of requiring scanning empty space. That is the interesting consequence of the Hilbert curve being space-filling.\nReally, this video explains it much better than I ever could (even though I find the example given there slightly ridiculous). In the end, I mostly agree with the commentors; it probably wouldn’t have been too hard to find a good approximation that would make a zig-zag curve work well. But I had Hilbert Curves ready anyway and appreciated the opportunity to usue them.[/edit]\nThe first step for this was to get a list of locations and their corresponding positions. I was pretty sure that the online map should have that available somehow, as it uses some Google Maps framework to draw the map. So I looked at the network tab of the Chrome developer tools, found the URL that loaded the landmark data, copied the request as curl and saved the output for further massaging.\nThe returned file turns out to not actually be JSON (that’d be too easy, I guess) but some kind of javascript-code which is then probably eventually eval’d to get the data (edit: It has been pointed out, that this is just JSONP. I was aware that this is probably the case, but didn’t feel comfortable using the term, as I don’t know enough about it. I also didn’t consider it very important) :\n/**/jQuery31106443585752152035_1500757689075(/* json-data */) I just removed everything but the actual JSON with my editor and ran it through a pretty-printer, to get at it’s actual structure. I spare you the details; it turns out the list of locations isn’t even simply contained in that it’s embedded as another string, with HTML tags, as a property (twice!).\nSo I quickly hacked together some go code to dissect the data and voilà: Got a list of location names with the corresponding positions:\nfunc main() { var data struct { Parse struct { Properties []struct { Name string `json:\"name\"` Content string `json:\"*\"` } `json:\"properties\"` } `json:\"parse\"` } if err := json.NewDecoder(os.Stdin).Decode(\u0026data); err != nil { panic(err) } var content string for _, p := range data.Parse.Properties { if p.Name == \"description\" { content = p.Content } } if content == \"\" { panic(\"no content\") } var landmarks []struct { Type string Geometry struct { Type string Coordinates []float64 } Properties struct { Type string Id string Name string Link string Src string } } if err := json.NewDecoder(arrayReader(content)).Decode(\u0026landmarks); err != nil { panic(err) } for _, m := range landmarks { fmt.Printf(\"%s: %v\\n\", m.Properties.Name, m.Geometry.Coordinates) } } func arrayReader(s string) io.Reader { s = strings.TrimSuffix(strings.TrimSpace(s), \",\") return io.MultiReader(strings.NewReader(\"[\"), strings.NewReader(s), strings.NewReader(\"]\")) } This bode well. Now all I needed to do was to calculate the Hilbert Curve coordinate for each of them and I’d have what I need. The Wikipedia Article helpfully contains an implementation of the corresponding algorithm in C. xy2d assumes a discrete grid of n² cells and returns an integer preimage of the given coordinates. The coordinates we have are all floating point numbers between 0 and 2 (ish) with 5 significant digits. I figured that 65536 should be able to represent the granularity of points well enough, so I chose that as an n, ported the code to go, sorted the locations accordingly and it actually worked!\nfunc main() { // Same stuff as before  sort.Slice(landmarks, func(i, j int) bool { xi := f2d(landmarks[i].Geometry.Coordinates[0]) yi := f2d(landmarks[i].Geometry.Coordinates[1]) xj := f2d(landmarks[j].Geometry.Coordinates[0]) yj := f2d(landmarks[j].Geometry.Coordinates[1]) di := xy2d(116, xi, yi) dj := xy2d(116, xj, yj) return di  dj }) for _, m := range landmarks { fmt.Printf(\"%s: %v\\n\", m.Properties.Name, m.Geometry.Coordinates) } } func xy2d(n, x, y int) int { var d int for s := n / 2; s  0; s = s / 2 { var rx, ry int if (x \u0026 s)  0 { rx = 1 } if (y \u0026 s)  0 { ry = 1 } d += s * s * ((3 * rx) ^ ry) x, y = rot(s, x, y, rx, ry) } return d } func rot(n, x, y, rx, ry int) (int, int) { if ry == 0 { if ry == 1 { x = n - 1 - x y = n - 1 - y } x, y = y, x } return x, y } func f2d(f float64) int { return int((1  15) * f) } In the end, there was still a surprising amount of jumping around involved. I don’t know whether that’s accidental (i.e. due to my code being wrong) or inherent (that is the Hilbert curve just can’t map this perfectly well). I assume it’s a bit of both. The list also contains the same landmark multiple times. This is because things like big lakes or plains where marked multiple times. It would be trivial to filter duplicates but I actually found them reasonably helpfull when having to jump around.\nThere might also be better approaches than Hilbert Curves. For example, we could view it as an instance of the Traveling Salesman Problem with a couple of hundred points; it should be possible to have a good heuristic solution for that. On the other hand, a TSP solution doesn’t necessarily only have short jumps, so it might not be that good?\nIn any case, this approach was definitely good enough for me and it’s probably the nerdiest thing I ever did :)\n","wordCount":"1709","inLanguage":"en","datePublished":"2017-07-22T23:56:00Z","dateModified":"2017-07-22T23:56:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-07-22-using-hilbert-curves-to-100-zelda/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Using Hilbert Curves to 100% Zelda</h1><div class=post-meta><span title="2017-07-22 23:56:00 +0000 UTC">July 22, 2017</span></div></header><div class=post-content><p><strong>tl;dr: I used Hilbert Curves to make it quicker to walk through a list of locations on a map, so I could could fully complete a video game.</strong></p><p>As you probably know recently the question of what <a href=https://s-media-cache-ak0.pinimg.com/originals/eb/31/e5/eb31e5c0a14d4a68ab8d492e848de608.jpg>the best Zelda
Game</a>
is was finally settled by Breath Of The Wild. Like most people I know I ended
up playing. And to keep me engaged I early on decided that I would get as close
as possible to 100% of the game before finishing it. That is I wanted to finish
all shrines, find all Korok Seeds, max out all armor and do all quests before
killing Ganon. I recently finished that and finally killed Ganon. Predictably,
I was in for a disappointment:</p><p><img loading=lazy src=/assets/botw_9859.jpg alt=98.59%></p><p>98.59 percent! I did expect that though. The reason is that only certain things
count into the percentage as displayed; Korok Seeds are one of them, Shrines
are another. But it also counts landmarks and locations as shown on the map.
Each contributes 1/12% to the total.</p><p>So I started on the onerous task of finding the last 17 locations. I&rsquo;m not
above using help for that so I carefully scrolled through <a href=https://www.zeldadungeon.net/breath-of-the-wild-interactive-map>an online
map</a> of the
BotW universe, maticulously comparing the locations on it with the ones already
on my in-game map. Anything I haven&rsquo;t visited was marked and visited. But that
only put me to 99.58%; I was still missing 5 locations. apparently I didn&rsquo;t
compare carefully enough.</p><p>I needed a more systematic approach. I started to instead go through an
<a href=http://www.ign.com/wikis/the-legend-of-zelda-breath-of-the-wild/Locations_by_Region>alphabetical list of
locations</a>,
looking up each on the map and see if I already had it mapped. But that got old
<em>really</em> quickly. Alphabetical just wasn&rsquo;t a great way to organize these; I
wanted a list that I could systematically check. But I didn&rsquo;t want it
alphabetically but geographically. I didn&rsquo;t want to have to jump around the map
to try and find the next one. Which is when I realized that this would be the
perfect application for a <a href=https://en.wikipedia.org/wiki/Hilbert_curve>Hilbert curve</a>.</p><p>If you don&rsquo;t know (though you should really just read the Wikipedia Article),
the Hilbert curve is a space filling fractal curve, that is a continuous
bijective map from the real number line to the plane. It is iteratively
defined as the limit of finite curves that get denser and denser. One of the
most interesting properties of the curve and its finite approximations is that
points that are close on the real number line get mapped to points that are
close in the plane. So if we could extract all locations from the online map,
figure out for each what real number gets mapped to that point and order the
locations by those numbers, we&rsquo;d get a list of locations where neighbors in the
list are close to each other on the map. Presumably, that
would make for easy checking of the list: The next location should be pretty
much neighbouring the previous one and if I can&rsquo;t find a location nearby,
chances are that I didn&rsquo;t visit it yet (and I can then look it up specifically).</p><p><strong>[edit]</strong> Commentors on
<a href=https://www.reddit.com/r/programming/comments/6oxra8/using_hilbert_curves_to_100_zelda/dklhina/>reddit</a>
and <a href="https://news.ycombinator.com/item?id=14830691">Hacker news</a> have pointed
out correctly, that all curves satisfy the property that near point on the line
map to near points on the plane. What makes the Hilbert Curve special, is that
we work on finite approximations and with the Hilbert Curve, we don&rsquo;t have to
worry about the &ldquo;correct&rdquo; level of discrete approximation.</p><p>To see what that means, we can look at a zig-zag curve. Say, we split our map
into a 100000x100000 grid and move in a zig-zag, left-to-right, top-to-bottom.
Given how sparse our point-set is, this would mean that most of the rows are
empty and some of them would have only one point on them. So we wozuld have to
constantly move along the entire width of the map. On the other hand, if we
split it into a 2x2 grid, it wouldn&rsquo;t be very helpful; a lot of points would
end up in the same quadrant, which would be very large, so we wouldn&rsquo;t have won
anything. So there would have to be some fineness of the grid that&rsquo;s &ldquo;just
right&rdquo; somewhere in the middle, which we&rsquo;d need to find.</p><p>On the other hand with Hilbert Curves, this isn&rsquo;t a problem. That&rsquo;s because the
<em>limit</em> of the finite approximations is continuous (which isn&rsquo;t the case with
the limit of zig-zag curves). What that means, in essence, is that where a
point falls on the curve won&rsquo;t jump around a lot when we make our grid finer,
it will &ldquo;home in&rdquo; to its final location on the continuous curve. A first order
Hilbert Curve is just a zig-zag curve, so it has the same problem as the
2x2-grid zig-zag line. But as we increase it&rsquo;s order, the points will just
become more and more local, instead of requiring scanning empty space. That is
the interesting consequence of the Hilbert curve being space-filling.</p><p>Really, <a href="https://www.youtube.com/watch?v=3s7h2MHQtxc">this video</a> explains it
much better than I ever could (even though I find the example given there
slightly ridiculous). In the end, I mostly agree with the commentors; it
probably wouldn&rsquo;t have been too hard to find a good approximation that would
make a zig-zag curve work well. But I had Hilbert Curves ready anyway and
appreciated the opportunity to usue them.<strong>[/edit]</strong></p><p>The first step for this was to get a list of locations and their corresponding
positions. I was pretty sure that the online map should have that available
somehow, as it uses some Google Maps framework to draw the map. So I
looked at the network tab of the Chrome developer tools, found the URL that
loaded the landmark data, copied the request as curl and saved the output for
further massaging.</p><p><img loading=lazy src=/assets/botw_curl.jpg alt="Chrome developer tools - copy as cURL"></p><p>The returned file turns out to not actually be JSON (that&rsquo;d be too easy, I
guess) but some kind of javascript-code which is then probably eventually
eval&rsquo;d to get the data (<strong>edit</strong>: It has been pointed out, that this is just
<a href=https://en.wikipedia.org/wiki/JSONP>JSONP</a>. I was aware that this is probably
the case, but didn&rsquo;t feel comfortable using the term, as I don&rsquo;t know enough
about it. I also didn&rsquo;t consider it very important) :</p><pre tabindex=0><code>/**/jQuery31106443585752152035_1500757689075(/* json-data */)
</code></pre><p>I just removed everything but the actual JSON with my editor and ran it through
a pretty-printer, to get at it&rsquo;s actual structure. I spare you the details; it
turns out the list of locations isn&rsquo;t even simply contained in that it&rsquo;s
embedded as another string, with HTML tags, as a property (twice!).</p><p>So I quickly hacked together some go code to dissect the data and voilà: Got a
list of location names with the corresponding positions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Parse</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Properties</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>Name</span>    <span class=kt>string</span> <span class=s>`json:&#34;name&#34;`</span>
</span></span><span class=line><span class=cl>				<span class=nx>Content</span> <span class=kt>string</span> <span class=s>`json:&#34;*&#34;`</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=s>`json:&#34;properties&#34;`</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=s>`json:&#34;parse&#34;`</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span><span class=p>).</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>data</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>content</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span><span class=p>.</span><span class=nx>Parse</span><span class=p>.</span><span class=nx>Properties</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Name</span> <span class=o>==</span> <span class=s>&#34;description&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>content</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Content</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>content</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;no content&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>landmarks</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Type</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>		<span class=nx>Geometry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Type</span>        <span class=kt>string</span>
</span></span><span class=line><span class=cl>			<span class=nx>Coordinates</span> <span class=p>[]</span><span class=kt>float64</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>Properties</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Type</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>			<span class=nx>Id</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>			<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>			<span class=nx>Link</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>			<span class=nx>Src</span>  <span class=kt>string</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nf>arrayReader</span><span class=p>(</span><span class=nx>content</span><span class=p>)).</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>landmarks</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>landmarks</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s: %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Properties</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>arrayReader</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSuffix</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=s>&#34;,&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>io</span><span class=p>.</span><span class=nf>MultiReader</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=s>&#34;[&#34;</span><span class=p>),</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=s>&#34;]&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This bode well. Now all I needed to do was to calculate the Hilbert Curve
coordinate for each of them and I&rsquo;d have what I need. The Wikipedia Article
helpfully contains an
<a href=https://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms>implementation</a>
of the corresponding algorithm in C. <code>xy2d</code> assumes a discrete grid of n² cells
and returns an integer preimage of the given coordinates. The coordinates we have
are all floating point numbers between 0 and 2 (ish) with 5 significant digits.
I figured that 65536 should be able to represent the granularity of points well
enough, so I chose that as an n, ported the code to go, sorted the locations
accordingly and it <em>actually worked</em>!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Same stuff as before
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>landmarks</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>xi</span> <span class=o>:=</span> <span class=nf>f2d</span><span class=p>(</span><span class=nx>landmarks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>yi</span> <span class=o>:=</span> <span class=nf>f2d</span><span class=p>(</span><span class=nx>landmarks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>xj</span> <span class=o>:=</span> <span class=nf>f2d</span><span class=p>(</span><span class=nx>landmarks</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>yj</span> <span class=o>:=</span> <span class=nf>f2d</span><span class=p>(</span><span class=nx>landmarks</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>di</span> <span class=o>:=</span> <span class=nf>xy2d</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>16</span><span class=p>,</span> <span class=nx>xi</span><span class=p>,</span> <span class=nx>yi</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>dj</span> <span class=o>:=</span> <span class=nf>xy2d</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>16</span><span class=p>,</span> <span class=nx>xj</span><span class=p>,</span> <span class=nx>yj</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>di</span> <span class=p>&lt;</span> <span class=nx>dj</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>landmarks</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s: %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Properties</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Geometry</span><span class=p>.</span><span class=nx>Coordinates</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>xy2d</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>d</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>s</span> <span class=o>:=</span> <span class=nx>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>s</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span> <span class=o>/</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>rx</span><span class=p>,</span> <span class=nx>ry</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&amp;</span> <span class=nx>s</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>rx</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nx>y</span> <span class=o>&amp;</span> <span class=nx>s</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ry</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span> <span class=o>+=</span> <span class=nx>s</span> <span class=o>*</span> <span class=nx>s</span> <span class=o>*</span> <span class=p>((</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>rx</span><span class=p>)</span> <span class=p>^</span> <span class=nx>ry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=p>=</span> <span class=nf>rot</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>rx</span><span class=p>,</span> <span class=nx>ry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>d</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rot</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>rx</span><span class=p>,</span> <span class=nx>ry</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ry</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ry</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>x</span> <span class=p>=</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>			<span class=nx>y</span> <span class=p>=</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=p>=</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f2d</span><span class=p>(</span><span class=nx>f</span> <span class=kt>float64</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>int</span><span class=p>((</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span><span class=p>)</span> <span class=o>*</span> <span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the end, there was still a surprising amount of jumping around involved. I
don&rsquo;t know whether that&rsquo;s accidental (i.e. due to my code being wrong) or
inherent (that is the Hilbert curve just can&rsquo;t map this perfectly well). I
assume it&rsquo;s a bit of both. The list also contains the same landmark multiple
times. This is because things like big lakes or plains where marked multiple
times. It would be trivial to filter duplicates but I actually found them
reasonably helpfull when having to jump around.</p><p>There might also be better approaches than Hilbert Curves. For example, we
could view it as an instance of the <a href=https://en.wikipedia.org/wiki/Travelling_salesman_problem>Traveling Salesman
Problem</a> with a
couple of hundred points; it should be possible to have a good heuristic
solution for that. On the other hand, a TSP solution doesn&rsquo;t necessarily only
have short jumps, so it <em>might</em> not be that good?</p><p>In any case, this approach was definitely good enough for me and it&rsquo;s probably
the nerdiest thing I ever did :)</p><p><img loading=lazy src=/assets/botw_1000.jpg alt=100%></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/games/>games</a></li><li><a href=https://blog.merovius.de/tags/math/>math</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li><li><a href=https://blog.merovius.de/tags/zelda/>zelda</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>