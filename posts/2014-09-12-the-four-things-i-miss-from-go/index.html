<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The four things I miss about go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="A short list of four things that I might want to add to go (but probably wouldn&rsquo;t)."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2014-09-12-the-four-things-i-miss-from-go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="The four things I miss about go"><meta property="og:description" content="A short list of four things that I might want to add to go (but probably wouldn&rsquo;t)."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2014-09-12-the-four-things-i-miss-from-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-09-12T17:10:28+00:00"><meta property="article:modified_time" content="2014-09-12T17:10:28+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The four things I miss about go"><meta name=twitter:description content="A short list of four things that I might want to add to go (but probably wouldn&rsquo;t)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"The four things I miss about go","item":"https://blog.merovius.de/posts/2014-09-12-the-four-things-i-miss-from-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The four things I miss about go","name":"The four things I miss about go","description":"A short list of four things that I might want to add to go (but probably wouldn\u0026rsquo;t).","keywords":["golang","programming"],"articleBody":"As people who know me know, my current favourite language is go. One of the best features of go is the lack of features. This is actually the reason I preferred C over most scripting languages for a long time – it does not overburden you with language-features that you first have to wrap your head around. You don’t have to think for a while about what classes or modules or whatever you want to have, you just write your code down and the (more or less) entire language can easily fit inside your head. One of the best writeups of this (contrasting it with python) was done by Gustavo Niemeyer in a blogpost a few years back.\nSo when I say, there are a few things popping up I miss about go, this does not mean I wish them to be included. I subjectively miss them and it would definitely make me happy, if they existed. But I still very much like the go devs for prioritizing simplicity over making me happy.\nSo let’s dig in.\n Generics Weak references Dynamic loading of go code Garbage-collected goroutines  Generics So let’s get this elephant out of the room first. I think this is the most named feature lacking from go. They are asked so often, they have their own entry in the go FAQ. The usual answers are anything from “maybe they will get in” to “I don’t understand why people want generics, go has generic programming using interfaces”. To illustrate one shortcoming of the (current) interface approach, consider writing a (simple) graph-algorithm:\ntype Graph [][]int func DFS(g Graph, start int, visitor func(int)) { visited := make([]bool, len(g)) var dfs func(int) dfs = func(i int) { if visited[i] { return } visitor(i) visited[i] = true for _, j := range g[i] { dfs(j) } } dfs(start) } This uses an adjacency list to represent the graph and does a recursive depth-first-search on it. Now imagine, you want to implement this algorithm generically (given, a DFS is not really hard enough to justify this, but you could just as easily have a more complex algorithm). This could be done like this:\ntype Node interface{} type Graph interface { Neighbors(Node) []Node } func DFS(g Graph, start Node, visitor func(Node)) { visited := make(map[Node]bool) var dfs func(Node) dfs = func(n Node) { if visited[n] { return } visitor(n) visited[n] = true for _, n2 := range g.Neighbors(n) { dfs(n2) } } dfs(start) } This seems simple enough, but it has a lot of problems. For example, we loose type-safety: Even if we write Neighbors(Node) []Node there is no way to tell the compiler, that these instances of Node will actually always be the same. So an implementation of the graph interface would have to do type-assertions all over the place. Another problem is:\ntype AdjacencyList [][]int func (l AdjacencyList) Neighbors(n Node) []Node { i := n.(int) var result []Node for _, j := range l[i] { result = append(result, j) } return result } An implementation of this interface as an adjacency-list actually performs pretty badly, because it can not return an []int, but must return a []Node, and even though int satisfies Node, []int is not assignable to []Node (for good reasons that lie in the implementation of interfaces, but still).\nThe way to solve this, is to always map your nodes to integers. This is what the standard library does in the sort-package. It is exactly the same problem. But it might not always be possible, let alone straightforward, to do this for Graphs, for example if they do not fit into memory (e.g. a web-crawler). The answer is to have the caller maintain this mapping via a map[Node]int or something similar, but… meh.\nWeak references I have to admit, that I am not sure, my use case here is really an important or even very nice one, but let’s assume I want to have a database abstraction that transparently handles pointer-indirection. So let’s say I have two tables T1 and T2 and T2 has a foreign key referencing T1. I think it would be pretty neat, if a database abstraction could automatically deserialize this into a pointer to a T1-value A. But to do this. we would a) need to be able to recognize A a later Put (so if the user changes A and later stores it, the database knows what row in T1 to update) and b) hand out the same pointer, if another row in T2 references the same id.\nThe only way I can think how to do this is to maintain a map[Id]*T1 (or similar), but this would prevent the handed out values to ever be garbage-collected. Even though there a hacks that would allow some use cases for weak references to be emulated, I don’t see how they would work here.\nSo, as in the case of generics, this mainly means that some elegant APIs are not possible in go for library authors (and as I said, in this specific case it probably isn’t a very good idea. For example you would have to think about what happens, if the user gets the same value in two different goroutines from the database).\nDynamic loading of go code It would be useful to be able to dynamically load go code at runtime, to build plugins for go software. Specifically I want a good go replacement for jekyll because I went through some ruby-version-hell with it lately (for example jekyll serve -w still does not work for me with the version packaged in debian) and I think a statically linked go-binary would take a lot of possible pain-points out here. But plugins are a really important feature of jekyll for me, so I still want to be able to customize a page with plugins (how to avoid introducing the same version hell with this is another topic).\nThe currently recommended ways to do plugins are a) as go-packages and recompiling the whole binary for every change of a plugin and b) using sub-processes and net/rpc.\nI don’t feel a) being a good fit here, because it means maintaining a separate binary for every jekyll-site you have which just sounds like a smallish nightmare for binary distributions (plus I have use cases for plugins where even the relatively small compilation times of go would result in an intolerable increase in startup-time).\nb) on the other hand results in a lot of runtime-penalty: For example I can not really pass interfaces between plugins, let alone use channels or something and every function call has to have its parameters and results serialized and deserialized. Where in the same process I can just define a transformation between different formats as a func(r io.Reader) io.Reader or something, in the RPC-context I first have to transmit the entire file over a socket, or have the plugin-author implement a net/rpc server himself and somehow pass a reference to it over the wire. This increases the burden on the plugin-authors too much, I think.\nLuckily, it seems there seems to be some thought put forward recently on how to implement this, so maybe we see this in the nearish future.\nGarbage-collected goroutines Now, this is the only thing I really don’t understand why it is not part of the language. Concurrency in go is a first-class citizen and garbage-collection is a feature emphasized all the time by the go-authors as an advantage. Yet, they both seem to not play entirely well together, making concurrency worse than it has to be.\nSomething like the standard example of how goroutines and channels work goes a little bit like this:\nfunc Foo() { ch := make(chan int) go func() { i := 0 for { ch  i i++ } }() for { fmt.Println(ch) } } Now, this is all well, but what if we want to exit the loop prematurely? We have to do something like this:\nfunc Foo() { ch := make(chan int) done := make(chan bool) go func() { i := 0 for { select { case ch  i: i++ case done: return } } }() for { i := ch if i  1000 { break } fmt.Println(i) } } Because otherwise the goroutine would just stay around for all eternity, effectively being leaked memory. There are entire talks build around this and similar problems, where I don’t really understand why. If we add a break to our first version, Foo returns and suddenly, all other references to ch, except the one the goroutine is blocking on writing to are gone and can be garbage-collected. The runtime can already detect if all goroutines are sleeping and we have a deadlock, the garbage-collector can accurately see what references there are to a given channel, why can we not combine the two to just see “there is absolutely no way, this channel-write can ever succeed, so let’s just kill it and gc all it’s memory”? This would have zero impact on existing programs (because as you can not get any references to goroutines, a deadlocked one can have no side-effect on the rest of the program), but it would make channels so much more fun to work with. It would make channels as iterators a truly elegant pattern, it would simplify pipelines and it would possibly allow a myriad other use cases for channels I can not think of right now. Heck, you could even think about (not sure if this is possible or desirable) running any deferred statements, when a goroutine is garbage-collected, so all other resources held by it will be correctly released.\nThis is the one thing I really wish to be added to the language. Really diving into channels and concurrency right now is very much spoiled for me because I always have to think about draining every channel, always think about what goroutine closes what channels, passing cancellation-channels…\n","wordCount":"1648","inLanguage":"en","datePublished":"2014-09-12T17:10:28Z","dateModified":"2014-09-12T17:10:28Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2014-09-12-the-four-things-i-miss-from-go/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The four things I miss about go</h1><div class=post-meta><span title="2014-09-12 17:10:28 +0000 UTC">September 12, 2014</span></div></header><div class=post-content><p>As people who know me know, my current favourite language is
<a href=http://golang.org/>go</a>. One of the best features of go is the lack of
features. This is actually the reason I preferred C over most scripting
languages for a long time – it does not overburden you with language-features
that you first have to wrap your head around. You don&rsquo;t have to think for a
while about what classes or modules or whatever you want to have, you just
write your code down and the (more or less) entire language can easily fit
inside your head. One of the best writeups of this (contrasting it with python)
was done by Gustavo Niemeyer in a
<a href=http://blog.labix.org/2012/06/26/less-is-more-and-is-not-always-straightforward>blogpost</a>
a few years back.</p><p>So when I say, there are a few things popping up I miss about go, this does not
mean I wish them to be included. I subjectively miss them and it would
definitely make me happy, if they existed. But I still very much like the go
devs for prioritizing simplicity over making me happy.</p><p>So let&rsquo;s dig in.</p><ol><li><a href=#generics>Generics</a></li><li><a href=#weak-references>Weak references</a></li><li><a href=#dynamic-loading-of-go-code>Dynamic loading of go code</a></li><li><a href=#garbage-collected-goroutines>Garbage-collected goroutines</a></li></ol><h2 id=generics>Generics<a hidden class=anchor aria-hidden=true href=#generics>#</a></h2><p>So let&rsquo;s get this elephant out of the room first. I think this is the most
named feature lacking from go. They are asked so often, they have their own
entry in the <a href=http://golang.org/doc/faq#generics>go FAQ</a>. The usual answers
are anything from &ldquo;maybe they will get in&rdquo; to &ldquo;I don&rsquo;t understand why people
want generics, go has generic programming using interfaces&rdquo;. To illustrate one
shortcoming of the (current) interface approach, consider writing a (simple)
graph-algorithm:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>g</span> <span class=nx>Graph</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>visitor</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>g</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>dfs</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dfs</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>visitor</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>visited</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>dfs</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>dfs</span><span class=p>(</span><span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This uses an adjacency list to represent the graph and does a recursive
depth-first-search on it. Now imagine, you want to implement this algorithm
generically (given, a DFS is not really hard enough to justify this, but you
could just as easily have a more complex algorithm). This could be done like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Neighbors</span><span class=p>(</span><span class=nx>Node</span><span class=p>)</span> <span class=p>[]</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>g</span> <span class=nx>Graph</span><span class=p>,</span> <span class=nx>start</span> <span class=nx>Node</span><span class=p>,</span> <span class=nx>visitor</span> <span class=kd>func</span><span class=p>(</span><span class=nx>Node</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>Node</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>dfs</span> <span class=kd>func</span><span class=p>(</span><span class=nx>Node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dfs</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>n</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>visitor</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>visited</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n2</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nf>Neighbors</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>dfs</span><span class=p>(</span><span class=nx>n2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>dfs</span><span class=p>(</span><span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This seems simple enough, but it has a lot of problems. For example, we loose
type-safety: Even if we write <code>Neighbors(Node) []Node</code> there is no way to tell
the compiler, that these instances of <code>Node</code> will actually always be the same.
So an implementation of the graph interface would have to do type-assertions
all over the place. Another problem is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>AdjacencyList</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>AdjacencyList</span><span class=p>)</span> <span class=nf>Neighbors</span><span class=p>(</span><span class=nx>n</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>[]</span><span class=nx>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>i</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>result</span> <span class=p>[]</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>l</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>An implementation of this interface as an adjacency-list actually performs
pretty badly, because it can not return an <code>[]int</code>, but must return a <code>[]Node</code>,
and even though <code>int</code> satisfies <code>Node</code>, <code>[]int</code> is not assignable to <code>[]Node</code>
(for good reasons that lie in the implementation of interfaces, but still).</p><p>The way to solve this, is to always map your nodes to integers. This is what
the standard library does in the
<a href=http://golang.org/pkg/sort/#Interface>sort-package</a>. It is exactly the same
problem. But it might not always be possible, let alone straightforward, to do
this for Graphs, for example if they do not fit into memory (e.g. a
web-crawler). The answer is to have the caller maintain this mapping via a
<code>map[Node]int</code> or something similar, but… meh.</p><h2 id=weak-references>Weak references<a hidden class=anchor aria-hidden=true href=#weak-references>#</a></h2><p>I have to admit, that I am not sure, my use case here is really an important or
even very nice one, but let&rsquo;s assume I want to have a database abstraction that
transparently handles pointer-indirection. So let&rsquo;s say I have two tables T1
and T2 and T2 has a foreign key referencing T1. I think it would be pretty
neat, if a database abstraction could automatically deserialize this into a
pointer to a T1-value <code>A</code>. But to do this. we would a) need to be able to
recognize <code>A</code> a later Put (so if the user changes <code>A</code> and later stores it, the
database knows what row in T1 to update) and b) hand out the <em>same</em> pointer, if
another row in T2 references the same id.</p><p>The only way I can think how to do this is to maintain a <code>map[Id]*T1</code> (or
similar), but this would prevent the handed out values to ever be
garbage-collected. Even though there a
<a href=https://groups.google.com/forum/#!topic/golang-nuts/1ItNOOj8yW8/discussion>hacks</a>
that would allow some use cases for weak references to be emulated, I don&rsquo;t see
how they would work here.</p><p>So, as in the case of generics, this mainly means that some elegant APIs are
not possible in go for library authors (and as I said, in this specific case it
probably isn&rsquo;t a very good idea. For example you would have to think about what
happens, if the user gets the same value in two different goroutines from the
database).</p><h2 id=dynamic-loading-of-go-code>Dynamic loading of go code<a hidden class=anchor aria-hidden=true href=#dynamic-loading-of-go-code>#</a></h2><p>It would be useful to be able to dynamically load go code at runtime, to build
plugins for go software. Specifically I want a good go replacement for
<a href=http://jekyllrb.com/>jekyll</a> because I went through some ruby-version-hell
with it lately (for example <code>jekyll serve -w</code> still does not work for me with
the version packaged in debian) and I think a statically linked go-binary would
take a lot of possible pain-points out here. But plugins are a really important
feature of jekyll for me, so I still want to be able to customize a page with
plugins (how to avoid introducing the same version hell with this is another
topic).</p><p>The currently recommended ways to do plugins are a) as go-packages and
recompiling the whole binary for every change of a plugin and b) using
sub-processes and <a href=http://golang.org/pkg/net/rpc>net/rpc</a>.</p><p>I don&rsquo;t feel a) being a good fit here, because it means maintaining a separate
binary for every jekyll-site you have which just sounds like a smallish
nightmare for binary distributions (plus I have use cases for plugins where even
the relatively small compilation times of go would result in an intolerable
increase in startup-time).</p><p>b) on the other hand results in a lot of runtime-penalty: For example I can not
really pass interfaces between plugins, let alone use channels or something and
every function call has to have its parameters and results serialized and
deserialized. Where in the same process I can just define a transformation
between different formats as a <code>func(r io.Reader) io.Reader</code> or something, in
the RPC-context I first have to transmit the entire file over a socket, or have
the plugin-author implement a <code>net/rpc</code> server himself and somehow pass a
reference to it over the wire. This increases the burden on the plugin-authors
too much, I think.</p><p>Luckily, it seems there seems to be
<a href=https://groups.google.com/forum/#!topic/golang-dev/0_N7DLmrUFA>some thought</a>
put forward recently on how to implement this, so maybe we see this in the
nearish future.</p><h2 id=garbage-collected-goroutines>Garbage-collected goroutines<a hidden class=anchor aria-hidden=true href=#garbage-collected-goroutines>#</a></h2><p>Now, this is the only thing I really don&rsquo;t understand why it is not part of the
language. Concurrency in go is a first-class citizen and garbage-collection is
a feature emphasized all the time by the go-authors as an advantage. Yet, they
both seem to not play entirely well together, making concurrency worse than it
has to be.</p><p>Something like the standard example of how goroutines and channels work goes a
little bit like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>			<span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, this is all well, but what if we want to exit the loop prematurely? We
have to do something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>					<span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>1000</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Because otherwise the goroutine would just stay around for all eternity,
effectively being leaked memory. There are
<a href=http://youtu.be/f6kdp27TYZs>entire</a> <a href=http://youtu.be/QDDwwePbDtw>talks</a>
build around this and similar problems, where I don&rsquo;t really understand why. If
we add a <code>break</code> to our first version, <code>Foo</code> returns and suddenly, all other
references to <code>ch</code>, except the one the goroutine is blocking on writing to are
gone and can be garbage-collected. The runtime can already detect if all
goroutines are sleeping and we have a deadlock, the garbage-collector can
accurately see what references there are to a given channel, why can we not
combine the two to just see &ldquo;there is absolutely <em>no</em> way, this channel-write
can <em>ever</em> succeed, so let&rsquo;s just kill it and gc all it&rsquo;s memory&rdquo;? This would
have zero impact on existing programs (because as you can not get any
references to goroutines, a deadlocked one can have no side-effect on the rest
of the program), but it would make channels <em>so</em> much more fun to work with. It
would make channels as iterators a truly elegant pattern, it would simplify
<a href=http://blog.golang.org/pipelines>pipelines</a> and it would possibly allow a
myriad other use cases for channels I can not think of right now. Heck, you
could even think about (not sure if this is possible or desirable) running any
deferred statements, when a goroutine is garbage-collected, so all other
resources held by it will be correctly released.</p><p>This is the <em>one</em> thing I really wish to be added to the language. Really
diving into channels and concurrency right now is very much spoiled for me
because I always have to think about draining every channel, always think about
what goroutine closes what channels, passing cancellation-channels…</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>