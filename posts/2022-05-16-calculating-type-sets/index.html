<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Calculating type sets is harder than you think | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I try to explain why the problem of calculating the exact contents of a type set in Go is harder than it might seem on the surface."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Calculating type sets is harder than you think"><meta property="og:description" content="I try to explain why the problem of calculating the exact contents of a type set in Go is harder than it might seem on the surface."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-16T09:33:10+00:00"><meta property="article:modified_time" content="2022-05-16T09:33:10+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Calculating type sets is harder than you think"><meta name=twitter:description content="I try to explain why the problem of calculating the exact contents of a type set in Go is harder than it might seem on the surface."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Calculating type sets is harder than you think","item":"https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Calculating type sets is harder than you think","name":"Calculating type sets is harder than you think","description":"I try to explain why the problem of calculating the exact contents of a type set in Go is harder than it might seem on the surface.","keywords":["golang","programming"],"articleBody":" Go 1.18 added the biggest and probably one of the most requested features of all time to the language: Generics. If you want a comprehensive introduction to the topic, there are many out there and I would personally recommend this talk I gave at the Frankfurt Gopher Meetup.\nThis blog post is not an introduction to generics, though. It is about this sentence from the spec:\n Implementation restriction: A compiler need not report an error if an operand’s type is a type parameter with an empty type set.\n As an example, consider this interface:\ntype C interface { int M() } This constraint can never be satisfied. It says that a type has to be both the predeclared type int and have a method M(). But predeclared types in Go do not have any methods. So there is no type satisfying C and its type set is empty. The compiler accepts it just fine, though. That is what this clause from the spec is about.\nThis decision might seem strange to you. After all, if a type set is empty, it would be very helpful to report that to the user. They obviously made a mistake - an empty type set can never be used as a constraint. A function using it could never be instantiated.\nI want to explain why that sentence is there and also go into a couple of related design decisions of the generics design. I’m trying to be expansive in my explanation, which means that you should not need any special knowledge to understand it. It also means, some of the information might be boring to you - feel free to skip the corresponding sections.\nThat sentence is in the Go spec because it turns out to be hard to determine if a type set is empty. Hard enough, that the Go team did not want to require an implementation to solve that. Let’s see why.\nP vs. NP When we talk about whether or not a problem is hard, we often group problems into two big classes:\n Problems which can be solved reasonably efficiently. This class is called P. Problems which can be verified reasonably efficiently. This class is called NP.  The first obvious follow up question is “what does ‘reasonably efficient’ mean?”. The answer to that is “there is an algorithm with a running time polynomial in its input size”1.\nThe second obvious follow up question is “what’s the difference between ‘solving’ and ‘verifying’?”.\nSolving a problem means what you think it means: Finding a solution. If I give you a number and ask you to solve the factorization problem, I’m asking you to find a (non-trivial) factor of that number.\nVerifying a problem means that I give you a solution and I’m asking you if the solution is correct. For the factorization problem, I’d give you two numbers and ask you to verify that the second is a factor of the first.\nThese two things are often very different in difficulty. If I ask you to give me a factor of 297863737, you probably know no better way than to sit down and try to divide it by a lot of numbers and see if it comes out evenly. But if I ask you to verify that 9883 is a factor of that number, you just have to do a bit of long division and it either divides it, or it does not.\nIt turns out, that every problem which is efficiently solvable is also efficiently verifiable. You can just calculate the solution and compare it to the given one. So every problem in P is also in NP2. But it is a famously open question whether the opposite is true - that is, we don’t really know, if there are problems which are hard to solve but easy to verify.\nThis is hard to know in general. Because us not having found an efficient algorithm to solve a problem does not mean there is none. But in practice we usually assume that there are some problems like that.\nOne fact that helps us talk about hard problems, is that there are some problems which are as hard as possible in NP. That means we were able to prove that if you can solve one of these problems you can use that to solve any other problem in NP. These problems are called “NP-complete”.\nThat is, to be frank, plain magic and explaining it is far beyond my capabilities. But it helps us to tell if a given problem is hard, by doing it the other way around. If solving problem X would enable us to solve one of these NP-complete problems then solving problem X is obviously itself NP-complete and therefore probably very hard. This is called a “proof by reduction”.\nOne example of such problem is boolean satisfiability. And it is used very often to prove a problem is hard.\nSAT Imagine I give you a boolean function. The function has a bunch of bool arguments and returns bool, by joining its arguments with logical operators into a single expression. For example:\nfunc F(x, y, z bool) bool { return ((!x \u0026\u0026 y) || z) \u0026\u0026 (x || !y) } If I give you values for these arguments, you can efficiently tell me if the formula evaluates to true or false. You just substitute them in and evaluate every operator. For example\nf(true, true, false) → ((!true \u0026\u0026 true) || false) \u0026\u0026 (true || !true) → ((false \u0026\u0026 true) || false) \u0026\u0026 (true || !true) → ((false \u0026\u0026 true) || false) \u0026\u0026 (true || false) → ((false \u0026\u0026 true) || false) \u0026\u0026 true → (false \u0026\u0026 true) || false → false \u0026\u0026 true → false This takes at most one step per operator in the expression. So it takes a linear number of steps in the length of the input, which is very efficient.\nBut if I only give you the function and ask you to find arguments which make it return true - or even to find out whether such arguments exist - you probably have to try out all possible input combinations to see if any of them does. That’s easy for three arguments. But for \\(n\\) arguments there are \\(2^n\\) possible assignments, so it takes exponential time in the number of arguments.\nThe problem of finding arguments that makes such a function return true (or proving that no such arguments exists) is called “boolean satisfiability” and it is NP-complete.\nIt is extremely important in what form the expression is given, though. Some forms make it pretty easy to solve, while others make it hard.\nFor example, every expression can be rewritten into what is called a “Disjunctive Normal Form” (DNF). It is called that because it consists of a series of conjunction (\u0026\u0026) terms, joined together by disjunction (||) operators3:\nfunc F_DNF(x, y, z bool) bool { return (x \u0026\u0026 z) || (!y \u0026\u0026 z) } (You can verify that this is the same function as above, by trying out all 8 input combinations)\nEach term has a subset of the arguments, possibly negated, joined by \u0026\u0026. The terms are then joined together using ||.\nSolving the satisfiability problem for an expression in DNF is easy:\n Go through the individual terms. || is true if and only if either of its operands is true. So for each term:  If it contains both an argument and its negation (x \u0026\u0026 !x) it can never be true. Continue to the next term. Otherwise, you can infer valid arguments from the term:  If it contains x, then we must pass true for x If it contains !x, then we must pass false for x If it contains neither, then what we pass for x does not matter and either value works.   The term then evaluates to true with these arguments, so the entire expression does.   If none of the terms can be made true, the function can never return true and there is no valid set of arguments.  On the other hand, there is also a “Conjunctive Normal Form” (CNF). Here, the expression is a series of disjunction (||) terms, joined together with conjunction (\u0026\u0026) operators:\nfunc F_CNF(x, y, z bool) bool { return (!x || z) \u0026\u0026 (y || z) \u0026\u0026 (x || !y) } (Again, you can verify that this is the same function)\nFor this, the idea of our algorithm does not work. To find a solution, you have to take all terms into account simultaneously. You can’t just tackle them one by one. In fact, solving satisfiability on CNF (often abbreviated as “CNFSAT”) is NP-complete4.\nIt turns out that every boolean function can be written as a single expression using only ||, \u0026\u0026 and !. In particular, every boolean function has a DNF and a CNF.\nVery often, when we want to prove a problem is hard, we do so by reducing CNFSAT to it. That’s what we will do for the problem of calculating type sets. But there is one more preamble we need.\nSets and Satisfiability There is an important relationship between sets and boolean functions.\nSay we have a type T and a Universe which contains all possible values of T. If we have a func(T) bool, we can create a set from that, by looking at all objects for which the function returns true:\nvar Universe Set[T] func MakeSet(f func(T) bool) Set[T] { s := make(Set[T]) for v := range Universe { if f(v) { s.Add(v) } } return s } This set contains exactly all elements for which f is true. So calculating f(v) is equivalent to checking s.Contains(v). And checking if s is empty is equivalent to checking if f can ever return true.\nWe can also go the other way around:\nfunc MakeFunc(s Set[T]) func(T) bool { return func(v T) bool { return s.Contains(v) } } So in a sense func(T) bool and Set[T] are “the same thing”. We can transform a question about one into a question about the other and back.\nAs we observed above it is important how a boolean function is given. To take that into account we have to also convert boolean operators into set operations:\n// Union(s, t) contains all elements which are in s *or* in t. func Union(s, t Set[T]) Set[T] { return MakeSet(func(v T) bool { return s.Contains(v) || t.Contains(v) }) } // Intersect(s, t) contains all elements which are in s *and* in t. func Intersect(s, t Set[T]) Set[T] { return MakeSet(func(v T) bool { return s.Contains(v) \u0026\u0026 t.Contains(v) }) } // Complement(s) contains all elements which are *not* in s. func Complement(s Set[T]) Set[T] { return MakeSet(func(v T) bool { return !s.Contains(v) }) } And back:\n// Or creates a function which returns if f or g is true. func Or(f, g func(T) bool) func(T) bool { return MakeFunc(Union(MakeSet(f), MakeSet(g))) } // And creates a function which returns if f and g are true. func And(f, g func(T) bool) func(T) bool { return MakeFunc(Intersect(MakeSet(f), MakeSet(g))) } // Not creates a function which returns if f is false func Not(f func(T) bool) func(T) bool { return MakeFunc(Complement(MakeSet(f))) } The takeaway from all of this is that constructing a set using Union, Intersect and Complement is really the same as writing a boolean function using ||, \u0026\u0026 and !.\nAnd proving that a set constructed in this way is empty is the same as proving that a corresponding boolean function is never true.\nAnd because checking that a boolean function is never true is NP-complete, so is checking if one of the sets constructed like this.\nWith this, let us look at the specific sets we are interested in.\nBasic interfaces as type sets Interfaces in Go are used to describe sets of types. For example, the interface\ntype S interface { X() Y() Z() } is “the set of all types which have a method X() and a method Y() and a method Z()”.\nWe can also express set intersection, using interface embedding:\ntype S interface { X() } type T interface { Y() } type U interface { S T } This expresses the intersection of S and T as an interface. Or we can view the property “has a method X()” as a boolean variable and think of this as the formula x \u0026\u0026 y.\nSurprisingly, there is also a limited form of negation. It happens implicitly, because a type can not have two different methods with the same name. Implicitly, if a type has a method X() it does not have a method X() int for example:\ntype X interface { X() } type NotX interface{ X() int } There is a small snag: A type can have neither a method X() nor have a method X() int. That’s why our negation operator is limited. Real boolean variables are always either true or false, whereas our negation also allows them to be neither. In mathematics we say that this logic language lacks the law of the excluded middle (also called “Tertium Non Datur” - “there is no third”). For this section, that does not matter. But we have to worry about it later.\nBecause we have intersection and negation, we can express interfaces which could never be satisfied by any type (i.e. which describe an empty type set):\ninterface{ X; NotX } The compiler rejects such interfaces. But how can it do that? Did we not say above that checking if a set is empty is NP-complete?\nThe reason this works is that we only have negation and conjunction (\u0026\u0026). So all the boolean expressions we can build with this language have the form\nx \u0026\u0026 y \u0026\u0026 !z These expressions are in DNF! We have a term, which contains a couple of variables - possibly negated - and joins them together using \u0026\u0026. We don’t have ||, so there is only a single term.\nSolving satisfiability in DNF is easy, as we said. So with the language as we have described it so far, we can only express type sets which are easy to check for emptiness.\nAdding unions Go 1.18 extends the interface syntax. For our purposes, the important addition is the | operator:\ntype S interface{ A | B } This represents the set of all types which are in the union of the type sets A and B - that is, it is the set of all types which are in A or in B (or both).\nThis means our language of expressible formulas now also includes a ||-operator - we have added set unions and set unions are equivalent to || in the language of formulas. What’s more, the form of our formula is now a conjunctive normal form - every line is a term of || and the lines are connected by \u0026\u0026:\ntype X interface { X() } type NotX interface{ X() int } type Y interface { Y() } type NotY interface{ Y() int } type Z interface { Z() } type NotZ interface{ Z() int } // (!x || z) \u0026\u0026 (y || z) \u0026\u0026 (x || !y) type S interface { NotX | Z Y | Z X | NotY } This is not quite enough to prove NP-completeness though, because of the snag above. If we want to prove that it is easy, it does not matter that a type can have neither method. But if we want to prove that it is hard, we really need an exact equivalence between boolean functions and type sets. So we need to guarantee that a type has one of our two contradictory methods.\n“Luckily”, the | operator gives us a way to fix that:\ntype TertiumNonDatur interface { X | NotX Y | NotY Z | NotZ } // (!x || z) \u0026\u0026 (y || z) \u0026\u0026 (x || !y) type S interface { TertiumNonDatur NotX | Z Y | Z X | NotY } Now any type which could possibly implement S must have either an X() or an X() int method, because it must implement TertiumNonDatur as well. So this extra interface helps us to get the law of the excluded middle into our language of type sets.\nWith this, checking if a type set is empty is in general as hard as checking if an arbitrary boolean formula in CNF has no solution. As described above, that is NP-complete.\nEven worse, we want to define which operations are allowed on a type parameter by saying that it is allowed if every type in a type set supports it. However, that check is also NP-complete.\nThe easy way to prove that is to observe that if a type set is empty, every operator should be allowed on a type parameter constrained by it. Because any statement about “every element of the empty set“ is true5.\nBut this would mean that type-checking a generic function would be NP-complete. If an operator is used, we have to at least check if the type set of its constraint is empty. Which is NP-complete.\nWhy do we care? A fair question is “why do we even care? Surely these cases are super exotic. In any real program, checking this is trivial”.\nThat’s true, but there are still reasons to care:\n  Go has the goal of having a fast compiler. And importantly, one which is guaranteed to be fast for any program. If I give you a Go program, you can be reasonably sure that it compiles quickly, in a time frame predictable by the size of the input.\nIf I can craft a program which compiles slowly - and may take longer than the lifetime of the universe - this is no longer true.\nThis is especially important for environments like the Go playground, which regularly compiles untrusted code.\n  NP complete problems are notoriously hard to debug if they fail.\nIf you use Linux, you might have occasionally run into a problem where you accidentally tried installing conflicting versions of some package. And if so, you might have noticed that your computer first chugged along for a while and then gave you an unhelpful error message about the conflict. And maybe you had trouble figuring out which packages declared the conflicting dependencies.\nThis is typical for NP complete problems. As an exact solution is often too hard to compute, they rely on heuristics and randomization and it’s hard to work backwards from a failure.\n  We generally don’t want the correctness of a Go program to depend on the compiler used. That is, a program should not suddenly stop compiling because you used a different compiler or the compiler was updated to a new Go version.\nBut NP-complete problems don’t allow us to calculate an exact solution. They always need some heuristic (even if it is just “give up after a bit”). If we don’t want the correctness of a program to be implementation defined, that heuristic must become part of the Go language specification. But these heuristics are very complex to describe. So we would have to spend a lot of room in the spec for something which does not give us a very large benefit.\n  Note that Go also decided to restrict the version constraints a go.mod file can express, for exactly the same reasons. Go has a clear priority, not to require too complicated algorithms in its compilers and tooling. Not because they are hard to implement, but because the behavior of complicated algorithms also tends to be hard to understand for humans.\nSo requiring to solve an NP-complete problem is out of the question.\nThe fix Given that there must not be an NP-complete problem in the language specification and given that Go 1.18 was released, this problem must have somehow been solved.\nWhat changed is that the language for describing interfaces was limited from what I described above. Specifically\n Implementation restriction: A union (with more than one term) cannot contain the predeclared identifier comparable or interfaces that specify methods, or embed comparable or interfaces that specify methods.\n This disallows the main mechanism we used to map formulas to interfaces above. We can no longer express our TertiumNonDatur type, or the individual | terms of the formula, as the respective terms specify methods. Without specifying methods, we can’t get our “implicit negation” to work either.\nThe hope is that this change (among a couple of others) is sufficient to ensure that we can always calculate type sets accurately. Which means I pulled a bit of a bait-and-switch: I said that calculating type sets is hard. But as they were actually released, they might not be.\nThe reason I wrote this blog post anyways is to explain the kind of problems that exist in this area. It is easy to say we have solved this problem once and for all.\nBut to be certain, someone should prove this - either by writing a proof that the problem is still hard or by writing an algorithm which solves it efficiently.\nThere are also still discussions about changing the generics design. As one example, the limitations we introduced to fix all of this made one of the use cases from the design doc impossible to express. We might want to tweak the design to allow this use case. We have to look out in these discussions, so we don’t re-introduce NP-completeness. It took us some time to even detect it when the union operator was proposed.\nAnd there are other kinds of “implicit negations” in the Go language. For example, a struct can not have both a field and a method with the same name. Or being one type implies not being another type (so interface{int} implicitly negates interface{string}).\nAll of which is to say that even if the problem might no longer be NP-complete - I hope that I convinced you it is still more complicated than you might have thought.\nIf you want to discuss this further, you can find links to my social media on the bottom of this site.\n I want to thank my beta-readers for helping me improve this article. Namely arnehormann, @johanbrandhorst, @mvdan_, @_myitcv, @readcodesing, @rogpeppe and @zekjur.\nThey took a frankly unreasonable chunk of time out of their day. And their suggestions were invaluable.\n  It should be pointed out, though, that “polynomial” can still be extremely inefficient. \\(n^{1000}\\) still grows extremely fast, but is polynomial. And for many practical problems, even \\(n^3\\) is intolerably slow. But for complicated reasons, there is a qualitatively important difference between “polynomial” and “exponential”6 run time. So you just have to trust me that the distinction makes sense. ↩︎\n These names might seem strange, by the way. P is easy to explain: It stands for “polynomial”.\nNP doesn’t mean “not polynomial” though. It means “non-deterministic polynomial”. A non-deterministic computer, in this context, is a hypothetical machine which can run arbitrarily many computations simultaneously. A program which can be verified efficiently by any computer can be solved efficiently by a non-deterministic one. It just tries out all possible solutions at the same time and returns a correct one.\nThus, being able to verify a problem on a normal computer means being able to solve it on a non-deterministic one. That is why the two definitions of NP “verifiable by a classical computer” and “solvable by a non-deterministic computer” mean the same thing. ↩︎\n You might complain that it is hard to remember if the “disjunctive normal form” is a disjunction of conjunctions, or a conjunction of disjunctions - and that no one can remember which of these means \u0026\u0026 and which means || anyways.\nYou would be correct. ↩︎\n You might wonder why we can’t just solve CNFSAT by transforming the formula into DNF and solving that.\nThe answer is that the transformation can make the formula exponentially larger. So even though solving the problem on DNF is linear in the size the DNF formula, that size is exponential in the size of the CNF formula. So we still use exponential time in the size of the CNF formula. ↩︎\n This is called the principle of explosion or “ex falso quodlibet” (“from falsehoold follows anything”).\nMany people - including many first year math students - have anxieties and confusion around this principle and feel that it makes no sense. So I have little hope that I can make it palatable to you. But it is extremely important for mathematics to “work” and it really is the most reasonable way to set things up.\nSorry. ↩︎\n Yes, I know that there are complexity classes between polynomial and exponential. Allow me the simplification. ↩︎\n   ","wordCount":"4098","inLanguage":"en","datePublished":"2022-05-16T09:33:10Z","dateModified":"2022-05-16T09:33:10Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Calculating type sets is harder than you think</h1><div class=post-meta><span title="2022-05-16 09:33:10 +0000 UTC">May 16, 2022</span></div></header><div class=post-content><script defer crossorigin=anonymous src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><p>Go 1.18 added the biggest and probably one of the most requested features of
all time to the language: <a href=https://go.dev/doc/go1.18#generics>Generics</a>. If
you want a comprehensive introduction to the topic, there are many out there
and I would personally <a href="https://www.youtube.com/watch?v=QP6v-Q5Foek">recommend this talk I gave at the Frankfurt Gopher
Meetup</a>.</p><p>This blog post is not an introduction to generics, though. It is about <a href=https://go.dev/ref/spec#Operands>this
sentence from the spec</a>:</p><blockquote><p>Implementation restriction: A compiler need not report an error if an
operand&rsquo;s type is a type parameter with an empty type set.</p></blockquote><p>As an example, consider this interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>C</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nf>M</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This constraint can never be satisfied. It says that a type has to be <em>both</em>
the predeclared type <code>int</code> <em>and</em> have a method <code>M()</code>. But predeclared
types in Go do not have any methods. So there is no type satisfying <code>C</code> and its
type set is empty.
<a href=https://go.dev/play/p/36pFPhJKGxl>The compiler accepts it just fine</a>, though.
That is what this clause from the spec is about.</p><p>This decision might seem strange to you. After all, if a type set is empty,
it would be very helpful to report that to the user. They obviously made a
mistake - an empty type set can never be used as a constraint. A function using
it could never be instantiated.</p><p>I want to explain why that sentence is there and also go into a couple of
related design decisions of the generics design. I&rsquo;m trying to be expansive in
my explanation, which means that you should not need any special knowledge to
understand it. It also means, some of the information might be boring to you -
feel free to skip the corresponding sections.</p><p>That sentence is in the Go spec because it turns out to be hard to determine if
a type set is empty. Hard enough, that the Go team did not want to require an
implementation to solve that. Let&rsquo;s see why.</p><h2 id=p-vs-np>P vs. NP<a hidden class=anchor aria-hidden=true href=#p-vs-np>#</a></h2><p>When we talk about whether or not a problem is hard, we often group problems
into two big classes:</p><ol><li>Problems which can be <em>solved</em> reasonably efficiently. This class is called
P.</li><li>Problems which can be <em>verified</em> reasonably efficiently. This class is called
NP.</li></ol><p>The first obvious follow up question is “what does ‘reasonably efficient’
mean?”. The answer to that is “there is an algorithm with a running time
polynomial in its input size”<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>The second obvious follow up question is “what&rsquo;s the difference between
‘solving’ and ‘verifying’?”.</p><p><em>Solving</em> a problem means what you think it means: Finding a solution. If I
give you a number and ask you to solve the factorization problem, I&rsquo;m asking
you to find a (non-trivial) factor of that number.</p><p><em>Verifying</em> a problem means that I give you a solution and I&rsquo;m asking you if the
solution is correct. For the factorization problem, I&rsquo;d give you two numbers
and ask you to verify that the second is a factor of the first.</p><p>These two things are often very different in difficulty. If I ask you to give
me a factor of 297863737, you probably know no better way than to sit down and
try to divide it by a lot of numbers and see if it comes out evenly. But if I
ask you to verify that 9883 is a factor of that number, you just have to do a
bit of long division and it either divides it, or it does not.</p><p>It turns out, that every problem which is efficiently <em>solvable</em> is also
efficiently <em>verifiable</em>. You can just calculate the solution and compare it to
the given one. So every problem in P is also in NP<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. But it is
<a href=https://en.wikipedia.org/wiki/P_versus_NP_problem>a famously open question</a>
whether the opposite is true - that is, we don&rsquo;t really <em>know</em>, if there are
problems which are hard to solve but easy to verify.</p><p>This is hard to know in general. Because us not having <em>found</em> an efficient
algorithm to solve a problem does not mean <em>there is none</em>. But in practice we
usually assume that there are some problems like that.</p><p>One fact that helps us talk about hard problems, is that there are some
problems which are <em>as hard as possible</em> in NP. That means we were able to
prove that if you can solve one of these problems you can use that to solve
<em>any other problem in NP</em>. These problems are called “NP-complete”.</p><p>That is, to be frank, plain magic and explaining it is far beyond my
capabilities. But it helps us to tell if a given problem is hard, by doing it
the other way around. If solving problem X would enable us to solve one of
these NP-complete problems then solving problem X is obviously itself NP-complete
and therefore <em>probably very hard</em>. This is called a “proof by reduction”.</p><p>One example of such problem is boolean satisfiability. And it is used very
often to prove a problem is hard.</p><h2 id=sat>SAT<a hidden class=anchor aria-hidden=true href=#sat>#</a></h2><p>Imagine I give you a boolean function. The function has a bunch of <code>bool</code>
arguments and returns <code>bool</code>, by joining its arguments with logical operators
into a single expression. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>F</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((!</span><span class=nx>x</span> <span class=o>&amp;&amp;</span> <span class=nx>y</span><span class=p>)</span> <span class=o>||</span> <span class=nx>z</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>x</span> <span class=o>||</span> <span class=p>!</span><span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If I give you values for these arguments, you can efficiently tell me if the
formula evaluates to <code>true</code> or <code>false</code>. You just substitute them in and
evaluate every operator. For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>f</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span> <span class=p>((!</span><span class=kc>true</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=kc>true</span> <span class=o>||</span> <span class=p>!</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span> <span class=p>((</span><span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=kc>true</span> <span class=o>||</span> <span class=p>!</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span> <span class=p>((</span><span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=kc>true</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span> <span class=p>((</span><span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span> <span class=o>||</span> <span class=kc>false</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span>  <span class=p>(</span><span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span><span class=p>)</span> <span class=o>||</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span>   <span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=err>→</span>   <span class=kc>false</span>
</span></span></code></pre></div><p>This takes at most one step per operator in the expression. So it takes a
<em>linear</em> number of steps in the length of the input, which is very efficient.</p><p>But if I <em>only</em> give you the function and ask you to <em>find</em> arguments which
make it return <code>true</code> - or even to find out whether such arguments exist - you
probably have to try out all possible input combinations to see if any of them
does. That&rsquo;s easy for three arguments. But for \(n\) arguments there are
\(2^n\) possible assignments, so it takes <em>exponential</em> time in the number of
arguments.</p><p>The problem of finding arguments that makes such a function return <code>true</code> (or
proving that no such arguments exists) is called &ldquo;boolean satisfiability&rdquo; and
it is NP-complete.</p><p>It is extremely important <em>in what form</em> the expression is given, though. Some
forms make it pretty easy to solve, while others make it hard.</p><p>For example, every expression can be rewritten into what is called a
<a href=https://en.wikipedia.org/wiki/Disjunctive_normal_form>“Disjunctive Normal Form” (DNF)</a>.
It is called that because it consists of a series of <em>conjunction</em> (<code>&&</code>)
terms, joined together by <em>disjunction</em> (<code>||</code>) operators<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>F_DNF</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=nx>x</span> <span class=o>&amp;&amp;</span> <span class=nx>z</span><span class=p>)</span> <span class=o>||</span> <span class=p>(!</span><span class=nx>y</span> <span class=o>&amp;&amp;</span> <span class=nx>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>(You can verify that this is the same function as above, by
<a href=https://go.dev/play/p/dCtSs3tf91F>trying out all 8 input combinations</a>)</p><p>Each term has a subset of the arguments, possibly negated, joined by
<code>&&</code>. The terms are then joined together using <code>||</code>.</p><p>Solving the satisfiability problem for an expression in DNF is easy:</p><ol><li>Go through the individual terms. <code>||</code> is <code>true</code> if and only if
either of its operands is <code>true</code>. So for each term:<ul><li>If it contains both an argument and its negation (<code>x && !x</code>) it can never
be <code>true</code>. Continue to the next term.</li><li>Otherwise, you can infer valid arguments from the term:<ul><li>If it contains <code>x</code>, then we must pass <code>true</code> for <code>x</code></li><li>If it contains <code>!x</code>, then we must pass <code>false</code> for <code>x</code></li><li>If it contains neither, then what we pass for <code>x</code> does not matter and
either value works.</li></ul></li><li>The term then evaluates to <code>true</code> with these arguments, so the entire
expression does.</li></ul></li><li>If none of the terms can be made <code>true</code>, the function can never return
<code>true</code> and there is no valid set of arguments.</li></ol><p>On the other hand, there is also a <a href=https://en.wikipedia.org/wiki/Conjunctive_normal_form>“Conjunctive Normal Form”
(CNF)</a>. Here, the
expression is a series of <em>disjunction</em> (<code>||</code>) terms, joined together with
<em>conjunction</em> (<code>&&</code>) operators:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>F_CNF</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(!</span><span class=nx>x</span> <span class=o>||</span> <span class=nx>z</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>y</span> <span class=o>||</span> <span class=nx>z</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>x</span> <span class=o>||</span> <span class=p>!</span><span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>(Again, you can <a href=https://go.dev/play/p/0xldLVGqu7m>verify that this is the same function</a>)</p><p>For this, the idea of our algorithm does not work. To find a solution, you have
to take <em>all terms</em> into account simultaneously. You can&rsquo;t just tackle them one
by one. In fact, solving satisfiability on CNF (often abbreviated as “CNFSAT”)
is NP-complete<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p><a href=https://en.wikipedia.org/wiki/Functional_completeness>It turns out</a> that
<em>every</em> boolean function can be written as a single expression using only <code>||</code>, <code>&&</code> and <code>!</code>. In particular, every boolean function has a DNF and a CNF.</p><p>Very often, when we want to prove a problem is hard, we do so by reducing
CNFSAT to it. That&rsquo;s what we will do for the problem of calculating type sets.
But there is one more preamble we need.</p><h2 id=sets-and-satisfiability>Sets and Satisfiability<a hidden class=anchor aria-hidden=true href=#sets-and-satisfiability>#</a></h2><p>There is an important relationship between
<a href=https://en.wikipedia.org/wiki/Set_(mathematics)>sets</a> and boolean functions.</p><p>Say we have a type <code>T</code> and a <code>Universe</code> which contains all possible values of
<code>T</code>. If we have a <code>func(T) bool</code>, we can create a set from that, by looking at
all objects for which the function returns <code>true</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>Universe</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>Universe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nf>f</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>s</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This set contains exactly all elements for which <code>f</code> is <code>true</code>. So calculating
<code>f(v)</code> is equivalent to checking <code>s.Contains(v)</code>. And checking if <code>s</code> is empty
is equivalent to checking if <code>f</code> can ever return <code>true</code>.</p><p>We can also go the other way around:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MakeFunc</span><span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So in a sense <code>func(T) bool</code> and <code>Set[T]</code> are “the same thing”. We can
transform a question about one into a question about the other and back.</p><p>As we observed above it is important <em>how</em> a boolean function is given.
To take that into account we have to also convert boolean operators into set
operations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Union(s, t) contains all elements which are in s *or* in t.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Union</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>t</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=o>||</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Intersect(s, t) contains all elements which are in s *and* in t.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Intersect</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>t</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Complement(s) contains all elements which are *not* in s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Complement</span><span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>!</span><span class=nx>s</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And back:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Or creates a function which returns if f or g is true.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Or</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>g</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeFunc</span><span class=p>(</span><span class=nf>Union</span><span class=p>(</span><span class=nf>MakeSet</span><span class=p>(</span><span class=nx>f</span><span class=p>),</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=nx>g</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// And creates a function which returns if f and g are true.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>And</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>g</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeFunc</span><span class=p>(</span><span class=nf>Intersect</span><span class=p>(</span><span class=nf>MakeSet</span><span class=p>(</span><span class=nx>f</span><span class=p>),</span> <span class=nf>MakeSet</span><span class=p>(</span><span class=nx>g</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Not creates a function which returns if f is false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Not</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>MakeFunc</span><span class=p>(</span><span class=nf>Complement</span><span class=p>(</span><span class=nf>MakeSet</span><span class=p>(</span><span class=nx>f</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The takeaway from all of this is that constructing a set using <code>Union</code>,
<code>Intersect</code> and <code>Complement</code> is really the same as writing a boolean function
using <code>||</code>, <code>&&</code> and <code>!</code>.</p><p>And proving that a set constructed in this way is empty is the same as proving
that a corresponding boolean function is never <code>true</code>.</p><p>And because checking that a boolean function is never <code>true</code> is NP-complete, so
is checking if one of the sets constructed like this.</p><p>With this, let us look at the specific sets we are interested in.</p><h2 id=basic-interfaces-as-type-sets>Basic interfaces as type sets<a hidden class=anchor aria-hidden=true href=#basic-interfaces-as-type-sets>#</a></h2><p>Interfaces in Go are used to describe sets of types. For example, the interface</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>S</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>X</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nf>Y</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nf>Z</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>is “the set of all types which have a method <code>X()</code> and a method <code>Y()</code> and a
method <code>Z()</code>”.</p><p>We can also express set intersection, using <a href=https://go.dev/ref/spec#Embedded_interfaces>interface embedding</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>S</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>X</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>Y</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>U</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>S</span>
</span></span><span class=line><span class=cl>    <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This expresses the intersection of <code>S</code> and <code>T</code> as an interface. Or we can view
the property “has a method <code>X()</code>” as a boolean variable and think of this as
the formula <code>x && y</code>.</p><p>Surprisingly, there is also a limited form of negation. It happens implicitly,
because a type can not have two different methods with the same name.
Implicitly, if a type has a method <code>X()</code> it does <em>not</em> have a method <code>X() int</code> for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>X</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>X</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NotX</span> <span class=kd>interface</span><span class=p>{</span> <span class=nf>X</span><span class=p>()</span> <span class=kt>int</span> <span class=p>}</span>
</span></span></code></pre></div><p>There is a small snag: A type can have <em>neither</em> a method <code>X()</code> <em>nor</em> have a
method <code>X() int</code>. That&rsquo;s why our negation operator is limited. Real boolean
variables are always <em>either</em> <code>true</code> <em>or</em> <code>false</code>, whereas our negation also
allows them to be neither. In mathematics we say that this logic language lacks
<a href=https://en.wikipedia.org/wiki/Law_of_excluded_middle>the law of the excluded middle</a>
(also called “Tertium Non Datur” - “there is no third”). For this section, that does not matter. But we have to worry about it later.</p><p>Because we have intersection and negation, we can express interfaces which
could never be satisfied by any type (i.e. which describe an empty type set):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>interface</span><span class=p>{</span> <span class=nx>X</span><span class=p>;</span> <span class=nx>NotX</span> <span class=p>}</span>
</span></span></code></pre></div><p><a href=https://go.dev/play/p/r4kpXNynscX>The compiler rejects such interfaces</a>. But
how can it do that? Did we not say above that checking if a set is empty is
NP-complete?</p><p>The reason this works is that we only have negation and conjunction (<code>&&</code>). So
all the boolean expressions we can build with this language have the form</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>&amp;&amp;</span> <span class=nx>y</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>z</span>
</span></span></code></pre></div><p>These expressions are in DNF! We have a term, which contains a couple of
variables - possibly negated - and joins them together using <code>&&</code>. We don&rsquo;t
have <code>||</code>, so there is only a single term.</p><p>Solving satisfiability in DNF is easy, as we said. So with the language as we
have described it so far, we can only express type sets which are easy to check
for emptiness.</p><h2 id=adding-unions>Adding unions<a hidden class=anchor aria-hidden=true href=#adding-unions>#</a></h2><p>Go 1.18 extends the interface syntax. For our purposes, the important addition
is the <code>|</code> operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>S</span> <span class=kd>interface</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>A</span> <span class=p>|</span> <span class=nx>B</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This represents the set of all types which are in the <em>union</em> of the type sets
<code>A</code> and <code>B</code> - that is, it is the set of all types which are in <code>A</code> <em>or</em> in <code>B</code>
(or both).</p><p>This means our language of expressible formulas now also includes a
<code>||</code>-operator - we have added set unions and set unions are equivalent to
<code>||</code> in the language of formulas. What&rsquo;s more, the form of our formula is now a
<em>conjunctive</em> normal form - every line is a term of <code>||</code> and the lines are
connected by <code>&&</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>X</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>X</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NotX</span> <span class=kd>interface</span><span class=p>{</span> <span class=nf>X</span><span class=p>()</span> <span class=kt>int</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Y</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>Y</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NotY</span> <span class=kd>interface</span><span class=p>{</span> <span class=nf>Y</span><span class=p>()</span> <span class=kt>int</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Z</span> <span class=kd>interface</span> <span class=p>{</span> <span class=nf>Z</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NotZ</span> <span class=kd>interface</span><span class=p>{</span> <span class=nf>Z</span><span class=p>()</span> <span class=kt>int</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>S</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>NotX</span> <span class=p>|</span> <span class=nx>Z</span>
</span></span><span class=line><span class=cl>    <span class=nx>Y</span> <span class=p>|</span> <span class=nx>Z</span>
</span></span><span class=line><span class=cl>    <span class=nx>X</span> <span class=p>|</span> <span class=nx>NotY</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is not <em>quite</em> enough to prove NP-completeness though, because of the snag
above. If we want to prove that it is easy, it does not matter that a type can
have neither method. But if we want to prove that it is hard, we really need an
<em>exact</em> equivalence between boolean functions and type sets. So we need to
guarantee that a type has one of our two contradictory methods.</p><p>“Luckily”, the <code>|</code> operator gives us a way to fix that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TertiumNonDatur</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>X</span> <span class=p>|</span> <span class=nx>NotX</span>
</span></span><span class=line><span class=cl>    <span class=nx>Y</span> <span class=p>|</span> <span class=nx>NotY</span>
</span></span><span class=line><span class=cl>    <span class=nx>Z</span> <span class=p>|</span> <span class=nx>NotZ</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>S</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>TertiumNonDatur</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>NotX</span> <span class=p>|</span> <span class=nx>Z</span>
</span></span><span class=line><span class=cl>    <span class=nx>Y</span> <span class=p>|</span> <span class=nx>Z</span>
</span></span><span class=line><span class=cl>    <span class=nx>X</span> <span class=p>|</span> <span class=nx>NotY</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now any type which could possibly implement <code>S</code> <em>must</em> have either an <code>X()</code> or
an <code>X() int</code> method, because it must implement <code>TertiumNonDatur</code> as well. So
this extra interface helps us to get the law of the excluded middle into our
language of type sets.</p><p>With this, checking if a type set is empty is in general as hard as checking if
an arbitrary boolean formula in CNF has no solution. As described above, that
is NP-complete.</p><p>Even worse, we want to define which operations are allowed on a type parameter
by saying that it is allowed if every type in a type set supports it. However,
<a href=https://github.com/golang/go/issues/45346#issuecomment-822330394>that check is also NP-complete</a>.</p><p>The easy way to prove that is to observe that if a type set is empty, <em>every
operator</em> should be allowed on a type parameter constrained by it. Because any
statement about “every element of the empty set“ is true<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><p>But this would mean that type-checking a generic function would be NP-complete.
If an operator is used, we have to at least check if the type set of its
constraint is empty. Which is NP-complete.</p><h2 id=why-do-we-care>Why do we care?<a hidden class=anchor aria-hidden=true href=#why-do-we-care>#</a></h2><p>A fair question is “why do we even care? Surely these cases are super exotic.
In any real program, checking this is trivial”.</p><p>That&rsquo;s true, but there are still reasons to care:</p><ul><li><p>Go has the goal of having a fast compiler. And importantly, one which is
guaranteed to be fast <em>for any program</em>. If I give you a Go program, you can
be reasonably sure that it compiles quickly, in a time frame predictable by
the size of the input.</p><p>If I <em>can</em> craft a program which compiles slowly - and may take longer than
the lifetime of the universe - this is no longer true.</p><p>This is especially important for environments like the Go playground, which
regularly compiles untrusted code.</p></li><li><p>NP complete problems are notoriously hard to debug if they fail.</p><p>If you use Linux, you might have occasionally run into a problem where you
accidentally tried installing conflicting versions of some package. And if
so, you might have noticed that your computer first chugged along for a while
and then gave you an unhelpful error message about the conflict. And maybe
you had trouble figuring out which packages declared the conflicting
dependencies.</p><p>This is typical for NP complete problems. As an exact solution is often too
hard to compute, they rely on heuristics and randomization and it&rsquo;s hard to
work backwards from a failure.</p></li><li><p>We generally don&rsquo;t want the correctness of a Go program to depend on the
compiler used. That is, a program should not suddenly stop compiling because
you used a different compiler or the compiler was updated to a new Go
version.</p><p>But NP-complete problems don&rsquo;t allow us to calculate an exact solution. They
always need some heuristic (even if it is just “give up after a bit”). If we
don&rsquo;t want the correctness of a program to be implementation defined, that
heuristic must become part of the Go language specification. But these
heuristics are very complex to describe. So we would have to spend a lot of
room in the spec for something which does not give us a very large benefit.</p></li></ul><p>Note that Go also decided to restrict the version constraints a <code>go.mod</code> file
can express, <a href=https://research.swtch.com/version-sat>for exactly the same reasons</a>.
Go has a clear priority, not to require too complicated algorithms in its
compilers and tooling. Not because they are hard to implement, but because the
behavior of complicated algorithms also tends to be hard to understand for
humans.</p><p>So requiring to solve an NP-complete problem is out of the question.</p><h2 id=the-fix>The fix<a hidden class=anchor aria-hidden=true href=#the-fix>#</a></h2><p>Given that there must not be an NP-complete problem in the language
specification and given that Go 1.18 was released, this problem must have
somehow been solved.</p><p>What changed is that the language for describing interfaces was limited from
what I described above. <a href=https://go.dev/ref/spec#General_interfaces>Specifically</a></p><blockquote><p>Implementation restriction: A union (with more than one term) cannot contain
the predeclared identifier <code>comparable</code> or interfaces that specify methods, or
embed <code>comparable</code> or interfaces that specify methods.</p></blockquote><p>This disallows the main mechanism we used to map formulas to interfaces above.
We can no longer express our <code>TertiumNonDatur</code> type, or the individual <code>|</code>
terms of the formula, as the respective terms specify methods. Without
specifying methods, we can&rsquo;t get our “implicit negation” to work either.</p><p>The hope is that this change (among a couple of others) is sufficient to ensure
that we can always calculate type sets accurately. Which means I pulled a bit
of a bait-and-switch: I said that calculating type sets is hard. But as they
were actually released, they <em>might not be</em>.</p><p>The reason I wrote this blog post anyways is to explain the <em>kind of problems</em>
that exist in this area. It is easy to say we have solved this problem
<a href="https://www.youtube.com/watch?v=0SYpUSjSgFg">once and for all</a>.</p><p>But to be certain, someone should <em>prove</em> this - either by writing a proof that
the problem is still hard or by writing an algorithm which solves it
efficiently.</p><p>There are also still discussions about changing the generics design. As one
example, the limitations we introduced to fix all of this made
<a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#interface-types-in-union-elements>one of the use cases from the design doc</a>
impossible to express. We might want to tweak the design to allow this use
case. We have to look out in these discussions, so we don&rsquo;t
re-introduce NP-completeness. It took us some time to even detect it
<a href=https://github.com/golang/go/issues/45346>when the union operator was proposed</a>.</p><p>And there are other kinds of “implicit negations” in the Go language. For
example, a <code>struct</code> can not have both a field <em>and</em> a method with the same
name. Or being one type implies not being another type (so <code>interface{int}</code>
implicitly negates <code>interface{string}</code>).</p><p>All of which is to say that even if the problem might no longer be
NP-complete - I hope that I convinced you it is still more complicated than you
might have thought.</p><p>If you want to discuss this further, you can find links to my social media on
the bottom of this site.</p><hr><p>I want to thank my beta-readers for helping me improve this article.
Namely
<a href=https://github.com/arnehormann>arnehormann</a>,
<a href=https://twitter.com/johanbrandhorst>@johanbrandhorst</a>,
<a href=https://twitter.com/mvdan_>@mvdan_</a>,
<a href=https://twitter.com/_myitcv>@_myitcv</a>,
<a href=https://mobile.twitter.com/readcodesing>@readcodesing</a>,
<a href=https://twitter.com/rogpeppe>@rogpeppe</a> and
<a href=https://twitter.com/zekjur>@zekjur</a>.</p><p>They took a frankly unreasonable chunk of time out of their day. And their
suggestions were invaluable.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>It should be pointed out, though, that “polynomial” can still be
extremely inefficient. \(n^{1000}\) still grows extremely fast, but is
polynomial. And for many practical problems, even \(n^3\) is
intolerably slow. But for complicated reasons, there is a qualitatively
important difference between “polynomial” and “exponential”<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> run time. So
you just have to trust me that the distinction makes sense.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>These names might seem strange, by the way. P is easy to explain: It
stands for “polynomial”.</p><p>NP doesn&rsquo;t mean “not polynomial” though. It means “non-deterministic
polynomial”. A non-deterministic computer, in this context, is a
hypothetical machine which can run arbitrarily many computations
simultaneously. A program which can be <em>verified</em> efficiently by any
computer can be <em>solved</em> efficiently by a non-deterministic one. It just
tries out all possible solutions at the same time and returns a correct
one.</p><p>Thus, being able to verify a problem on a normal computer means being
able to solve it on a non-deterministic one. That is why the two
definitions of NP “verifiable by a classical computer” and “solvable by a
non-deterministic computer” mean the same thing.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>You might complain that it is hard to remember if the “disjunctive normal
form” is a disjunction of conjunctions, or a conjunction of disjunctions -
and that no one can remember which of these means <code>&&</code> and which means <code>||</code>
anyways.</p><p>You would be correct.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>You might wonder why we can&rsquo;t just solve CNFSAT by transforming the formula
into DNF and solving that.</p><p>The answer is that the transformation can make the formula exponentially
larger. So even though solving the problem on DNF is linear in the size the
DNF formula, that size is <em>exponential</em> in the size of the CNF formula. So
we still use exponential time in the size of the CNF formula.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>This is called <a href=https://en.wikipedia.org/wiki/Principle_of_explosion>the principle of explosion</a>
or “ex falso quodlibet” (“from falsehoold follows anything”).</p><p>Many people - including many first year math students - have anxieties and
confusion around this principle and feel that it makes no sense. So I have
little hope that I can make it palatable to you. But it is extremely
important for mathematics to “work” and it really <em>is</em> the most reasonable
way to set things up.</p><p>Sorry.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Yes, I know that there are complexity classes between polynomial and
exponential. Allow me the simplification.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=Bookwyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>