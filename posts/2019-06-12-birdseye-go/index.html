<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A bird's eye view of Go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2019-06-12-birdseye-go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="A bird's eye view of Go"><meta property="og:description" content="I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2019-06-12-birdseye-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-12T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A bird's eye view of Go"><meta name=twitter:description content="I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"A bird's eye view of Go","item":"https://blog.merovius.de/posts/2019-06-12-birdseye-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A bird's eye view of Go","name":"A bird\u0027s eye view of Go","description":"I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose.","keywords":["golang","programming"],"articleBody":"tl;dr: I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose. See the bottom-most section for that.\nWhen we talk about “Go”, depending on context, we can mean very different things. This is my attempt at providing a very high-level overview of the language and ecosystem and to link to the relevant documentation about how each part fits together (it’s also a bit of a hodgepodge though, addressing individual random questions I encountered recently). So, let’s dive in:\nThe Go programming language The bottom turtle is Go, the programming language. It defines the format and meaning of source code and the authoritative source is the Go language specification. If something doesn’t conform to the spec, it’s not “Go”. And conversely, if something isn’t mentioned in the spec it’s not part of the language. The language spec is maintained by the Go team and versioned, with a new release roughly every six months. At the time I wrote this post, the newest release was version 1.12.\nThe domain of the spec are:\n The grammar of the language Types, values and their semantics What identifiers are predeclared and what their meaning is How Go programs get executed The special package unsafe (though not all of its semantics)  The spec alone should enable you to write a compiler for Go. And indeed, there are many different compilers.\nA Go compiler and runtime The language spec is a text document, which is not useful in and of itself. For that you need software that actually implements these semantics. This is done by a compiler (which analyzes and checks the source code and transforms it into an executable format) and a runtime (which provides the necessary environment to actually run the code). There are many such combinations and they all differ a bit more or a bit less. Examples are:\n gc, a compiler and runtime written in pure Go (with some assembly) by the Go team themselves and versioned and released together with the language. Unlike other such tools, gc doesn’t strictly separate the compiler, assembler and linker - they end up sharing a lot of code and some of the classical responsibilities move or are shared between them. As such, it’s in general not possible to e.g. link packages compiled by different versions of gc. gccgo and libgo, a frontend for gcc and a runtime. It’s written in C and maintained by the Go team. It lives in the gcc organization though and is released according to the gcc release schedule and thus often lags a bit behind the “latest” version of the Go spec. llgo, a frontend for LLVM. I don’t know much else about it. gopherjs, compiling Go code into javascript and using a javascript VM plus some custom code as a runtime. Long-term, it’ll probably be made obsolete by gc gaining native support for WebAssembly. tinygo, an incomplete implementation targeting small code size. Runs on either bare-metal micro-controllers or WebAssembly VMs, with a custom runtime. Due to its limitations it doesn’t technically implement Go - notably, it doesn’t include a garbage collector, concurrency or reflection.  There are more, but this gives you an overview over the variety of implementations. Each of these made potentially different choices for how to implement the language and have their own idiosyncrasies. Examples (some of them a bit exotic, to illustrate) where they might differ are:\n Size of int/uint - the language allows them to be either 32 or 64 bit wide. How fundamental functionalities of the runtime, like allocation, garbage collection or concurrency are implemented. The order of ranging over a map isn’t defined in the language - gc famously explicitly randomizes it, gopherjs uses (last time I checked) whatever the javascript implementation you are running on uses. How much extra space append allocates if it needs to - not however, when it allocates extra space. How conversions between unsafe.Pointer and uintptr happen. gc, in particular, comes with its own set of rules regarding when these conversions are valid and when they aren’t. In general, the unsafe package is virtual and implemented in the compiler.  In general, relying on details not mentioned in the spec (in particular the ones mentioned here) makes your program compile with different compilers, but not work as expected. So you should avoid it if possible.\nIf you install Go via a “normal” way (by downloading it from the website, or installing it via a package manager), you’ll get gc and the official runtime by the Go team. And if the context doesn’t imply otherwise, when we talk about how “Go does things”, we usually refer to gc. It’s the main implementation.\nThe standard library The standard library is a set of packages that come with Go and can be relied upon to immediately build useful applications with. It too is maintained by the Go team and versioned and released together with the language and compiler. In general the standard library of one implementation will only work with the compiler it comes with. The reason is that most (but not all) of the runtime is part of the standard library (mainly in the packages runtime, reflect, syscall). As the compiler needs to generate code compatible with the used runtime, both need to come from the same version. The API of the standard library is stable and won’t change in incompatible ways, so a Go program written against a given version of the standard library will continue to work as expected with future versions of the compiler.\nSome implementations use their own version of some or all of the standard library - in particular, the runtime, reflect, unsafe and syscall packages are completely implementation-defined. As an example, I believe that AppEngine Standard used to re-define parts of the standard library for security and safety. In general, implementations try to make that transparent to the user.\nThere is also a separate set of repositories, colloquially referred to as x or “the subrepositories”. They contain packages which are developed and maintained by the Go team with all the same processes, but are not on the same release schedule as the language and have less strict compatibility guarantees (and commitment to maintainership) than Go itself. The packages in there are either experimental (for potential future inclusion in the standard library), not widely useful enough to be included in the standard library or, in rare cases, a way for people on the Go team to work on code using the same review processes they are used to.\nAgain, when referring to “the standard library” devoid of extra context, we mean the officially maintained and distributed one, hosted on golang.org.\nThe build tool To make the language user-friendly, you need a build tool. The primary role of this tool is to find the package you want to compile, find all of its dependencies, and execute the compiler and linker with the arguments necessary to build them. Go (the language) has support for packages, which combine multiple source files into one unit of compilation. And it defines how to import and use other packages. But importantly, it doesn’t define how import paths map to source files or how they are laid out on disk. As such, each build tool comes with its own ideas for this. It’s possible to use a generic build tool (like Make) for this purpose, but there are a bunch of Go-specific ones:\n The go tool1 is the build tool officially maintained by the Go team. It is versioned and released with the language (and gc and the standard library). It expects a directory called GOROOT (from an environment variable, with a compiled default) to contain the compiler, the standard library and various other tools. And it expects all source code in a single directory called GOPATH (from an environment variable, defaulting to $HOME/go or equivalent). Specifically, package a/b is expected to have its source at $GOPATH/src/a/b/c.go etc. And $GOPATH/src/a/b is expected to only contain source files of one package. It also has a mechanism to download a package and its dependencies recursively from an arbitrary server, in a fully decentralized scheme, though it does not support versioning or verification of downloads. The go tool also contains extra tooling for testing Go code, reading documentation (golang.org is served by the Go tool), file bugs, run various tools… gopherjs comes with its own build tool, that largely mimics the Go tool. gomobile is a build tool specifically to build Go code for mobile operating systems. dep, gb, glide,… are community-developed build-tools and dependency managers, each with their own approach to file layout (some are compatible with the go tool, some aren’t) and dependency declarations. bazel is the open source version of Google’s own build system. While it’s not actually Go-specific, I’m mentioning it explicitly due to common claims that idiosyncrasies of the go tool are intended to serve Google’s own use cases, in conflict with the needs of the community. However, the go tool (and many public tools) can’t be used at Google, because bazel uses an incompatible file layout.  The build tool is what most users directly interface with and as such, it’s what largely determines aspects of the Go ecosystem and how packages can be combined and thus how different Go programmers interact. As above, the go tool is what’s implicitly referred to (unless other context is specified) and thus its design decisions significantly influence public opinion about “Go”. While there are alternative tools and they have wide adoption for use cases like company-internal code, the open source community in general expects code to conform to the expectations of the go tool, which (among other things) means:\n Be available as source code. The go tool has little support for binary distribution of packages, and what little it has is going to be removed soon. Be documented according to the godoc format. Have tests that can be run via go test. Be fully compilable by a go build (together with the next one, this is usually called being “go-gettable”). In particular, to use go generate if generating source-code or metaprogramming is required and commit the generated artifacts. Namespace import paths with a domain-name as the first component and have that domain-name either be a well-known code hoster or have a webserver running on it, so that go get works and can find the source code of dependencies. Have one package per directory and use build constraints for conditional compilation.  The documentation of the go tool is very comprehensive and probably a good starting point to learn how Go implements various ecosystem aspects.\nTools Go’s standard library includes several packages to interact with Go source code and the x/tools subrepo contains even more. As a result (and due to a strong desire to keep the canonical Go distribution lean), Go has developed a strong culture of developing third-party tools. In general, these tools need to know where to find source code, and might need access to type information. The go/build package implements the conventions used by the Go tool, and can thus also serve as documentation for parts of its build process. The downside is that tools built on top of it sometimes don’t work with code relying on other build tools. That’s why there is a new package in development which integrates nicely with other build tools.\nBy its nature the list of Go tools is long and everybody has their own preferences. But broadly, they contain:\n Tools developed by the Go team and released as part of the distribution. This includes tools for automatically formatting source code, coverage testing, runtime tracing and profiling, a static analyzer for common mistakes and a mostly obsolete tool to migrate code to new Go versions. These are generally accesed via go tool . Tools developed by the Go team and maintained out-of-tree. This includes tools to write blog posts and presentations, easily do large refactors, automatically find and fix import paths and a language server. Third-party tools - too many to count. There are many lists of these; here is one.  In Summary I wanted to end this with a short list of references for beginners who feel lost. So this is where you should go, if you:\n Want to start learning Go. Want to understand how a specific language construct works. Want to nitpick what is or is not valid Go and why. Want documentation about what the go tool does Also available via go help. It sometimes references other topics, that you can also see on the web, but not nicely. Want to write code that adheres to community standards. Want to test your code. Want to find new packages or look at documentation of public packages.  There are many more useful supplementary documents, but this should serve as a good start. Please let me know on Twitter if you are a beginner and there’s an area of Go you are missing from this overview (I might follow this up with more specific topics), or a specific reference you found helpful. You can also drop me a note if you’re a more experienced Gopher and think I missed something important (but keep in mind that I intentionally left out most references, so as to keep the ways forward crisp and clear :) ).\n  The Go team is currently rolling out support for modules, which is a unit of code distribution above packages, including support for versioning and more infrastructure to solve some issues with the “traditional” go tool. With that, basically everything in that paragraph becomes obsolete. However, for now the module support exists but is opt-in. And as the point of this article is to provide an overview of the separation of concerns, which doesn’t actually change, I felt it was better to stay within ye olden days - for now. ↩︎\n   ","wordCount":"2317","inLanguage":"en","datePublished":"2019-06-12T00:00:00Z","dateModified":"2019-06-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2019-06-12-birdseye-go/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A bird's eye view of Go</h1><div class=post-meta><span title="2019-06-12 00:00:00 +0000 UTC">June 12, 2019</span></div></header><div class=post-content><p><strong>tl;dr: I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose. See the bottom-most section for that.</strong></p><p>When we talk about &ldquo;Go&rdquo;, depending on context, we can mean very different
things. This is my attempt at providing a very high-level overview of the
language and ecosystem and to link to the relevant documentation about how each
part fits together (it&rsquo;s also a bit of a hodgepodge though, addressing
individual random questions I encountered recently). So, let&rsquo;s dive in:</p><h2 id=the-go-programming-language>The Go programming language<a hidden class=anchor aria-hidden=true href=#the-go-programming-language>#</a></h2><p>The bottom turtle is Go, the programming language. It defines the format and
meaning of source code and the authoritative source is
<a href=https://golang.org/ref/spec>the Go language specification</a>. If something
doesn&rsquo;t conform to the spec, it&rsquo;s not &ldquo;Go&rdquo;. And conversely, if something
<em>isn&rsquo;t</em> mentioned in the spec it&rsquo;s not part of the language. The language spec
is maintained by the Go team and versioned, with a new release roughly every
six months. At the time I wrote this post, the newest release was version
<code>1.12</code>.</p><p>The domain of the spec are:</p><ul><li>The grammar of the language</li><li>Types, values and their semantics</li><li>What identifiers are predeclared and what their meaning is</li><li>How Go programs get executed</li><li>The special package <a href=https://golang.org/ref/spec#Package_unsafe>unsafe</a>
(though not all of its semantics)</li></ul><p>The spec alone <em>should</em> enable you to write a compiler for Go. And indeed,
there are many different compilers.</p><h2 id=a-go-compiler-and-runtime>A Go compiler and runtime<a hidden class=anchor aria-hidden=true href=#a-go-compiler-and-runtime>#</a></h2><p>The language spec is a text document, which is not useful in and of itself.
For that you need software that actually implements these semantics. This is
done by a compiler (which analyzes and checks the source code and
transforms it into an executable format) and a runtime (which provides the
necessary environment to actually run the code). There are many such
combinations and they all differ a bit more or a bit less. Examples are:</p><ul><li><code>gc</code>, a compiler and runtime written in pure Go (with some assembly) by the
Go team themselves and versioned and released together with the language.
Unlike other such tools, <code>gc</code> doesn&rsquo;t <em>strictly</em> separate the compiler,
assembler and linker - they end up sharing a lot of code and some of the
classical responsibilities move or are shared between them. As such, it&rsquo;s in
general not possible to e.g. link packages compiled by different versions of
<code>gc</code>.</li><li><a href=https://golang.org/doc/install/gccgo>gccgo and libgo</a>, a frontend for gcc
and a runtime. It&rsquo;s written in C and maintained by the Go team. It lives in
the gcc organization though and is released according to the gcc release
schedule and thus often lags a bit behind the &ldquo;latest&rdquo; version of the Go
spec.</li><li><a href=https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT>llgo</a>, a frontend
for LLVM. I don&rsquo;t know much else about it.</li><li><a href=https://github.com/gopherjs/gopherjs>gopherjs</a>, compiling Go code into
javascript and using a javascript VM plus some custom code as a runtime.
Long-term, it&rsquo;ll probably be made obsolete by <code>gc</code> gaining native support for
WebAssembly.</li><li><a href=https://tinygo.org/>tinygo</a>, an incomplete implementation targeting small
code size. Runs on either bare-metal micro-controllers or WebAssembly VMs,
with a custom runtime. Due to its limitations it doesn&rsquo;t <em>technically</em>
implement Go - notably, it doesn&rsquo;t include a garbage collector, concurrency
or reflection.</li></ul><p>There are more, but this gives you an overview over the variety
of implementations. Each of these made potentially different choices
for how to implement the language and have their own idiosyncrasies.
Examples (some of them a bit exotic, to illustrate) where they might differ are:</p><ul><li>Size of <code>int</code>/<code>uint</code> - the language allows them to be either 32 or 64 bit wide.</li><li>How fundamental functionalities of the runtime, like allocation, garbage
collection or concurrency are implemented.</li><li>The order of ranging over a <code>map</code> isn&rsquo;t defined in the language - <code>gc</code>
famously explicitly randomizes it, <code>gopherjs</code> uses (last time I checked)
whatever the javascript implementation you are running on uses.</li><li>How much extra space <code>append</code> allocates if it needs to - <em>not</em> however,
<em>when</em> it allocates extra space.</li><li>How conversions between <code>unsafe.Pointer</code> and <code>uintptr</code> happen. <code>gc</code>, in
particular, comes with its own <a href=https://godoc.org/unsafe#Pointer>set of rules</a>
regarding when these conversions are valid and when they aren&rsquo;t. In general,
the <code>unsafe</code> package is virtual and implemented in the compiler.</li></ul><p>In general, relying on details not mentioned in the spec (in particular the
ones mentioned here) makes your program <em>compile</em> with different compilers, but
not <em>work</em> as expected. So you should avoid it if possible.</p><p>If you install Go via a &ldquo;normal&rdquo; way (by downloading it from the website, or
installing it via a package manager), you&rsquo;ll get <code>gc</code> and the official
runtime by the Go team. And if the context doesn&rsquo;t imply otherwise, when
we talk about how &ldquo;Go does things&rdquo;, we usually refer to <code>gc</code>. It&rsquo;s the main
implementation.</p><h2 id=the-standard-library>The standard library<a hidden class=anchor aria-hidden=true href=#the-standard-library>#</a></h2><p><a href=https://golang.org/pkg/#stdlib>The standard library</a> is a set of packages
that come with Go and can be relied upon to immediately build useful
applications with. It too is maintained by the Go team and versioned and
released together with the language and compiler. In general the standard
library of one implementation will only work with the compiler it comes with.
The reason is that most (but not all) of the runtime is part of the standard
library (mainly in the packages <code>runtime</code>, <code>reflect</code>, <code>syscall</code>). As the
compiler needs to generate code compatible with the used runtime, both need to
come from the same version. The <em>API</em> of the standard library is stable and
won&rsquo;t change in incompatible ways, so a Go program written against a given
version of the standard library will continue to work as expected with future
versions of the compiler.</p><p>Some implementations use their own version of some or all of the standard
library - in particular, the <code>runtime</code>, <code>reflect</code>, <code>unsafe</code> and <code>syscall</code>
packages are completely implementation-defined. As an example, I believe that
<a href=https://cloud.google.com/appengine/docs/standard/go/>AppEngine Standard</a> used
to re-define parts of the standard library for security and safety. In general,
implementations try to make that transparent to the user.</p><p>There is also a <a href=https://golang.org/pkg/#subrepo>separate set of repositories</a>,
colloquially referred to as <code>x</code> or &ldquo;the subrepositories&rdquo;. They contain packages
which are developed and maintained by the Go team with all the same processes,
but are <em>not</em> on the same release schedule as the language and have less strict
compatibility guarantees (and commitment to maintainership) than <a href=https://golang.org/doc/go1compat>Go itself</a>.
The packages in there are either experimental (for potential future inclusion
in the standard library), not widely useful enough to be included in the
standard library or, in rare cases, a way for people on the Go team to work on
code using the same review processes they are used to.</p><p>Again, when referring to &ldquo;the standard library&rdquo; devoid of extra context, we
mean the officially maintained and distributed one, hosted on
<a href=https://golang.org/pkg>golang.org</a>.</p><h2 id=the-build-tool>The build tool<a hidden class=anchor aria-hidden=true href=#the-build-tool>#</a></h2><p>To make the language user-friendly, you need a build tool. The primary role of
this tool is to find the package you want to compile, find all of its
dependencies, and execute the compiler and linker with the arguments necessary
to build them. Go (the language) has <a href=https://golang.org/ref/spec#Packages>support for packages</a>,
which combine multiple source files into one unit of compilation. And it
defines how to import and use other packages. But importantly, it doesn&rsquo;t
define how import paths map to source files or how they are laid out on disk.
As such, each build tool comes with its own ideas for this. It&rsquo;s possible to
use a generic build tool (like Make) for this purpose, but there are a bunch of
Go-specific ones:</p><ul><li><a href=https://golang.org/cmd/go/>The go tool</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> is the build tool officially maintained
by the Go team. It is versioned and released with the language (and
<code>gc</code> and the standard library). It expects a directory called <code>GOROOT</code> (from
an environment variable, with a compiled default) to contain the compiler,
the standard library and various other tools. And it expects all source code
in a single directory called <code>GOPATH</code> (from an environment variable,
defaulting to <code>$HOME/go</code> or equivalent). Specifically, package <code>a/b</code> is
expected to have its source at <code>$GOPATH/src/a/b/c.go</code> etc. And
<code>$GOPATH/src/a/b</code> is expected to <em>only</em> contain source files of one package.
It also has a mechanism to
<a href=https://golang.org/cmd/go/#hdr-Remote_import_paths>download a package and its dependencies recursively from an arbitrary server</a>,
in a fully decentralized scheme, though it does not support versioning or
verification of downloads. The go tool also contains extra tooling for
testing Go code, reading documentation (<a href=https://golang.org>golang.org</a> is
served by the Go tool), file bugs, run various tools…</li><li><a href=https://github.com/gopherjs/gopherjs>gopherjs</a> comes with its own build
tool, that largely mimics the Go tool.</li><li><a href=https://github.com/golang/go/wiki/Mobile>gomobile</a> is a build tool
specifically to build Go code for mobile operating systems.</li><li><a href=https://github.com/golang/dep>dep</a>, <a href=https://getgb.io/>gb</a>,
<a href=https://glide.sh/>glide</a>,… are community-developed build-tools and
dependency managers, each with their own approach to file layout (some are
compatible with the go tool, some aren&rsquo;t) and dependency declarations.</li><li><a href=https://bazel.build/>bazel</a> is the open source version of Google&rsquo;s own
build system. While it&rsquo;s not actually Go-specific, I&rsquo;m mentioning it
explicitly due to common claims that idiosyncrasies of the go tool are
intended to serve Google&rsquo;s own use cases, in conflict with the needs of the
community. However, the go tool (and many public tools) can&rsquo;t be used at
Google, because bazel uses an incompatible file layout.</li></ul><p>The build tool is what most users directly interface with and as such, it&rsquo;s
what largely determines aspects of the <em>Go ecosystem</em> and how packages can be
combined and thus how different Go programmers interact. As above, the go tool
is what&rsquo;s implicitly referred to (unless other context is specified) and thus its
design decisions significantly influence public opinion about &ldquo;Go&rdquo;. While there
are alternative tools and they have wide adoption for use cases like
company-internal code, the open source community <em>in general</em> expects code to
conform to the expectations of the go tool, which (among other things) means:</p><ul><li>Be available as source code. The go tool has little support for binary
distribution of packages, and what little it has is going to be removed soon.</li><li>Be documented according to <a href=https://blog.golang.org/godoc-documenting-go-code>the godoc format</a>.</li><li><a href=https://golang.org/pkg/testing/#pkg-overview>Have tests</a> that can be run via <code>go test</code>.</li><li>Be fully compilable by a <code>go build</code> (together with the next one, this is
usually called being &ldquo;go-gettable&rdquo;). In particular, to use <a href=https://golang.org/pkg/cmd/go/internal/generate/>go generate</a>
if generating source-code or metaprogramming is required and commit the generated
artifacts.</li><li>Namespace import paths with a domain-name as the first component and have
that domain-name either be a well-known code hoster or have a webserver
running on it, so that <a href=https://golang.org/cmd/go/#hdr-Remote_import_paths>go get works</a>
and can find the source code of dependencies.</li><li>Have one package per directory and use <a href=https://golang.org/pkg/go/build/#hdr-Build_Constraints>build constraints</a>
for conditional compilation.</li></ul><p>The <a href=https://golang.org/cmd/go>documentation of the go tool</a> is very
comprehensive and probably a good starting point to learn how Go implements
various ecosystem aspects.</p><h2 id=tools>Tools<a hidden class=anchor aria-hidden=true href=#tools>#</a></h2><p>Go&rsquo;s standard library includes <a href=https://golang.org/pkg/go/>several packages to interact with Go source code</a>
and the <a href=https://godoc.org/golang.org/x/tools/go>x/tools subrepo contains even more</a>.
As a result (and due to a strong desire to keep the canonical Go distribution
lean), Go has developed a strong culture of developing third-party tools. In
general, these tools need to know where to find source code, and might
need access to type information. The <a href=https://golang.org/pkg/go/build/>go/build</a>
package implements the conventions used by the Go tool, and can thus also serve
as documentation for parts of its build process. The downside is that tools
built on top of it sometimes don&rsquo;t work with code relying on other build tools.
That&rsquo;s why there is a <a href=https://godoc.org/golang.org/x/tools/go/packages>new package in development</a>
which integrates nicely with other build tools.</p><p>By its nature the list of Go tools is long and everybody has their own
preferences. But broadly, they contain:</p><ul><li><a href=https://golang.org/cmd/>Tools developed by the Go team and released as part of the distribution</a>.</li><li>This includes tools for <a href=https://golang.org/cmd/gofmt/>automatically formatting source code</a>,
<a href=https://golang.org/cmd/cover/>coverage testing</a>,
<a href=https://golang.org/cmd/trace/>runtime tracing</a> and
<a href=https://golang.org/cmd/pprof/>profiling</a>, a <a href=https://golang.org/cmd/vet/>static analyzer for common mistakes</a>
and <a href=https://golang.org/cmd/fix/>a mostly obsolete tool to migrate code to new Go versions</a>.
These are generally accesed via <code>go tool &lt;cmd></code>.</li><li><a href=https://godoc.org/golang.org/x/tools/cmd>Tools developed by the Go team and maintained out-of-tree</a>.
This includes tools to
<a href=https://godoc.org/golang.org/x/tools/cmd/present>write blog posts and presentations</a>,
<a href=https://godoc.org/golang.org/x/tools/cmd/eg>easily do large refactors</a>,
<a href=https://godoc.org/golang.org/x/tools/cmd/goimports>automatically find and fix import paths</a>
and a <a href=https://godoc.org/golang.org/x/tools/cmd/gopls>language server</a>.</li><li>Third-party tools - too many to count. There are many lists of these;
<a href=https://github.com/avelino/awesome-go#tools>here is one</a>.</li></ul><h2 id=in-summary>In Summary<a hidden class=anchor aria-hidden=true href=#in-summary>#</a></h2><p>I wanted to end this with a short list of references for beginners who feel lost.
So this is where you should go, if you:</p><ul><li><a href=https://tour.golang.org/welcome/1>Want to start learning Go</a>.</li><li><a href=https://golang.org/doc/effective_go.html>Want to understand how a specific language construct works</a>.</li><li><a href=https://golang.org/ref/spec>Want to nitpick what is or is not valid Go and why</a>.</li><li><a href=https://golang.org/cmd/go/>Want documentation about what the go tool does</a>
Also available via <code>go help</code>. It sometimes references other topics, that you can also
<a href=https://golang.org/pkg/cmd/go/internal/help/>see on the web</a>, but not nicely.</li><li><a href=https://github.com/golang/go/wiki/CodeReviewComments>Want to write code that adheres to community standards</a>.</li><li><a href=https://golang.org/pkg/testing/#pkg-overview>Want to test your code</a>.</li><li><a href=https://godoc.org/>Want to find new packages or look at documentation of public packages</a>.</li></ul><p>There are many more useful supplementary documents, but this should serve as a good start.
Please <a href=https://twitter.com/TheMerovius>let me know on Twitter</a>
if you are a beginner and there&rsquo;s an area of Go you are missing from this
overview (I might follow this up with more specific topics), or a specific
reference you found helpful. You can also drop me a note if you&rsquo;re a more
experienced Gopher and think I missed something important (but keep in mind
that I intentionally left out most references, so as to keep the ways
forward crisp and clear :) ).</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The Go team is currently rolling out support for <em>modules</em>, which is
a unit of code distribution above packages, including support for versioning
and more infrastructure to solve some issues with the &ldquo;traditional&rdquo; go
tool. With that, basically everything in that paragraph becomes obsolete.
However, <em>for now</em> the module support exists but is opt-in. And as the
point of this article is to provide an overview of the separation of
concerns, which doesn&rsquo;t actually change, I felt it was better to stay
within ye olden days - <em>for now</em>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://twitter.com/TheMerovius target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>