<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Persistent datastructures with Go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I present a couple of patterns that help modelling persistent datastructures in Go. I also apply them to three examples."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="Persistent datastructures with Go"><meta property="og:description" content="I present a couple of patterns that help modelling persistent datastructures in Go. I also apply them to three examples."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-25T17:30:00+00:00"><meta property="article:modified_time" content="2018-02-25T17:30:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Persistent datastructures with Go"><meta name=twitter:description content="I present a couple of patterns that help modelling persistent datastructures in Go. I also apply them to three examples."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Persistent datastructures with Go","item":"https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Persistent datastructures with Go","name":"Persistent datastructures with Go","description":"I present a couple of patterns that help modelling persistent datastructures in Go. I also apply them to three examples.","keywords":["golang","programming"],"articleBody":"I’ve recently taken a liking to persistent datastructures. These are datastructures where instead of mutating data in-place, you are creating a new version of the datastructures, that shares most of its state with the previous version. Not all datastructures can be implemented efficiently like this, but those that do get a couple of immediate benefits - keeping old versions around allows you to get cheap snapshotting and copying. It is trivial to pass a copy to a different thread and you don’t have to worry about concurrent writes, as neither actually mutates any shared state.\nPersistent datastructures are popular in functional programming languages, but I also found the idea a useful tool to model datastructures in Go. Go’s interfaces provide a nice way to model them and make them easy to reason about. In this post, I will try to illustrate this with a couple of examples.\nThere are four key ideas I’d like you to walk away with:\n Modeling datastructures as persistent (if possible) makes them easier to reason about. When you want to use sum types, try to think of the common properties you are trying to abstract over instead - put those in an interface. Separate out the required from the provided interface. Make the former an interface type, provide the latter as functions or a wrapper. Doing these allows you to add more efficient implementations later, when you discover they are necessary.  Linked lists This is more of an illustrative example, to demonstrate the techniques, than actually useful. But one of the simplest datastructures existing are linked lists: A list of nodes, where each node has a value and possibly a next node (unless we are at the end of the List). In functional languages, you’d use a sum type to express this:\ntype List a = Node a (List a) -- either it's a node with a value and the rest of the list | End -- or it's the end of the list Go infamously does not have sum types, but we can use interfaces to instead. The classical way would be something like\ntype List interface { // We use an unexported marker-method. As nothing outside the current package  // can implement this unexported method, we get control over all  // implementations of List and can thus de-facto close the set of possible  // types.  list() } type Node struct { Value int Next List } func (Node) list() {} type End struct {} func (End) list() {} func Value(l List) (v int, ok bool) { switch l := l.(type) { case Node: return l.Value, true case End: return 0, false default: // This should never happen. Someone violated our sum-type assumption.  panic(fmt.Errorf(\"unknown type %T\", l)) } } This works, but it is not really idiomatic Go code. It is error-prone and easy to misuse, leading to potential panics. But there is a different way to model this using interfaces, closer to how they are intended. Instead of expressing what a list is\n A list is either a value and a next element, or the end of the list\n we say what we want a list to be able to do:\n A list has a current element and may have a tail\n type List interface { // Value returns the current value of the list  Value() int // Next returns the tail of the list, or nil, if this is the last node.  Next() List } type node struct { value int next List } func (n node) Value() int { return n.value } func (n node) Next() List { return n.next } func New(v int) List { return node{v, nil} } func Prepend(l List, v int) List { return node{v, l} } This is a far more elegant abstraction. The empty list is represented by the nil interface. We have only one implementation of that interface, for the nodes. We offer exported functions to create new lists - potentially from existing ones.\nNote that the methods actually have node as a receiver, not *node, as we often tend to do with structs. This fact makes this implementation a persistent linked list. None of the methods can modify the list. So after creation, the linked list will stay forever immutable. Even if you type-assert to get to the underlying data, that would only provide you with a copy of the data - the original would stay unmodified. The memory layout, however, is the same - the value gets put on the heap and you are only passing pointers to it around.\nThe beauty of this way to think about linked lists, is that it allows us to amend it after the fact. For example, say we notice that our program is slow, due to excessive cache-misses (as linked lists are not contiguous in memory). We can easily add a function, that packs a list:\ntype packed []int func (p packed) Value() int { return p[0] } func (p packed) Next() List { if len(p) == 0 { return nil } return p[1:] } func Pack(l List) List { if l == nil { return nil } var p packed for ; l != nil; l = l.Next() { p = append(p, l.Value()) } return p } The cool thing about this is that we can mix and match the two: For example, we could prepend new elements and once the list gets too long, pack it and continue to prepend to the packed list. And since List is an interface, users can implement it themselves and use it with our existing implementation. So, for example, a user could build us a list that calculates fibonacci numbers:\ntype fib [2]int func (l fib) Value() int { return l[0] } func (l fib) Next() List { return fib{l[1], l[0]+l[1]} } and then use that with functions that take a List. Or they could have a lazily evaluated list:\ntype lazy struct { o sync.Once f func() (int, List) v int next List } func (l *lazy) Value() int { l.o.Do(func() { l.v, l.next = l.f() }) return l.v } func (l *lazy) Next() List { l.o.Do(func() { l.v, l.next = l.f() }) return l.next } Note that in this case the methods need to be on a pointer-receiver. This (technically) leaves the realm of persistent data-structures. While they motivated our interface-based abstraction and helped us come up with a safe implementation, we are not actually bound to them. If we later decide, that for performance reasons we want to add a mutable implementation, we can do so (of course, we still have to make sure that we maintain the safety of the original). And we can intermix the two, allowing us to only apply this optimization to part of our data structure.\nI find this a pretty helpful way to think about datastructures.\nAssociative lists Building on linked lists, we can build a map based on Association Lists. It’s a similar idea as before:\ntype Map interface { Value(k interface{}) interface{} Set(k, v interface{}) Map } type empty struct{} func (empty) Value(_ interface{}) interface{} { return nil } func (empty) Set(k, v interface{}) Map { return pair{k, v, empty{}} } func Make() Map { return empty{} } type pair struct { k, v interface{} parent Map } func (p pair) Value(k interface{}) interface{} { if k == p.k { return p.v } return p.parent.Value(k) } func (p pair) Set(k, v interface{}) Map { return pair{k, v, p} } This time, we don’t represent an empty map as nil, but add a separate implementation of the interface for an empty map. That makes the implementation of Value cleaner, as it doesn’t have to check the parent map for nil – but it requires users to call Make.\nThere is a problem with our Map, though: We cannot iterate over it. The interface does not give us access to any parent maps. We could use type-assertion, but that would preclude users from implementing their own. What if we added a method to the interface to support iteration?\ntype Map interface { Value(k interface{}) interface{} // Iterate calls f with all key-value pairs in the map.  Iterate(f func(k, v interface{})) } func (empty) Iterate(func(k, v interface{})) { } func (p pair) Iterate(f func(k, v interface{})) { f(p.k, p.v) p.parent.Iterate(f) } Unfortunately, this still doesn’t really work though: If we write multiple times to the same key, Iterate as implemented would call f with all key-value-pairs. This is likely not what we want.\nThe heart of the issue here, is the difference between the required interface and the provided interface. We can also see that with Set. Both of the implementations of that method look essentially the same and neither actually depends on the used type. We could instead provide Set as a function:\nfunc Set(m Map, k, v interface{}) Map { return pair{k,v,m} } The lesson is, that some operations need support from the implementation, while other operations can be implemented without it. The provided interface is the set of operations we provide to the user, whereas the required interface is the set of operations that we rely on. We can split the two and get something like this:\n// Interface is the set of operations required to implement a persistent map. type Interface interface { Value(k interface{}) interface{} Iterate(func(k, v interface{})) } type Map struct { Interface } func (m Map) Iterate(f func(k, v interface{})) { seen := make(map[interface{}]bool) m.Interface.Iterate(func(k, v interface{}) { if !seen[k] { f(k, v) } }) } func (m Map) Set(k, v interface{}) Map { return Map{pair{k, v, m.Interface}} } Using this, we could again implement a packed variant of Map:\ntype packed map[interface{}]interface{} func (p packed) Value(k interface{}) interface{} { return p[k] } func (p packed) Iterate(f func(k, v interface{})) { for k, v := range p { f(k, v) } } func Pack(m Map) Map { p := make(packed) m.Iterate(func(k,v interface{}) { p[k] = v }) return m } Ropes A Rope is a data structure to store a string in a way that is efficiently editable. They are often used in editors, as it is too slow to copy the complete content on every insert operation. Editors also benefit from implementing them as persistent data structures, as that makes it very easy to implement multi-level undo: Just have a stack (or ringbuffer) of Ropes, representing the states the file was in after each edit. Given that they all share most of their structure, this is very efficient. Implementing ropes is what really bought me into the patterns I’m presenting here. Let’s see, how we could represent them.\n A Rope is a binary tree with strings as leafs. The represented string is what you get when you do a depth-first traversal and concatenate all the leafs. Every node in the tree also has a weight, which corresponds to the length of the string for leafs and the length of the left subtree for inner nodes. This allows easy recursive lookup of the ith character: If i is less than the weight of a node, we look into the left subtree, otherwise into the right. Let’s represent this:\ntype Base interface { Index(i int) byte Length() int } type leaf string func (l leaf) Index(i int) byte { return l[i] } func (l leaf) Length() int { return len(l) } type node struct { left, right Base } func (n node) Index(i int) byte { if w := n.left.Length(); i = w { // The string represented by the right child starts at position w,  // so we subtract it when recursing to the right  return n.right.Index(i-w) } return n.left.Index(i) } func (n node) Length() int { return n.left.Length() + n.right.Length() } type Rope struct { Base } func New(s string) Rope { return Rope{leaf(s)} } func (r Rope) Append(r2 Rope) Rope { return Rope{node{r.Base, r2.Base}} } Note, how we did not actually add a Weight-method to our interface: Given that it’s only used by the traversal on inner nodes, we can just directly calculate it from its definition as the length of the left child tree. In practice, we might want to pre-calculate Length on creation, though, as it currently is a costly recursive operation.\nThe next operation we’d have to support, is splitting a Rope at an index. We can’t implement that with our current interface though, we need to add it:\ntype Base interface { Index(i int) byte Length() int Split(i int) (left, right Base) } func (l leaf) Split(i int) (Base, Base) { return l[:i], l[i:] } func (n node) Split(i int) (Base, Base) { if w := n.left.Length(); i = w { left, right := n.right.Split(i-w) return node{n.left, left}, right } left, right := n.left.Split(i) return left, node{n.right, right} } func (r Rope) Split(i int) (Rope, Rope) { // Note that we return the wrapping struct, as opposed to Base.  // This is so users work with the provided interface, not the required one.  left, right := r.Split(i) return Rope{left}, Rope{right} } I think this code is remarkably readable and easy to understand - and that is mostly due to the fact that we are reusing subtrees whenever we can. What’s more, given these operations we can implement the remaining three from the wikipedia article easily:\nfunc (r Rope) Insert(r2 Rope, i int) Rope { left, right := r.Split(i) return left.Append(r2).Append(right) } func (r Rope) Delete(i, j int) Rope { left, right := r.Split(j) left, _ = left.Split(i) return left.Append(right) } func (r Rope) Slice(i, j int) Rope { r, _ = r.Split(j) _, r = r.Split(i) return r } This provides us with a fully functioning Rope implementation. It doesn’t support everything we’d need to write an editor, but it’s a good start that was quick to write. It is also reasonably simple to extend with more functionality. For example, you could imagine having an implementation that can rebalance itself, when operations start taking too long. Or adding traversal, or random-access unicode support that is still backed by compact UTF-8. And I found it reasonably simple (though it required some usage of unsafe) to write an implementation of Base that used an mmaped file (thus you’d only need to keep the actual edits in RAM, the rest would be read directly from disk with the OS managing caching for you).\nClosing remarks None of these ideas are revolutionary (especially to functional programmers). But I find that considering if a datastructure I need can be implemented as a persistent/immutable one helps me to come up with clear abstractions that work well. And I also believe that Go’s interfaces provide a good way to express these abstractions - because they allow you to start with a simple, immutable implementation and then compose it with mutable ones - if and only if there are clear efficiency benefits. Lastly, I think there is an interesting idea here of how to substitute sum-types by interfaces - not in a direct manner, but instead by thinking about the common behavior you want to provide over the sum.\nI hope you find that this inspires you to think differently about these problems too.\n","wordCount":"2520","inLanguage":"en","datePublished":"2018-02-25T17:30:00Z","dateModified":"2018-02-25T17:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Persistent datastructures with Go</h1><div class=post-meta><span title="2018-02-25 17:30:00 +0000 UTC">February 25, 2018</span></div></header><div class=post-content><p>I&rsquo;ve recently taken a liking to <a href=https://en.wikipedia.org/wiki/Persistent_data_structure>persistent datastructures</a>.
These are datastructures where instead of mutating data in-place, you are
creating a new version of the datastructures, that shares most of its state
with the previous version. Not all datastructures can be implemented
efficiently like this, but those that do get a couple of immediate benefits -
keeping old versions around allows you to get cheap snapshotting and copying.
It is trivial to pass a copy to a different thread and you don&rsquo;t have to worry
about concurrent writes, as neither actually mutates any shared state.</p><p>Persistent datastructures are popular in functional programming languages, but
I also found the idea a useful tool to model datastructures in Go. Go&rsquo;s
interfaces provide a nice way to model them and make them easy to reason about.
In this post, I will try to illustrate this with a couple of examples.</p><p>There are four key ideas I&rsquo;d like you to walk away with:</p><ul><li>Modeling datastructures as persistent (<em>if possible</em>) makes them easier to
reason about.</li><li>When you want to use sum types, try to think of the common properties you are
trying to abstract over instead - put those in an interface.</li><li>Separate out the required from the provided interface. Make the former an
interface type, provide the latter as functions or a wrapper.</li><li>Doing these allows you to add more efficient implementations later, when you
discover they are necessary.</li></ul><h2 id=linked-lists>Linked lists<a hidden class=anchor aria-hidden=true href=#linked-lists>#</a></h2><p>This is more of an illustrative example, to demonstrate the techniques, than
actually useful. But one of the simplest datastructures existing are linked
lists: A list of nodes, where each node has a value and possibly a next node
(unless we are at the end of the List). In functional languages, you&rsquo;d use a
sum type to express this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>type</span> <span class=kt>List</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Node</span> <span class=n>a</span> <span class=p>(</span><span class=kt>List</span> <span class=n>a</span><span class=p>)</span> <span class=c1>-- either it&#39;s a node with a value and the rest of the list</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=kt>End</span>             <span class=c1>-- or it&#39;s the end of the list</span>
</span></span></code></pre></div><p>Go infamously does not have sum types, but we can use interfaces to instead.
The classical way would be something like</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>List</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We use an unexported marker-method. As nothing outside the current package
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// can implement this unexported method, we get control over all
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// implementations of List and can thus de-facto close the set of possible
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// types.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Value</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nx>Next</span> <span class=nx>List</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>Node</span><span class=p>)</span> <span class=nf>list</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>End</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>End</span><span class=p>)</span> <span class=nf>list</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>l</span> <span class=nx>List</span><span class=p>)</span> <span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=nx>l</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nx>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>l</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nx>End</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This should never happen. Someone violated our sum-type assumption.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nb>panic</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unknown type %T&#34;</span><span class=p>,</span> <span class=nx>l</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This works, but it is not really idiomatic Go code. It is error-prone and easy
to misuse, leading to potential panics. But there is a different way to model
this using interfaces, closer to how they are intended. Instead of expressing
what a list is</p><blockquote><p>A list <em>is</em> either a value and a next element, or the end of the list</p></blockquote><p>we say what we want a list to be able to <em>do</em>:</p><blockquote><p>A list has a current element and may have a tail</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>List</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Value returns the current value of the list
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Value</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Next returns the tail of the list, or nil, if this is the last node.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Next</span><span class=p>()</span> <span class=nx>List</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>value</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nx>next</span>  <span class=nx>List</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=nf>Value</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>value</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=nf>Next</span><span class=p>()</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>next</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>node</span><span class=p>{</span><span class=nx>v</span><span class=p>,</span> <span class=kc>nil</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Prepend</span><span class=p>(</span><span class=nx>l</span> <span class=nx>List</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>node</span><span class=p>{</span><span class=nx>v</span><span class=p>,</span> <span class=nx>l</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is a far more elegant abstraction. The empty list is represented by the
<code>nil</code> interface. We have only one implementation of that interface, for the
nodes. We offer exported functions to create new lists - potentially from
existing ones.</p><p>Note that the methods actually have <code>node</code> as a receiver, not <code>*node</code>, as we
often tend to do with structs. This fact makes this implementation a
<em>persistent</em> linked list. None of the methods can modify the list. So after
creation, the linked list will stay forever immutable. Even if you type-assert
to get to the underlying data, that would only provide you with a <em>copy</em> of the
data - the original would stay unmodified. The memory layout, however, is the
same - the value gets put on the heap and you are only passing pointers to it
around.</p><p>The beauty of this way to think about linked lists, is that it allows us to
amend it after the fact. For example, say we notice that our program is slow,
due to excessive cache-misses (as linked lists are not contiguous in memory).
We can easily add a function, that packs a list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>packed</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>packed</span><span class=p>)</span> <span class=nf>Value</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>packed</span><span class=p>)</span> <span class=nf>Next</span><span class=p>()</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Pack</span><span class=p>(</span><span class=nx>l</span> <span class=nx>List</span><span class=p>)</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>l</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>p</span> <span class=nx>packed</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>;</span> <span class=nx>l</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>l</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Value</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The cool thing about this is that we can mix and match the two: For example,
we could prepend new elements and once the list gets too long, pack it and
continue to prepend to the packed list. And since <code>List</code> is an interface, users
can implement it themselves and use it with our existing implementation. So,
for example, a user could build us a list that calculates fibonacci numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>fib</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>fib</span><span class=p>)</span> <span class=nf>Value</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>l</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>fib</span><span class=p>)</span> <span class=nf>Next</span><span class=p>()</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>fib</span><span class=p>{</span><span class=nx>l</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>l</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>+</span><span class=nx>l</span><span class=p>[</span><span class=mi>1</span><span class=p>]}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and then use that with functions that take a <code>List</code>. Or they could have a
lazily evaluated list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>lazy</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>o</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>  <span class=nx>f</span> <span class=kd>func</span><span class=p>()</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=nx>List</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>v</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nx>next</span> <span class=nx>List</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>lazy</span><span class=p>)</span> <span class=nf>Value</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span><span class=p>.</span><span class=nx>o</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>l</span><span class=p>.</span><span class=nx>v</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>f</span><span class=p>()</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>l</span><span class=p>.</span><span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>lazy</span><span class=p>)</span> <span class=nf>Next</span><span class=p>()</span> <span class=nx>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>l</span><span class=p>.</span><span class=nx>o</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>l</span><span class=p>.</span><span class=nx>v</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>f</span><span class=p>()</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>l</span><span class=p>.</span><span class=nx>next</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that in this case the methods need to be on a pointer-receiver. This
(technically) leaves the realm of persistent data-structures. While they
motivated our interface-based abstraction and helped us come up with a safe
implementation, we are not actually <em>bound</em> to them. If we later decide, that
for performance reasons we want to add a mutable implementation, we can do so
(of course, we still have to make sure that we maintain the safety of the
original). And we can intermix the two, allowing us to only apply this
optimization to part of our data structure.</p><p>I find this a pretty helpful way to think about datastructures.</p><h2 id=associative-lists>Associative lists<a hidden class=anchor aria-hidden=true href=#associative-lists>#</a></h2><p>Building on linked lists, we can build a map based on <a href=https://en.wikipedia.org/wiki/Association_list>Association Lists</a>.
It&rsquo;s a similar idea as before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Value</span><span class=p>(</span><span class=nx>k</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Set</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=nx>Map</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>empty</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>empty</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>_</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>empty</span><span class=p>)</span> <span class=nf>Set</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>pair</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>empty</span><span class=p>{}}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Make</span><span class=p>()</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>empty</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pair</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nx>parent</span> <span class=nx>Map</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>pair</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>k</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>k</span> <span class=o>==</span> <span class=nx>p</span><span class=p>.</span><span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>v</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>pair</span><span class=p>)</span> <span class=nf>Set</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>pair</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>p</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This time, we don&rsquo;t represent an empty map as <code>nil</code>, but add a separate
implementation of the interface for an empty map. That makes the
implementation of <code>Value</code> cleaner, as it doesn&rsquo;t have to check the parent map
for <code>nil</code> &ndash; but it requires users to call <code>Make</code>.</p><p>There is a problem with our <code>Map</code>, though: We cannot iterate over it. The
interface does not give us access to any parent maps. We could use
type-assertion, but that would preclude users from implementing their own. What
if we added a method to the interface to support iteration?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Value</span><span class=p>(</span><span class=nx>k</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Iterate calls f with all key-value pairs in the map.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>empty</span><span class=p>)</span> <span class=nf>Iterate</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>pair</span><span class=p>)</span> <span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>f</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Unfortunately, this still doesn&rsquo;t really work though: If we write multiple
times to the same key, <code>Iterate</code> as implemented would call <code>f</code> with all
key-value-pairs. This is likely not what we want.</p><p>The heart of the issue here, is the difference between the <em>required</em> interface
and the <em>provided</em> interface. We can also see that with <code>Set</code>. Both of the
implementations of that method look essentially the same and neither actually
depends on the used type. We could instead provide <code>Set</code> as a function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Set</span><span class=p>(</span><span class=nx>m</span> <span class=nx>Map</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>pair</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span><span class=nx>v</span><span class=p>,</span><span class=nx>m</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The lesson is, that some operations need support from the implementation, while
other operations can be implemented without it. The provided interface is the
set of operations we provide to the user, whereas the required interface is the
set of operations that we rely on. We can split the two and get something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Interface is the set of operations required to implement a persistent map.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Interface</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Value</span><span class=p>(</span><span class=nx>k</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Iterate</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Interface</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>Map</span><span class=p>)</span> <span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>seen</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=p>.</span><span class=nx>Interface</span><span class=p>.</span><span class=nf>Iterate</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>seen</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>f</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>Map</span><span class=p>)</span> <span class=nf>Set</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>Map</span><span class=p>{</span><span class=nx>pair</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Interface</span><span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Using this, we could again implement a packed variant of <code>Map</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>packed</span> <span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>packed</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>k</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>packed</span><span class=p>)</span> <span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Pack</span><span class=p>(</span><span class=nx>m</span> <span class=nx>Map</span><span class=p>)</span> <span class=nx>Map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>packed</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=p>.</span><span class=nf>Iterate</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ropes>Ropes<a hidden class=anchor aria-hidden=true href=#ropes>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Rope_(data_structure)>Rope</a> is a data
structure to store a string in a way that is efficiently editable. They are
often used in editors, as it is too slow to copy the complete content on every
insert operation. Editors also benefit from implementing them as persistent data
structures, as that makes it very easy to implement multi-level undo: Just have
a stack (or ringbuffer) of Ropes, representing the states the file was in after
each edit. Given that they all share most of their structure, this is very
efficient. Implementing ropes is what really bought me into the patterns
I&rsquo;m presenting here. Let&rsquo;s see, how we could represent them.</p><a href=https://en.wikipedia.org/wiki/Rope_(data_structure)#/media/File:Vector_Rope_example.svg><img src=/assets/Vector_Rope_example.svg alt='Rope representing the string "Hello_my_name_is_Simon"'></a><p>A Rope is a binary tree with strings as leafs. The represented string
is what you get when you do a depth-first traversal and concatenate all the
leafs. Every node in the tree also has a <em>weight</em>, which corresponds to the
length of the string for leafs and the length of the left subtree for inner
nodes. This allows easy recursive lookup of the <code>i</code>th character: If <code>i</code> is less
than the weight of a node, we look into the left subtree, otherwise into the
right. Let&rsquo;s represent this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Base</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Index</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl>  <span class=nf>Length</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>leaf</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>leaf</span><span class=p>)</span> <span class=nf>Index</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>l</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>leaf</span><span class=p>)</span> <span class=nf>Length</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=nx>Base</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=nf>Index</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>w</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>.</span><span class=nf>Length</span><span class=p>();</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=nx>w</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The string represented by the right child starts at position w,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so we subtract it when recursing to the right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>right</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>i</span><span class=o>-</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=nf>Length</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>.</span><span class=nf>Length</span><span class=p>()</span> <span class=o>+</span> <span class=nx>n</span><span class=p>.</span><span class=nx>right</span><span class=p>.</span><span class=nf>Length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Rope</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Base</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Rope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>Rope</span><span class=p>{</span><span class=nf>leaf</span><span class=p>(</span><span class=nx>s</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nf>Append</span><span class=p>(</span><span class=nx>r2</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nx>Rope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>Rope</span><span class=p>{</span><span class=nx>node</span><span class=p>{</span><span class=nx>r</span><span class=p>.</span><span class=nx>Base</span><span class=p>,</span> <span class=nx>r2</span><span class=p>.</span><span class=nx>Base</span><span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note, how we did not actually add a <code>Weight</code>-method to our interface: Given
that it&rsquo;s only used by the traversal on inner nodes, we can just directly
calculate it from its definition as the length of the left child tree. In
practice, we might want to pre-calculate <code>Length</code> on creation, though, as it
currently is a costly recursive operation.</p><p>The next operation we&rsquo;d have to support, is splitting a Rope at an index. We
can&rsquo;t implement that with our current interface though, we need to add it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Base</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Index</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl>  <span class=nf>Length</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nf>Split</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=nx>Base</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=nx>leaf</span><span class=p>)</span> <span class=nf>Split</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>Base</span><span class=p>,</span> <span class=nx>Base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>l</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nx>l</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=nf>Split</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>Base</span><span class=p>,</span> <span class=nx>Base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>w</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>.</span><span class=nf>Length</span><span class=p>();</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=nx>w</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>right</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=o>-</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>node</span><span class=p>{</span><span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>,</span> <span class=nx>left</span><span class=p>},</span> <span class=nx>right</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>left</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>left</span><span class=p>,</span> <span class=nx>node</span><span class=p>{</span><span class=nx>n</span><span class=p>.</span><span class=nx>right</span><span class=p>,</span> <span class=nx>right</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nf>Split</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>Rope</span><span class=p>,</span> <span class=nx>Rope</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Note that we return the wrapping struct, as opposed to Base.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This is so users work with the provided interface, not the required one.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>Rope</span><span class=p>{</span><span class=nx>left</span><span class=p>},</span> <span class=nx>Rope</span><span class=p>{</span><span class=nx>right</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I think this code is remarkably readable and easy to understand - and that is
mostly due to the fact that we are reusing subtrees whenever we can. What&rsquo;s
more, given these operations we can implement the remaining three from the
wikipedia article easily:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nf>Insert</span><span class=p>(</span><span class=nx>r2</span> <span class=nx>Rope</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>Rope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>left</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>r2</span><span class=p>).</span><span class=nf>Append</span><span class=p>(</span><span class=nx>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>Rope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>left</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>left</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>left</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>Rope</span><span class=p>)</span> <span class=nf>Slice</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>Rope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>r</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>_</span><span class=p>,</span> <span class=nx>r</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This provides us with a fully functioning Rope implementation. It doesn&rsquo;t
support everything we&rsquo;d need to write an editor, but it&rsquo;s a good start that was
quick to write. It is also reasonably simple to extend with more functionality.
For example, you could imagine having an implementation that can rebalance
itself, when operations start taking too long. Or adding traversal, or
random-access unicode support that is still backed by compact UTF-8. And I
found it reasonably simple (though it required some usage of unsafe) to write
an implementation of <code>Base</code> that used an <code>mmap</code>ed file (thus you&rsquo;d only need to
keep the actual edits in RAM, the rest would be read directly from disk with
the OS managing caching for you).</p><h2 id=closing-remarks>Closing remarks<a hidden class=anchor aria-hidden=true href=#closing-remarks>#</a></h2><p>None of these ideas are revolutionary (especially to functional programmers).
But I find that considering if a datastructure I need can be implemented as a
persistent/immutable one helps me to come up with clear abstractions that work
well. And I also believe that Go&rsquo;s interfaces provide a good way to express
these abstractions - because they allow you to start with a simple, immutable
implementation and then compose it with mutable ones - if and only if there are
clear efficiency benefits. Lastly, I think there is an interesting idea here of
how to substitute sum-types by interfaces - not in a direct manner, but instead
by thinking about the common behavior you want to provide over the sum.</p><p>I hope you find that this inspires you to think differently about these problems too.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a><a href=https://bookwyrm.social/user/Merovius target=_blank rel="noopener noreferrer me" title=BookWyrm><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>