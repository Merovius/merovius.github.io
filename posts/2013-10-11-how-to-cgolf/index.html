<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to C-Golf | Mero's Blog</title><meta name=keywords content="C,programming"><meta name=description content="We had a codegolf challenge recently. My C-solution was 246 byte, the perl-winner was 191. I decided to give notes for C-golf beginners."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2013-10-11-how-to-cgolf/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f05a1c2e6a80eb4940c12054260e86cca78c7d0fe0e47ea390db536920db05a7.css integrity="sha256-8FocLmqA60lAwSBUJg6GzKeMfQ/g5H6jkNtTaSDbBac=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel="preload stylesheet" href=https://blog.merovius.de/css/syntax.min.feec697016b5166ca8c6e23d68f6e97fcacd1fbd04d381a0639b2744f1a938c425d47396956cb5a7c9fcaf13d419675574dd51278b1ffcc0dc88e503b65c2785.css integrity="sha512-/uxpcBa1FmyoxuI9aPbpf8rNH70E04GgY5snRPGpOMQl1HOWlWy1p8n8rxPUGWdVdN1RJ4sf/MDciOUDtlwnhQ=="><meta property="og:title" content="How to C-Golf"><meta property="og:description" content="We had a codegolf challenge recently. My C-solution was 246 byte, the perl-winner was 191. I decided to give notes for C-golf beginners."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2013-10-11-how-to-cgolf/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-10-11T02:09:38+00:00"><meta property="article:modified_time" content="2013-10-11T02:09:38+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to C-Golf"><meta name=twitter:description content="We had a codegolf challenge recently. My C-solution was 246 byte, the perl-winner was 191. I decided to give notes for C-golf beginners."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"How to C-Golf","item":"https://blog.merovius.de/posts/2013-10-11-how-to-cgolf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to C-Golf","name":"How to C-Golf","description":"We had a codegolf challenge recently. My C-solution was 246 byte, the perl-winner was 191. I decided to give notes for C-golf beginners.","keywords":["C","programming"],"articleBody":"tl;dr: We had a codegolf challenge recently. My C-solution was 246 byte, the perl-winner was 191. I decided to give notes for C-golf beginners\nNote: Most of this blog post is incredibly boring. A better way than to read through it is to just skip through the git-repository and refer to the explanations here everytime you don’t know why a change works or what it does. To make this easier, I added ankers to every paragraph, named by the commit of the change it explains. So if you want to know, how a specific change works, you can add #commitid to the url of this post, with commitid being the full id of that change. If you want to read the more interesting stuff, from about here it starts to get non-obvious I think.\nAt the rgb2rv10 we again had a codegolf event. C is generally not a preferred language for golf, but I use it, because I know it best and my experiences with it are not that bad. My C solutions are most of the times longer then the shortest solutions in perl or similar languages, but they are competitive. That’s why I decided to make a blogpost explaining this years C solution as an example to show some basic C-golfing techniques.\nThis years challenge was to implement an interpreter for esocalc, a two-dimensional language for arithmetic expressions. Follow the link for a more detailed specification. This challenge is primed to be solved in C. This is also reflected by the length of the different solutions: The shortest C solution is 246 bytes, the shortest Python solution is 227 and the shortest Perl solution is 191 bytes. For a codegolf-challenge this is an impressively small gap between C and scripting languages.\nYou can follow this post by checking out the code on github. The oldest commit is the one we are starting with and we will refine it until we reach the 246 byte solution in master. You can test it by compiling it (gcc -o golf golf.c should suffice in most cases, the shortest needs a longer commandline, which is put in the Makefile, so you should make it). You can run it through the testsuite used in the contest by running GOLF_BIN=\"./golf prove -l\".\n The first step is to implement an easily readable, working version. This is done in the first commit. Though you yourself might have come up with a different implementation, this is pretty straightforward I think. We just read the whole esocalc-sourcecode and walk through it, executing every instruction as we go. The stack is statically allocated and of a fixed size, but that’s no problem because we only have a limited testsuite anyway.\n The next step is obvious: We remove comments and move to one-letter variable names, thus reducing readability, but also size considerably. We will leave most of the whitespace for now, because else it is hard to follow the changes.\n An important lesson for C-golfers is the following: for is never longer then while and most of the times shorter. An endless loop with while takes one character more then a for-loop. We will later see more instances when for will be considerably shorter. Also, we see the if/else-constructs in the control-flow instructions. It is considerably shorter to use a ternary operator in most cases, because in C, most statements are also expressions, so we can write them as cases in ?: - or use the short-circuiting \u0026\u0026 if there is no else-part. We will see more of that later. Lastly we collapse multiple variable declarations into one to save int-keywords. These three changes are what happend in the next version.\n We continue in our path and notice, that we every char-literal takes three bytes, while the number it represents often only takes two in decimal. Let’s fix that.\n We also have two temporary variables a and b, that we shouldn’t need. We can get rid of them, by thinking up a single statement for arithmetic operations.\n The next step uses a real detail of C: If you don’t give a type for a global variable, a parameter or the return type of a function, int is assumed. If a function is not defined, a prototype of int foo() is assumed, meaning we can pass arbitrary arguments and get an int. The libc is linked in by default. All these facts means, we can drop all includes and put our variables in the global scope to remove all int-keywords. This is a very basic, but very usefull technique. It has one important caveat, you should look out for: If you need the return value of a libc-function and it is not int, you should think about wether it can be safely converted. For example on amd64 an int has 32 bits, but a pointer has 64 bits, therefore pointers as return values get truncated (even if you assign them to a pointer).\n We can save more by using a parameter to main. This is also a very basic and often seen trick in C-golfing. You get up to 3 local variables for free this way. In our case there is an additional benefit: The first parameter to main is the number of arguments, which is 1 for a normal call (the first argument is the name with which the programm was called). This means, we get the initialization to 1 for free.\n A trivial optimization is using gets instead of read. gets always adds a terminating zero-byte, so we need to grow our buffer a little bit.\n If we now look at our code, all the case-keywords might annoy us. If we see a lot of repititions in our code, the obvious tool to use in C are defines. So lets define the structure of the cases and replace every case by a short 1-letter identifier.\n The same goes for the arithmetic operations: Four times the same long code cries for a define. A define is not always a good solution. You have to weigh the additional overhead of the keyword and the needed newline against the savings and number of repititions.\n Next we eliminate the variable i. Skilled C-coders use pointer-arithmetic quite often (no matter how bad the reputation is). In this case it would be a bad idea, if we were not explicitely allowed to assume that all programs are correct and stay in the bounds given (because bound-checks are a lot harder without indexing).\n Another example of savings by for-loops is the next change. Here we moved two statements into the for-loop, thus using the semicolons we need there anyway and saving two bytes.\n So the next big thing that catches our eyes are the switch, case and break-keywords. Everytime you see long identifiers or keywords you should think about wether a different program-structure or a different libc-builtin may help you save it. switch-construct can almost always be replaced by an if-else if construct (which is why we learned to use switch anyway). This is often shorter, but as we learned, the ternary operator is even shorter. So in the next step we use a giant ternary expression instead of a switch-structure. This brings one major problem: return is one of the few things that’s a statement, but not an expression. So we can’t use it in ?:-expressions (because the branches have to be expressions). We use exit() instead, which is an expression, but a void-expression, so again we run into problems using it in ?:. We work around that for now by using (exit(0),1) instead. If you connect expressions by , they are evaluated in succession (contrary to using boolean operators for example) and the value of the last one is becoming the value of the whole expression - so our exit-expression evaluates to 1 in this case.\n exit is still pretty long (especially with the added parens and comma-expression), so we want to avoid it too. Here comes a notable quote of the organisator of the competition into action: “The return value isn’t important, as long as the output is correct. So it doesn’t matter if you segfault or anything”. This is the key to the next change: Instead of exiting orderly we just create the conditions for a segfault by assigning zero to p, which is dereferenced shortly thereafter, thus creating a segfault when we want to exit. This is one of my favourite optimizations.\n There still is some repitition in our code. We still assign to d more often then not. But our big nested ternary operator doesn’t return anything yet. So our next step is to return the new value for d in all subexpressions (if need be by using a comma). This does not save a lot, but still a few bytes.\n Now the sources of bytes to save are getting scarcer. What still is a pain is the explicit stack of a fixed size. Here another deep mistery of C (or more specifically the way modern computers work) comes into play: The call stack. We can actually use this as our stack. The way this works is, that we use a pointer to an address in the memory area, the operating system reserved for our call stack and grow down (contrary to the illustration on wikipedia, the stack grows downwards. But this is a minor detail). By writing to this pointer and decrementing, we can push to the stack. By incrementing it and reading we can pop something from the top of the stack. To get a valid stack-address we could use the address of a local variable (for example s itself). Local variables are at the bottom of the stackframe, so we do not overwrite anything important if growing down. There is however a problem: We call gets and printf which push a few stackframes to the callstack. Our stack would get smashed by these calls. Therefore we just subtract a sufficiently high number from it to reserve space for the stackframes of the function calls. 760 is the minimum amount needed in my setup, everything up to 99999 should save at least one byte.\n This still is unsatisfactory, so we will hack a little more and use the fact, that the testsuite only uses quite small programms and a quite small stack is needed. So we just use s unitialized, which is absolutely crazy. I discovered (by accident), that you will always end up with a pointer to your program-array, using around 200 bytes of the end (most probably some earlier deeply nested call in the startup of the binary will write an appropriate address here by accident). This of course is borderline cheating, but it saves 6 bytes, so who cares. From now on it’s absolutely forbidden to compile with optimizations, because this will destroy this coincidence. Oh well.\n So, if we are already doing unreliable horrific voodoo which will curl up the fingernails of every honest C developer, we can also save two bytes by not setting p to zero, but instead just doubling it. You will then end up with some address, that is hard to predict, but in all cases I tried leads to crashing just as reliable. This means, we exit our program in just one byte. Neato!\n There is not a lot we can save left now. What might still annoy us and is a very good tip in general are all this numbers. Even if most characters have only 2 bytes as a decimal, they still only have one byte as a character (not a char-literal!). We can fix this by passing a verbatim character as the first argument to the c-makro. To interpret it as a char, we stringify it (with #a) and dereference it (with *#a), getting the first char. This opens a problem: A space is a significant character in the interpreted source code, so we need to use it as an argument. But a space is not significant at that point in the C source code, so we simply can not pass it to our makro. The solution to this is to move the whole ASCII-table. So instead of comparing *p we compare *p+n with n to be choosen. Thus we don’t need to pass a space, but some other char, that is n positions away and everyone is happy. Kind of. We also need to avoid single quotes, double quotes (though we can avoid this by using emtpy string (think about why this works), but too many bytes!!!), parenthesis and chars outside of ASCII (because this will break our C-file). These constrictions make n=3 pretty much the only choice. This means, we have to include a DEL-character in our source-code, but the compiler is quite happy about that (the wiki isn’t, github isn’t, the editor isn’t, but who cares). This is my second most favourite hack.\n Now there is not much left to do. We remove the last char-literal left and remove all non-essential whitespace.\n This leaves us with 253 bytes. To get below 250, we use buildflags instead of defines. Usually such flags are counted by the difference they add to a minimal compiler call needed. In this case, we have a 186 byte C-file (after removing the trailing newline added by vim) and 60 bytes of compiler-flags, totalling 246 bytes.\nI think there still is potential to remove some more characters. Other tools not used here include dispatch tables (which are kind of hard in C, because it lacks an eval, but some variations of the concept still apply) and magic formulas. If the testcases are very limited, some people resort to hardcoding the wanted results and just golf a minimal way to differentiate between what output is wanted. This might be surprising, but in many cases (this included) this will end up being shorter (though I consider it cheating and try to avoid it). We also didn’t do a lot of bit banging. For example using ^ instead of == reverses the check but saves a byte. But I think it is a usefull intro for people who are just learning C and want to dive deeper into the language by golfing.\n","wordCount":"2359","inLanguage":"en","datePublished":"2013-10-11T02:09:38Z","dateModified":"2013-10-11T02:09:38Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2013-10-11-how-to-cgolf/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How to C-Golf</h1><div class=post-meta><span title="2013-10-11 02:09:38 +0000 UTC">October 11, 2013</span></div></header><div class=post-content><p><strong>tl;dr: We had a codegolf challenge recently. My C-solution was 246 byte, the
perl-winner was 191. I decided to give notes for C-golf beginners</strong></p><p><strong>Note:</strong> Most of this blog post is incredibly boring. A better way than to
read through it is to just skip through the git-repository and refer to the
explanations here everytime you don&rsquo;t know why a change works or what it
does. To make this easier, I added ankers to every paragraph, named by the
commit of the change it explains. So if you want to know, how a specific change
works, you can add <code>#commitid</code> to the url of this post, with <code>commitid</code> being
the full id of that change. If you want to read the more interesting
stuff, <a href=#4272ca2a181e8f50c1645b793c7a1338f9ff1502>from about here</a> it starts
to get non-obvious I think.</p><p>At the <a href=http://rgb2r.noname-ev.de/>rgb2rv10</a> we again had a
<a href=https://en.wikipedia.org/wiki/Code_golf>codegolf</a> event. C is generally not a
preferred language for golf, but I use it, because I know it best and my
experiences with it are not that bad. My C solutions are most of the times
longer then the shortest solutions in perl or similar languages, but they are
competitive. That&rsquo;s why I decided to make a blogpost explaining this years C
solution as an example to show some basic C-golfing techniques.</p><p>This years <a href=https://www.noname-ev.de/w/Codegolf/RGB2Rv10>challenge</a> was to
implement an interpreter for esocalc, a two-dimensional language for arithmetic
expressions. Follow the link for a more detailed specification. This challenge
is primed to be solved in C. This is also reflected by the length of the
different solutions: The shortest C solution is 246 bytes, the shortest Python
solution is 227 and the shortest Perl solution is 191 bytes. For a
codegolf-challenge this is an impressively small gap between C and scripting
languages.</p><p>You can follow this post by checking out <a href=https://github.com/Merovius/cgolf>the code</a>
on github. The oldest commit is the one we are starting with and we will refine
it until we reach the 246 byte solution in <code>master</code>. You can test it by
compiling it (<code>gcc -o golf golf.c</code> should suffice in most cases, the shortest
needs a longer commandline, which is put in the Makefile, so you should <code>make</code>
it). You can run it through the testsuite used in the contest by running
<code>GOLF_BIN="./golf prove -l"</code>.</p><p><a id=e3dc46c7c88f740c6b4eb671cd3b987061797529></a>
The first step is to implement an easily readable, working version. This is
done in the
<a href=https://github.com/Merovius/cgolf/blob/e3dc46c7c88f740c6b4eb671cd3b987061797529/golf.c>first commit</a>.
Though you yourself might have come up with a different implementation, this is
pretty straightforward I think. We just read the whole esocalc-sourcecode and
walk through it, executing every instruction as we go. The stack is statically
allocated and of a fixed size, but that&rsquo;s no problem because we only have a
limited testsuite anyway.</p><p><a id=38e6ffceb633615f48d0a9d25a391abf5228c35c></a>
The <a href=https://github.com/Merovius/cgolf/blob/38e6ffceb633615f48d0a9d25a391abf5228c35c/golf.c>next step</a>
is obvious: We remove comments and move to one-letter variable names, thus
reducing readability, but also size considerably. We will leave most of the
whitespace for now, because else it is hard to follow the changes.</p><p><a id=004b45da976b3d1aab23e1b5ed3b9ff87b002895></a>
An important lesson for C-golfers is the following: <em>for is never longer then
while and most of the times shorter</em>. An endless loop with <code>while</code> takes one
character more then a <code>for</code>-loop. We will later see more instances when <code>for</code> will
be considerably shorter. Also, we see the <code>if</code>/<code>else</code>-constructs in the
control-flow instructions. It is considerably shorter to use a ternary operator
in most cases, because in C, most statements are also expressions, so we can
write them as cases in <code>?:</code> - or use the short-circuiting <code>&&</code> if there is no
<code>else</code>-part. We will see more of that later. Lastly we collapse multiple
variable declarations into one to save <code>int</code>-keywords. These three changes are
what happend in <a href=https://github.com/Merovius/cgolf/blob/004b45da976b3d1aab23e1b5ed3b9ff87b002895/golf.c>the next version</a>.</p><p><a id=eb5227716869399d62f12dcfc07c7e42094782b7></a>
We continue in our path and notice, that we every <code>char</code>-literal takes three
bytes, while the number it represents often only takes two in decimal.
<a href=https://github.com/Merovius/cgolf/blob/eb5227716869399d62f12dcfc07c7e42094782b7/golf.c>Let&rsquo;s fix that</a>.</p><p><a id=75625a730875ded009a216887db5455b5105e7e6></a>
We also have two temporary variables <code>a</code> and <code>b</code>, that we shouldn&rsquo;t need.
<a href=https://github.com/Merovius/cgolf/blob/75625a730875ded009a216887db5455b5105e7e6/golf.c>We can get rid of them</a>,
by thinking up a single statement for arithmetic operations.</p><p><a id=f0af3799d6c5ee3c30a1f43dd5c89523f2619759></a>
<a href=https://github.com/Merovius/cgolf/blob/f0af3799d6c5ee3c30a1f43dd5c89523f2619759/golf.c>The next step</a>
uses a real detail of C: If you don&rsquo;t give a type for a global variable, a
parameter or the return type of a function, <code>int</code> is assumed. If a function is
not defined, a prototype of <code>int foo()</code> is assumed, meaning we can pass
arbitrary arguments and get an <code>int</code>. The libc is linked in by default. All
these facts means, we can drop all <code>include</code>s and put our variables in the
global scope to remove all <code>int</code>-keywords. This is a very basic, but very
usefull technique. It has one important caveat, you should look out for: If you
need the return value of a libc-function and it is <em>not</em> <code>int</code>, you should
think about wether it can be safely converted. For example on amd64 an <code>int</code>
has 32 bits, but a pointer has 64 bits, therefore pointers as return values get
truncated (even if you assign them to a pointer).</p><p><a id=17f305a0091651c03bb9e86e6ee9332f72138c04></a>
<a href=https://github.com/Merovius/cgolf/blob/17f305a0091651c03bb9e86e6ee9332f72138c04/golf.c>We can save more</a>
by using a parameter to <code>main</code>. This is also a very basic and often seen trick
in C-golfing. You get up to 3 local variables for free this way. In our case
there is an additional benefit: The first parameter to <code>main</code> is the number of
arguments, which is 1 for a normal call (the first argument is the name with
which the programm was called). This means, we get the initialization to 1 for
free.</p><p><a id=f3957253031431ec25f8d4f68c10ca1b4dcfd4ed></a>
<a href=https://github.com/Merovius/cgolf/blob/f3957253031431ec25f8d4f68c10ca1b4dcfd4ed/golf.c>A trivial optimization</a>
is using <code>gets</code> instead of <code>read</code>. <code>gets</code> always adds a terminating zero-byte,
so we need to grow our buffer a little bit.</p><p><a id=https://github.com/Merovius/cgolf/blob/fed1a817b88072dc5d27d8ae4dc772da8518ee5d></a>
If we now look at our code, all the <code>case</code>-keywords might annoy us. If we see
a lot of repititions in our code, the obvious tool to use in C are <code>define</code>s. So
<a href=https://github.com/Merovius/cgolf/blob/fed1a817b88072dc5d27d8ae4dc772da8518ee5d/golf.c>lets define</a>
the structure of the cases and replace every case by a short 1-letter identifier.</p><p><a id=9de0b6f05fc52e5c08829bcf6d60a83c6756fba2></a>
The same goes for the arithmetic operations: Four times the same long code cries
for a <a href=https://github.com/Merovius/cgolf/blob/9de0b6f05fc52e5c08829bcf6d60a83c6756fba2/golf.c>define</a>.
A <code>define</code> is not always a good solution. You have to weigh the additional
overhead of the keyword and the needed newline against the savings and number
of repititions.</p><p><a id=ec654b1a11012a7820807cd29fe65a6427f300d4></a>
<a href=https://github.com/Merovius/cgolf/blob/ec654b1a11012a7820807cd29fe65a6427f300d4/golf.c>Next</a>
we eliminate the variable <code>i</code>. Skilled C-coders use pointer-arithmetic quite
often (no matter how bad the reputation is). In this case it would be a bad
idea, if we were not explicitely allowed to assume that all programs are
correct and stay in the bounds given (because bound-checks are a lot harder
without indexing).</p><p><a id=6a10cb1480e1ca6cdc61bd628d8cb2f4d365a699></a>
Another example of savings by <code>for</code>-loops is
<a href=https://github.com/Merovius/cgolf/blob/6a10cb1480e1ca6cdc61bd628d8cb2f4d365a699/golf.c>the next change</a>.
Here we moved two statements into the <code>for</code>-loop, thus using the semicolons we
need there anyway and saving two bytes.</p><p><a id=7d506e18324daf3d6d98e25682321c19c7bef781></a>
So the next big thing that catches our eyes are the <code>switch</code>, <code>case</code> and
<code>break</code>-keywords. Everytime you see long identifiers or keywords you should
think about wether a different program-structure or a different libc-builtin
may help you save it. <code>switch</code>-construct can almost always be replaced by an
<code>if</code>-<code>else if</code> construct (which is why we learned to use <code>switch</code> anyway). This
is often shorter, but as we learned, the ternary operator is even shorter. So in
<a href=https://github.com/Merovius/cgolf/blob/7d506e18324daf3d6d98e25682321c19c7bef781/golf.c>the next step</a>
we use a giant ternary expression instead of a <code>switch</code>-structure. This brings
one major problem: <code>return</code> is one of the few things that&rsquo;s a statement, but
not an expression. So we can&rsquo;t use it in <code>?:</code>-expressions (because the branches
have to be expressions). We use <code>exit()</code> instead, which is an expression, but a
<code>void</code>-expression, so again we run into problems using it in <code>?:</code>. We work
around that for now by using <code>(exit(0),1)</code> instead. If you connect expressions
by <code>,</code> they are evaluated in succession (contrary to using boolean operators
for example) and the value of the last one is becoming the value of the whole
expression - so our <code>exit</code>-expression evaluates to 1 in this case.</p><p><a id=4272ca2a181e8f50c1645b793c7a1338f9ff1502></a>
<code>exit</code> is still pretty long (especially with the added parens and
comma-expression), so we want to avoid it too. Here comes a notable quote of
the organisator of the competition into action: “The return value isn&rsquo;t
important, as long as the output is correct. So it doesn&rsquo;t matter if you
segfault or anything”. This is the key to
<a href=https://github.com/Merovius/cgolf/blob/4272ca2a181e8f50c1645b793c7a1338f9ff1502/golf.c>the next change</a>:
Instead of exiting orderly we just create the conditions for a segfault by
assigning zero to <code>p</code>, which is dereferenced shortly thereafter, thus creating
a segfault when we want to exit. This is one of my favourite optimizations.</p><p><a id=bb1b73fdfd4be6a75ebc47046af7b9af06ff80fe></a>
There still is some repitition in our code. We still assign to <code>d</code> more often
then not. But our big nested ternary operator doesn&rsquo;t return anything yet. So our
<a href=https://github.com/Merovius/cgolf/blob/bb1b73fdfd4be6a75ebc47046af7b9af06ff80fe/golf.c>next step</a>
is to return the new value for <code>d</code> in all subexpressions (if need be by using a
comma). This does not save a lot, but still a few bytes.</p><p><a id=309465a985f67a8326ab10347b568ef467362b1c></a>
Now the sources of bytes to save are getting scarcer. What still is a pain is
the explicit stack of a fixed size. Here another deep mistery of C (or more
specifically the way modern computers work) comes into play:
<a href=https://en.wikipedia.org/wiki/Call_stack>The call stack</a>. We can actually
<a href=https://github.com/Merovius/cgolf/blob/309465a985f67a8326ab10347b568ef467362b1c/golf.c>use this as our stack</a>.
The way this works is, that we use a pointer to an address in the memory area,
the operating system reserved for our call stack and grow down (contrary to the
illustration on wikipedia, the stack grows downwards. But this is a minor
detail). By writing to this pointer and decrementing, we can push to the stack.
By incrementing it and reading we can pop something from the top of the stack.
To get a valid stack-address we could use the address of a local variable (for
example <code>s</code> itself). Local variables are at the bottom of the stackframe, so we
do not overwrite anything important if growing down. There is however a
problem: We call <code>gets</code> and <code>printf</code> which push a few stackframes to the
callstack. Our stack would get smashed by these calls. Therefore we just
subtract a sufficiently high number from it to reserve space for the
stackframes of the function calls. 760 is the minimum amount needed in my
setup, everything up to 99999 should save at least one byte.</p><p><a id=00afa97fb52ba275f638092118b49b4027261928></a>
This still is unsatisfactory, so we will hack a little more and use the fact,
that the testsuite only uses quite small programms and a quite small stack is
needed. So we just
<a href=https://github.com/Merovius/cgolf/blob/00afa97fb52ba275f638092118b49b4027261928/golf.c>use <code>s</code> unitialized</a>,
which is absolutely crazy. I discovered (by accident), that you will always end
up with a pointer to your program-array, using around 200 bytes of the end
(most probably some earlier deeply nested call in the startup of the binary
will write an appropriate address here by accident). This of course is
borderline cheating, but it saves 6 bytes, so who cares. From now on it&rsquo;s
absolutely forbidden to compile with optimizations, because this will destroy
this coincidence. Oh well.</p><p><a id=e2aafeb23a88abb731d0341610bc84acd285424d></a>
So, if we are already doing unreliable horrific voodoo which will curl up the
fingernails of every honest C developer, we can also
<a href=https://github.com/Merovius/cgolf/blob/e2aafeb23a88abb731d0341610bc84acd285424d/golf.c>save two bytes</a>
by not setting <code>p</code> to zero, but instead just doubling it. You will then end up
with <em>some</em> address, that is hard to predict, but in all cases I tried leads to
crashing just as reliable. This means, we exit our program in just one byte. Neato!</p><p><a id=7b1803ce9fe52c0f57fb804067493bc975dfb3be></a>
There is not a lot we can save left now. What might still annoy us and is a
very good tip in general are all this numbers. Even if most characters have
only 2 bytes as a decimal, they still only have one byte as a character (not a
<code>char</code>-literal!). We can
<a href=https://github.com/Merovius/cgolf/blob/7b1803ce9fe52c0f57fb804067493bc975dfb3be/golf.c>fix this</a>
by passing a verbatim character as the first argument to the <code>c</code>-makro. To
interpret it as a <code>char</code>, we stringify it (with <code>#a</code>) and dereference it (with
<code>*#a</code>), getting the first <code>char</code>. This opens a problem: A space is a
significant character in the interpreted source code, so we need to use it as
an argument. But a space is not significant at that point in the C source code,
so we simply can not pass it to our makro. The solution to this is to move the
whole ASCII-table. So instead of comparing <code>*p</code> we compare <code>*p+n</code> with <code>n</code> to
be choosen. Thus we don&rsquo;t need to pass a space, but some other char, that is
<code>n</code> positions away and everyone is happy. Kind of. We also need to avoid single
quotes, double quotes (though we can avoid this by using emtpy string (think
about why this works), but too many bytes!!!), parenthesis and chars outside of
ASCII (because this will break our C-file). These constrictions make <code>n=3</code>
pretty much the only choice. This means, we have to include a DEL-character in
our source-code, but the compiler is quite happy about that (the wiki isn&rsquo;t,
github isn&rsquo;t, the editor isn&rsquo;t, but who cares). This is my second most favourite hack.</p><p><a id=60a5912baccb94e3e31cc57fe09712b1e7cb0280></a><a id=70da40d21ca8ff3a58e5d2a3a890ff0f44d2ee0c></a>
Now there is not much left to do. We
<a href=https://github.com/Merovius/cgolf/blob/60a5912baccb94e3e31cc57fe09712b1e7cb0280/golf.c>remove the last char-literal left</a> and
<a href=https://github.com/Merovius/cgolf/blob/70da40d21ca8ff3a58e5d2a3a890ff0f44d2ee0c/golf.c>remove all non-essential whitespace</a>.</p><p><a id=09ff6c236827639aad31edec198e97748241c3ea></a>
This leaves us with 253 bytes. To get below 250, we
<a href=https://github.com/Merovius/cgolf/blob/09ff6c236827639aad31edec198e97748241c3ea/Makefile>use buildflags</a>
instead of
<a href=https://github.com/Merovius/cgolf/blob/09ff6c236827639aad31edec198e97748241c3ea/golf.c>defines</a>.
Usually such flags are counted by the difference they add to a minimal compiler
call needed. In this case, we have a 186 byte C-file (after removing the
trailing newline added by vim) and 60 bytes of compiler-flags, totalling 246
bytes.</p><p>I think there still is potential to remove some more characters. Other tools
not used here include
<a href=https://en.wikipedia.org/wiki/Dispatch_table>dispatch tables</a>
(which are kind of hard in C, because it lacks an eval, but some variations of
the concept still apply) and magic formulas. If the testcases are very limited,
some people resort to hardcoding the wanted results and just golf a minimal way
to differentiate between what output is wanted. This might be surprising, but
in many cases (this included) this will end up being shorter (though I consider
it cheating and try to avoid it). We also didn&rsquo;t do a lot of
<a href=https://en.wikipedia.org/wiki/Bit_banging>bit banging</a>. For example using <code>^</code>
instead of <code>==</code> reverses the check but saves a byte. But I think it is a
usefull intro for people who are just learning C and want to dive deeper into
the language by golfing.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/C/>C</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><div class=social-icons><a href=https://twitter.com/TheMerovius target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://chaos.social/@Merovius target=_blank rel="noopener noreferrer me" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg></a><a href=https://github.com/Merovius target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.reddit.com/user/TheMerovius target=_blank rel="noopener noreferrer me" title=Reddit><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="1"><path d="M24 11.779c0-1.459-1.192-2.645-2.657-2.645-.715.0-1.363.286-1.84.746-1.81-1.191-4.259-1.949-6.971-2.046l1.483-4.669 4.016.941-.006.058c0 1.193.975 2.163 2.174 2.163 1.198.0 2.172-.97 2.172-2.163S21.396 2 20.199 2c-.92.0-1.704.574-2.021 1.379l-4.329-1.015c-.189-.046-.381.063-.44.249L11.755 7.82c-2.838.034-5.409.798-7.3 2.025-.474-.438-1.103-.712-1.799-.712-1.465.0-2.656 1.187-2.656 2.646.0.97.533 1.811 1.317 2.271-.052.282-.086.567-.086.857C1.231 18.818 6.039 22 11.95 22s10.72-3.182 10.72-7.093c0-.274-.029-.544-.075-.81.832-.447 1.405-1.312 1.405-2.318zM6.776 13.595c0-.868.71-1.575 1.582-1.575s1.581.707 1.581 1.575-.709 1.574-1.581 1.574-1.582-.706-1.582-1.574zm9.061 4.669c-.797.793-2.048 1.179-3.824 1.179L12 19.44l-.013.003c-1.777.0-3.028-.386-3.824-1.179-.145-.144-.145-.379.0-.523.145-.145.381-.145.526.0.65.647 1.729.961 3.298.961l.013.003.013-.003c1.569.0 2.648-.315 3.298-.962.145-.145.381-.144.526.0.145.145.145.379.0.524zm-.189-3.095c-.872.0-1.581-.706-1.581-1.574s.709-1.575 1.581-1.575 1.581.707 1.581 1.575-.709 1.574-1.581 1.574z"/></svg></a></div></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>