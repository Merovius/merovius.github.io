<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">Mero's Blog</title><link href="https://blog.merovius.de/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/atom.xml"/><updated>2024-05-06T05:23:05+00:00</updated><id>https://blog.merovius.de/</id><author><name>Axel Wagner</name></author><entry><title type="html">Constraining Go type parameter pointers</title><link href="https://blog.merovius.de/posts/2024-05-06-pointer-constraints/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2024-05-06-pointer-constraints/</id><published>2024-05-06T06:47:46+02:00</published><updated>2024-05-06T06:47:46+02:00</updated><content type="html"><![CDATA[<p>Sometimes, you need to be able to constrain a type-parameter with a method, but
that method should be defined on the pointer type. For example, say you want to
parse some bytes using JSON and pass the result to a handler. You might try
to write this as</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Handle</span><span class="p">[</span><span class="nx">M</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshaler</span><span class="p">](</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">M</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">M</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">UnmarshalJSON</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>However, this code does not work. Say you have a type <code>Message</code>, which
implements <code>json.Unmarshaler</code> with a pointer receiver (it needs to use a
pointer receiver, as it needs to be able to modify data):</p>
<ol>
<li>If you try to call <code>Handle[Message]</code>, you get a compiler error
(<a href="https://go.dev/play/p/Iu6rvJ4Ff_K">playground</a>).
That is because <code>Message</code> does not implement <code>json.Unmarshal</code>, only
<code>*Message</code> does.</li>
<li>If you try to call <code>Handle[*Message]</code>, the code panics
(<a href="https://go.dev/play/p/Y8xn9CU11nd">playground</a>),
because <code>var m M</code> creates a <code>*Message</code> and initializes that to <code>nil</code>. You
then call <code>UnmarshalJSON</code> with a <code>nil</code> receiver.</li>
</ol>
<p>Neither of these options work. You really want to rewrite <code>Handle</code>, so that it
says that the <em>pointer</em> to its type parameter implements <code>json.Unmarshaler</code>.
And this is how to do that (<a href="https://go.dev/play/p/YQuGAc4erQh">playground</a>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Unmarshaler</span><span class="p">[</span><span class="nx">M</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">M</span>
</span></span><span class="line"><span class="cl">	<span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshaler</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Handle</span><span class="p">[</span><span class="nx">M</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">PM</span> <span class="nx">Unmarshaler</span><span class="p">[</span><span class="nx">M</span><span class="p">]](</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">M</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">M</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// note: you need PM(&amp;m), as the compiler can not infer (yet) that you can
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// call the method of PM on a pointer to M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">PM</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">).</span><span class="nf">UnmarshalJSON</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content></entry><entry><title type="html">Constraining Complexity in the Generics Design</title><link href="https://blog.merovius.de/posts/2024-01-05_constraining_complexity/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2024-01-05_constraining_complexity/</id><published>2024-01-05T08:19:00+01:00</published><updated>2024-01-05T08:19:00+01:00</updated><content type="html"><![CDATA[<script defer crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<p><em>[2024-01-13: I added <a href="#option-4-delay-constraint-checking-until-instantiation">a section</a> with an option I forgot to put into my talk and thus elided from the initial post as well.]</em></p>
<p>I gave a talk at <a href="https://gophercon.com.au/" title="GopherConAU Website">GopherConAU 2023</a> about a particular problem we encountered when designing generics for Go and what we might do about it.</p>
<p>This blog post is meant as a supplement to that talk.
It mostly reproduces its content, while giving some supplementary information and more detailed explanations where necessary.</p>
<p>So if you prefer to ingest your information from text, then this blog post should serve you well.
If you prefer a talk, <a href="https://www.youtube.com/watch?v=0w4Px-yR8D8" title="Recording of the talk">you can watch the recording</a> and use it to get some additional details in the relevant sections.</p>
<p>The talk (and hence this post) is also a follow-up to <a href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/" title="Previous post: Calculating type sets is harder than you think">a previous blog post of mine</a>.
But I believe the particular explanation I give here should be a bit more approachable and is also more general.
If you have read that post and are just interested in the differences, feel free to skip to <a href="#the-type-parameter-problem">the Type Parameter Problem</a>.</p>
<p>With all that out of the way, let us get into it.</p>
<h2 id="the-problem">The Problem</h2>
<p>If you are using Go generics, you are probably aware that it&rsquo;s possible to constrain type parameters.
This makes sure that a type argument has all the operations that your generic function expects available to it.</p>
<p>One particular way to constrain a type parameter is using <em>union elements</em>, which allow you to say that a type has to be from some list of types.
The most common use of this is to allow you to use Go&rsquo;s operators on a generic parameter:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Allows any type argument that has underlying type int, uint or string.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Ordered</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// As all int, uint and string types support the &gt; operator, our generic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// function can use it:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Another case this would be very useful for would be to allow us to call a method as a fallback:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Stringish</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringish</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">any</span><span class="p">(</span><span class="nx">v</span><span class="p">).(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>However, if we try this, the compiler will complain:</p>
<blockquote>
<p>cannot use fmt.Stringer in union (fmt.Stringer contains methods)</p>
</blockquote>
<p>And if we check <a href="https://go.dev/ref/spec#General_interfaces" title="Go Language Specification: General interfaces">the spec</a>, we find a specific exception for this:</p>
<blockquote>
<p>Implementation restriction: A union (with more than one term) cannot contain the predeclared identifier <code>comparable</code> or interfaces that specify methods, or embed <code>comparable</code> or interfaces that specify methods.</p>
</blockquote>
<p>To explain why this restriction is in place, we will dive into a bit of theory.</p>
<h2 id="some-theory">Some Theory</h2>
<p>You have probably heard about the <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem" title="Wikipedia: P versus NP problem"><strong>P</strong> versus <strong>NP</strong> problem</a>.
It concerns two particular classes of computational problems:</p>
<ul>
<li><strong>P</strong> is the class of problems that can be <em>solved</em> efficiently<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.
An example  of this is multiplication of integers: If I give you two integers, you can write an algorithm that quickly multiplies them.</li>
<li><strong>NP</strong> is the class of problems that can be <em>verified</em> efficiently: If you have a candidate for a solution, you can write an efficient algorithm that verifies it.
An example is factorization: If you give me an integer \(N\) and a prime \(p\), you can efficiently check whether or not it is a factor of \(N\).
You just divide \(N\) by \(p\) and check whether there is any remainder.</li>
</ul>
<p>Every problem in <strong>P</strong> is also in <strong>NP</strong>: If you can efficiently <em>solve</em> a problem, you can also easily <em>verify</em> a solution, by just doing it yourself and comparing the answers.</p>
<p>However, the opposite is not necessarily true.
For example, if I give you an integer \(N\) and tell you to give me a non-trivial factor of it, the best you could probably do is try out all possible candidates until you find one.
This is <em>exponential</em> in the size of the input (an integer with \(k\) digits has on the order of \(10^k\) candidate factors).</p>
<p>We generally assume that there are in fact problems which are in <strong>NP</strong> but not in <strong>P</strong> - but we have not actually <em>proven</em> so.
Doing that is the <strong>P</strong> versus <strong>NP</strong> problem.</p>
<p>While we have not proven that there <em>are</em> such &ldquo;hard&rdquo; problems, we <em>did</em> prove that there are some problems which are &ldquo;at least as hard as any other problem in <strong>NP</strong>&rdquo;.
This means that if you can solve <em>them</em> efficiently, you can solve <em>any</em> problem in <strong>NP</strong> efficiently.
These are called &ldquo;<strong>NP</strong>-hard&rdquo; or &ldquo;<strong>NP</strong>-complete&rdquo;<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>One such problem is the <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" title="Wikipedia: Boolean Patisfiability Problem">Boolean Satisfiability Problem</a>.
It asks you to take in a boolean formula - a composition of some boolean variables, connected with &ldquo;and&rdquo;, &ldquo;or&rdquo; and &ldquo;not&rdquo; operators - and determine an assignment to the variables that makes the formula true.</p>
<p>So, for example, I could ask you to find me a <em>satisfying assignment</em> for this function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(!</span><span class="nx">x</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">z</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>For example, <code>F(true, true, false)</code> is <code>false</code>, so it is not a satisfying assignment.
But <code>F(false, true, false)</code> is <code>true</code>, so that <em>is</em> a satisfying assignment.</p>
<p>It is easy to verify whether any given assignment satisfies your formula - you just substitute all the variables and evaluate it.
But to <em>find</em> one, you probably have to try out all possible inputs.
And for \(n\) variables, you have \(2^n\) different options, so this takes exponential time.</p>
<p>In practice, this means that if you can show that solving a particular problem would allow you to solve SAT, your problem is <em>itself</em> <strong>NP</strong>-hard: It would be at least as hard as solving SAT, which is at least as hard as solving any other <strong>NP</strong> problem.
And as we assume that <strong>NP</strong>≠<strong>P</strong>, this means your problem can probably not be solved efficiently.</p>
<p>The last thing we need to mention is <a href="https://en.wikipedia.org/wiki/Co-NP" title="Wikipedia: co-NP"><strong>co-NP</strong></a>, the class of <em>complements</em> of problems in <strong>NP</strong>.
The complement of a (decision) problem is simply the same problem, with the answer is inverted: You have to answer &ldquo;yes&rdquo; instead of &ldquo;no&rdquo; and vice versa.
And where with <strong>NP</strong>, a &ldquo;yes&rdquo; answer should have an efficiently verifiable proof, with <strong>co-NP</strong>, a &ldquo;no&rdquo; answer should have an efficiently verifiable proof.</p>
<p>Notably, the actual <em>difficulty</em> of solving the problem does not change.
To decide between &ldquo;yes&rdquo; and &ldquo;no&rdquo; is just as hard, you just turn around the answer.
So, in a way, this is a technicality.</p>
<p>A <strong>co-NP</strong> complete problem is simply a problem that is the complement of an <strong>NP</strong> complete problem and as you would expect, it is just as hard and it is at least as hard as any other problem in <strong>co-NP</strong>.</p>
<p>Now, with the theory out of the way, let&rsquo;s look at Go again.</p>
<h2 id="the-type-parameter-problem">The Type Parameter Problem</h2>
<p>When building a Go program, the compiler has to solve a couple of computational problems as well.
For example, it has to be able to answer &ldquo;does a given type argument satisfy a given constraint&rdquo;.
This happens if you instantiate a generic function with a concrete type:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">C</span><span class="p">]()</span> <span class="p">{}</span> <span class="c1">// where C is some constraint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">F</span><span class="p">[</span><span class="kt">int</span><span class="p">]()</span> <span class="c1">// Allowed if and only if int satisfies C.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>This problem is in <strong>P</strong>: The compiler can just evaluate the constraint as if it was a logical formula, with <code>|</code> being an &ldquo;or&rdquo; operator, multiple lines being an &ldquo;and&rdquo; operator and checking if the type argument has the right methods or underlying types on the way.</p>
<p>Another problem it has to be able to solve is whether a given constraint <code>C1</code> <em>implies</em> another constraint <code>C2</code>: Does every type satisfying <code>C1</code> also satisfy <code>C2</code>?
This comes up if you instantiate a generic function <em>with a type parameter</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">C1</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">G</span><span class="p">[</span><span class="nx">T</span><span class="p">]()</span> <span class="c1">// Allowed if and only if C1 implies C2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">G</span><span class="p">[</span><span class="nx">T</span> <span class="nx">C2</span><span class="p">]()</span> <span class="p">{}</span>
</span></span></code></pre></div><p>My claim now is that this problem (which I will call the &ldquo;Type Parameter Problem&rdquo; for the purposes of this post) is <strong>co-NP</strong> complete<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>.</p>
<p>To prove this claim, we <em>reduce</em> SAT to the (complement of the) Type Parameter Problem.
We show that if we <em>had</em> a Go compiler which solves this problem, we can use it so solve the SAT problem as well.
And we do that, by translating an arbitrary boolean formula into a Go program and then check whether it compiles.</p>
<p>On a technical note, we are going to assume that the fomula is in <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form" title="Wikipedia: Conjunctive Normal Form">Conjunctive Normal Form (CNF)</a>:
A list of terms connected with &ldquo;and&rdquo; operators, where each term is a list of (possibly negated) variables connected with &ldquo;or&rdquo; terms.
The example I used above is in CNF and we use it as an example to demonstrate the translation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(!</span><span class="nx">x</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">z</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This assumption may seem like a cheat, but importantly,
<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Conjunctive_normal_form_2" title="Wikipedia: SAT for CNF">SAT is still <strong>NP</strong>-complete with it</a>.</p>
<p>The first step in our reduction is to model our boolean variables.
Every variable can be either true or false and it can appear negated or not negated.
We encode that by defining two interfaces per variable<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>     <span class="c1">// X is assigned &#34;true&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">NotX</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">NotX</span><span class="p">()}</span> <span class="c1">// X is assigned &#34;false&#34;
</span></span></span></code></pre></div><p>This allows us to translate our formula directly, using union elements for &ldquo;or&rdquo; and interface-embedding for &ldquo;and&rdquo;:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Represents (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !z)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Formula</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">NotX</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotZ</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There are, however, two issues with this:</p>
<ol>
<li>A type could have <em>neither</em> of <code>X()</code> and <code>NotX()</code>.</li>
<li>A type could have <em>both</em> of <code>X()</code> and <code>NotX()</code>.</li>
</ol>
<p>This breaks our representation, because a boolean variable always has to be <em>exactly</em> true or false - <a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" title="Wikipedia: Law of excluded middle">it can&rsquo;t be neither and it can&rsquo;t be both</a>.</p>
<p>To address the first point, we define another interface:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">AtLeastOne</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Z</span> <span class="p">|</span> <span class="nx">NotZ</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Any type satisfying <code>AtLeastOne</code> has to assign at least one of true and false to each variable.</p>
<p>Similarly, we define an interface to address the second problem:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Both_X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">X</span><span class="p">;</span> <span class="nx">NotX</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Both_Y</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Y</span><span class="p">;</span> <span class="nx">NotY</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Both_Z</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Z</span><span class="p">;</span> <span class="nx">NotZ</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Both</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Both_X</span> <span class="p">|</span> <span class="nx">Both_Y</span> <span class="p">|</span> <span class="nx">Both_Z</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Any type satisfying <code>Both</code> now assigns both true <em>and</em> false to at least one variable.</p>
<p>To represent a valid, satisfying assignment, a type thus has to</p>
<ol>
<li>satisfy <code>Formula</code></li>
<li>satisfy <code>AtLeastOne</code></li>
<li><em>not</em> satisfy <code>Both</code></li>
</ol>
<p>Now, we ask our compiler to type-check this Go program<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">G</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Both</span><span class="p">]()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span> <span class="nx">Formula</span><span class="p">;</span> <span class="nx">AtLeastOne</span> <span class="p">}]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">G</span><span class="p">[</span><span class="nx">T</span><span class="p">]()</span> <span class="c1">// Allowed if and only if (Formula &amp;&amp; AtLeastOne) =&gt; Both
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>This program should compile, if and only if any type satisfying <code>Formula</code> and <code>AtLeastOne</code> also satisfies <code>Both</code>.
Because we are looking at the <em>complement</em> of SAT, we invert this, to get our final answer:</p>
<pre tabindex="0"><code>    !( (Formula &amp;&amp; AtLeastOne) =&gt;  Both )
&lt;=&gt; !(!(Formula &amp;&amp; AtLeastOne) ||  Both ) // &#34;A =&gt; B&#34; is equivalent to &#34;!A || B&#34;
&lt;=&gt; !(!(Formula &amp;&amp; AtLeastOne  &amp;&amp; !Both)) // De Morgan&#39;s law
&lt;=&gt;     Formula &amp;&amp; AtLeastOne  &amp;&amp; !Both   // Double negation
</code></pre><p>This finishes our reduction: The compiler should reject the program, if and only if the formula has a satisfying assignment.
The Type Parameter Problem is at least as hard as the complement of SAT.</p>
<h2 id="going-forward">Going forward</h2>
<p>So the restriction on methods in union elements is in place, because we are concerned about type checking Go would become a very hard problem if we allowed them.
But that is, of course, a deeply dissatisfying situation.</p>
<p>Our <code>Stringish</code> example would clearly be a very useful constraint - so useful, in fact, that it was used <a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#interface-types-in-union-elements" title="Type Parameter Proposal: Interface types in union elements">an example in the original design doc</a>.
More generally, this restriction prevents us from having a good way to <a href="https://blog.merovius.de/posts/2022-05-23-operator-constraints/" title="Previous post: Operator Constraints">express operator constraints for generic functions and types</a>.
We currently end up writing multiple versions of the same functions, one that uses operators and one that takes functions to do the operations.
This leads to boilerplate and extra API surface<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>.</p>
<p><a href="https://pkg.go.dev/slices" title="Go standard library slices package documentation">The slices package</a> contains a bunch of examples like that (look for the <code>Func</code> suffix to the name):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Uses the == operator. Useful for predeclared types (int, string,…) and
</span></span></span><span class="line"><span class="cl"><span class="c1">// structs/arrays of those.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">Contains</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">E</span><span class="p">,</span> <span class="nx">E</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">E</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uses f. Needed for slices, maps, comparing by pointer-value or other notions
</span></span></span><span class="line"><span class="cl"><span class="c1">// of equality.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">ContainsFunc</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">E</span><span class="p">,</span> <span class="nx">E</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>
</span></span></code></pre></div><p>So we should consider compromises, allowing us to get <em>some</em> of the power of removing this restriction at least.</p>
<h3 id="option-1-ignore-the-problem">Option 1: Ignore the problem</h3>
<p>This might be a surprising option to consider after spending all these words on demonstrating that this problem is hard to solve, but we can at least consider it:
We simply say that a Go compiler has to include <em>some form</em> of (possibly limited) SAT solver and is allowed to just give up after some time, if it can not find a proof that a program is safe.</p>
<p>C++ concepts do this.
A C++ compiler has to determine if one constraint implies another one, when it has to decide which of multiple overloaded generic functions to invoke.
<a href="https://en.cppreference.com/w/cpp/language/constraints#Partial_ordering_of_constraints" title="C++ Reference: Partial ordering of constraints">And it does so using a simple SAT solver</a>.
In particular, if it wants to prove \(P ⇒ Q\), it first converts \(P\) into <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form" title="Wikipedia: Disjunctive Normal Form">Disjunctive Normal Form (DNF)</a> and then convert \(Q\) into <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form" title="Wikipedia: Conjunctive Normal Form">Conjunctive Normal Form (CNF)</a>.</p>
<p>With \(P\) in DNF and \(Q\) in CNF, \(P ⇒ Q\) is easy to prove (and disprove).
But this normalization into DNF or CNF <em>itself</em> requires exponential time in general.
And you can indeed create C++ programs that crash C++ compilers.</p>
<p>Personally, I find all versions of this option very dissatisfying:</p>
<ul>
<li>Leaving the heuristic up to the implementation feels like too much wiggle-room for what makes a valid Go program.</li>
<li>Describing an explicit heuristic in the spec takes up a lot of the complexity budget of the spec.</li>
<li>Allowing the compiler to try and give up after some time feels antithetical to the pride Go takes in fast compilation.</li>
</ul>
<h3 id="option-2-limit-the-expressiveness-of-interfaces">Option 2: Limit the expressiveness of interfaces</h3>
<p>For the interfaces as they exist today, we actually <em>can</em> solve the SAT problem: Any interface can ultimately be represented in the form (with some elements perhaps being empty):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="p">|</span> <span class="err">…</span> <span class="p">|</span> <span class="nx">C</span> <span class="p">|</span> <span class="err">~</span><span class="nx">X</span> <span class="p">|</span> <span class="err">…</span> <span class="p">|</span> <span class="err">~</span><span class="nx">Z</span> <span class="c1">// for some concrete types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">comparable</span>
</span></span><span class="line"><span class="cl">    <span class="nf">M1</span><span class="p">(</span><span class="err">…</span><span class="p">)</span> <span class="p">(</span><span class="err">…</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Mn</span><span class="p">(</span><span class="err">…</span><span class="p">)</span> <span class="p">(</span><span class="err">…</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And it is straight-forward to use this representation to do the kind of inference we need.</p>
<p>This tells us that there are <em>some</em> restrictions we can put on the kinds of interfaces we can write down, while still not running into the kinds of problems discussed in this post.
That&rsquo;s because every such kind of interfaces gives us a restricted <em>sub problem</em> of SAT, which only looks at formulas conforming to some extra restrictions.</p>
<p>One example of such a sub problem we actually used above, where we assumed that our formula is in Conjunctive Normal Form.
Another important such sub problem is the one where the formulas are in <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form" title="Wikipedia: Disjunctive Normal Form"><em>Disjunctive</em> Normal Form</a> instead:
Where we have a list of terms linked with &ldquo;or&rdquo; operators and each term is a list of (possibly negated) variables linked with &ldquo;and&rdquo; operators. For DNF, <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Disjunctive_normal_form" title="Wikipedia: SAT for DNF">the SAT problem is efficiently solvable</a>.</p>
<p>We could take advantage of that by allowing union elements to contain methods - but only if</p>
<ol>
<li>There is exactly one union in the top-level interface.</li>
<li>The interfaces embedded in that union are &ldquo;easy&rdquo; interfaces, i.e. ones we allow today.</li>
</ol>
<p>So, for example</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Stringish</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Allowed: fmt.Stringer and ~string are both allowed today
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Not Allowed: Stringish is not allowed today, so we have more than one level
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Stringish</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">B</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Allowed: Same as A, but we &#34;flattened&#34; it, so each element is an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#34;easy&#34; interface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Not Allowed: Can only have a single union (or must be an &#34;easy&#34; interface)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">comparable</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This restriction makes our interfaces be in DNF, in a sense.
It&rsquo;s just that every &ldquo;variable&rdquo; of our DNF is itself an &ldquo;easy&rdquo; interface.
If we need to solve SAT for one of these, we first solve it on the SAT formula to determine which &ldquo;easy&rdquo; interfaces need to be satisfied and then use our current algorithms to check which of those <em>can</em> be satisfied.</p>
<p>Of course, this restriction is somewhat hard to explain.
But it would allow us to write at least some of the useful programs we want to use this feature for.
And we might find another set of restrictions that are easier to explain but still allow that.</p>
<p>We should probably try to collect some useful programs that we would want to write with this feature and then see, for some restricted interface languages if they allow us to write them.</p>
<h3 id="option-3-make-the-type-checker-conservative">Option 3: Make the type-checker conservative</h3>
<p>For our reduction, we assumed that the compiler should allow the program if <em>and only if</em> it can prove that every type satisfying <code>C1</code> also satisfies <code>C2</code>.</p>
<p>We could allow it to reject some programs that <em>would</em> be valid, though.
Wec could describe an algorithm for determining if <code>C1</code> implies <code>C2</code> that can have false negatives: Rejecting a theoretically safe program, just because it cannot <em>prove</em> that it is safe with that algorithm, requiring you to re-write your program into something it can handle more easily.</p>
<p>Ultimately, this is kind of what a type system does: It gives you a somewhat limited language to write a proof to the compiler that your program is &ldquo;safe&rdquo;, in the sense that it satisfies certain invariants.
And if you accidentally pass a variable of the wrong type - even if your program would still be perfectly valid - you might have to add a conversion or call some function that verifies its invariants, before being allowed to do so.</p>
<p>For this route, we still have to decide <em>which</em> false negatives we are willing to accept though: What is the algorithm the compiler should use?</p>
<p>For some cases, this is trivial.
For example, this should obviously compile:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">StringifyAll</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringish</span><span class="p">](</span><span class="nx">vals</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vals</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Stringify as above. Should be allowed, as T uses the same constraint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// as Stringify.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Stringify</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>But other cases are not as straight forward and require <em>some</em> elaboration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Marshal</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringish</span> <span class="p">|</span> <span class="err">~</span><span class="kt">bool</span> <span class="p">|</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Integer</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Stringish appears in the union of the target constraint.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringish</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Marshal</span><span class="p">[</span><span class="nx">T</span><span class="p">](</span><span class="nx">v</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// string has underlying type string and fmt.Stringer is the Stringish union.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">G</span><span class="p">[</span><span class="nx">T</span> <span class="kt">string</span><span class="p">|</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Marshal</span><span class="p">[</span><span class="nx">T</span><span class="p">](</span><span class="nx">v</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// The method name is just a different representation of fmt.Stringer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">H</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">}](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Marshal</span><span class="p">[</span><span class="nx">T</span><span class="p">](</span><span class="nx">v</span><span class="p">)</span> <span class="p">}</span>
</span></span></code></pre></div><p>These examples are still simple, but they are useful, so should probably be allowed.
But they already show that there is <em>somewhat</em> complex inference needed: Some terms on the left might satisfy some terms on the right, but we can not simply compare them as a subset relation, we actually have to take into account the different cases.</p>
<p>And remember that converting to DNF or CNF takes exponential time, so the simple answer of &ldquo;convert the left side into DNF and the right side into CNF, then check each term individually&rdquo; does not solve our problem.</p>
<p>In practice, this option has a large intersection with the previous one: The algorithm would probably reject programs that use interfaces with too complex a structure on either side, to guarantee that it terminates quickly.
But it would allow us, in principle, to use <em>different</em> restrictions for the left and the right hand side: Allow you to write <em>any</em> interface and only check the structure if you actually use them in a way that would make inference impossible.</p>
<p>We have to decide whether we would find that acceptable though, or whether it seems to confusing in practice.
Describing the algorithm also would take quite a lot of space and complexity budget in the spec.</p>
<h3 id="option-4-delay-constraint-checking-until-instantiation">Option 4: Delay constraint checking until instantiation</h3>
<p>One option I forgot to bring up in my talk is essentially the opposite of the previous one:
We could have the compiler skip checking the constraints of generic function calls in generic functions altogether.
So, for example, this code would be valid:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">G</span><span class="p">[</span><span class="nx">T</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// T constrained on any does not satisfy fmt.Stringer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// But we allow the call anyways, for now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">G</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>To retain type-safety, we would instead check the constraints only when <code>F</code> is <em>instantiated</em> with a concrete type:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">F</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// Valid: time.Duration implements fmt.Stringer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">F</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>          <span class="c1">// Invalid: int does not implement fmt.Stringer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The upside is that this seems very easy to implement.
It means we completely ignore any questions that require us to do inference on &ldquo;sets of all types&rdquo;.
We only ever need to answer whether a specific type satisfies a specific constraint.
Which we know we can do efficiently.</p>
<p>The downside is that this effectively introduces new constraints on the type-parameter of <code>F</code> <em>implicitly</em>.
The signature says that <code>F</code> can be instantiated with <code>any</code> type, but it <em>actually</em> requires a <code>fmt.Stringer</code>.</p>
<p>One consequence of that is that it becomes harder to figure out what type arguments are allowed for a generic function or type.
An instantiation might fail and the only way to understand why is to look into the code of the function you are calling.
Potentially multiple layers of dependency deep.</p>
<p>Another consequence is that it means your program might break because of a seemingly innocuous change in a dependency.
A library author might add a generic call to one of their functions.
Because it only changes the implementation and not the API, they assume that this is a backwards compatible change.
Their tests pass, because none of the types they use in their tests triggers this change in behavior.
So they release a new minor version of their library.
Then you upgrade (perhaps by way of upgrading <em>another</em> library that also depends on it) and your code no longer compiles, because you use a different type - conforming to the actual constraints from the signature, but not the implicit ones several layers of dependency down.</p>
<p>Because of this breakage in encapsulation, Go generics have so far eschewed this idea of delayed constraint checking.
But it is possible that we could find a compromise here:
Check the most common and easy to handle cases statically, while delaying some of the more complex and uncommon ones until instantiation.
Where to draw that line would then be open for discussion.</p>
<p>Personally, just like with Option 1, I dislike this idea. But we should keep it in mind.</p>
<h3 id="future-proofing">Future-proofing</h3>
<p>Lastly, when we talk about this we should keep in mind possible future extensions to the generics design.</p>
<p>For example, there is a proposal by Rog Peppe to <a href="https://github.com/golang/go/issues/45380" title="Go language change proposal: Type switch on parametric types">add a type-switch on type parameters</a>.
The proposal is to add a new type switch syntax for type parameters, where every case has a new constraint and in that branch, you could use the type parameter <em>as if it was further constrained by that</em>.
So, for example, it would allow us to rewrite <code>Stringify</code> without <code>reflect</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringish</span><span class="p">](</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="kd">type</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// T is constrained by Stringish *and* fmt.Stringer. So just fmt.Stringer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Calling String on a fmt.Stringer is allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="err">~</span><span class="kt">string</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// T is consrtained by Stringish *and* ~string. So just ~string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Converting a ~string to string is allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The crux here is, that this proposal allows us to create new, implicit interfaces out of old ones.</p>
<p>If we restrict the structure of our interfaces, these implicit interfaces might violate this structure.
And if we make the type checker more conservative, a valid piece of code might no longer be valid if copied into a type parameter switch, if the implicit constraints would lead to a generic all the compiler can&rsquo;t prove to be safe.</p>
<p>Of course it is impossible to know what extension we <em>really</em> want to add in the future.
But we should at least consider some likely candidates during the discussion.</p>
<h2 id="summary">Summary</h2>
<p>I hope I convinced you that</p>
<ol>
<li>Simply allowing methods in unions would make type-checking Go code <strong>co-NP</strong> hard.</li>
<li>But we might be able to find <em>some</em> compromise that still allows us to do <em>some</em> of the things we want to use this for.</li>
<li>The devil is in the details and we still have to think hard and carefully about those.</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>&ldquo;efficient&rdquo;, in this context, means &ldquo;in polynomial time in the size of the input&rdquo;.</p>
<p>In general, if an input to an algorithm gets larger, the time it needs to run grows.
We can look at how fast this growth is, how long the algorithm takes by the size of the input.
And if that growth is at most polynomial, we consider that &ldquo;efficient&rdquo;, in this context.</p>
<p>In practice, even many polynomial growth functions are too slow for our taste.
But we still make this qualitative distinction in complexity theory.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>The difference between these two terms is that &ldquo;<strong>NP</strong>-hard&rdquo; means &ldquo;at least as difficult than any problem in <strong>NP</strong>&rdquo;.
While &ldquo;<strong>NP</strong>-complete&rdquo; means &ldquo;<strong>NP</strong>-hard and also <em>itself</em> in <strong>NP</strong>&rdquo;.</p>
<p>So an <strong>NP</strong>-hard problem might indeed be <em>even harder</em> than other problems in <strong>NP</strong>, while an <strong>NP</strong>-complete problem is not.</p>
<p>For us, the difference does not really matter.
All problems we talk about are in <strong>NP</strong>.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>If you have read <a href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/" title="Previous post: Calculating type sets is harder than you think">my previous post on the topic</a>, you might notice a difference here.
Previously, I defined <code>NotX</code> as <code>interface{ X() int }</code> and relied on this being mutually exclusive with <code>X</code>: You can&rsquo;t have two methods with the same name but different signatures.</p>
<p>This is one reason I think this proof is nicer than my previous one.
It does not require &ldquo;magical&rdquo; knowledge like that, instead <em>only</em> requiring you to be able to define interfaces with arbitrary method names.
Which is extremely open.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>The other reason I like this proof better than my previous one is that it no longer relies on the abstract problem of &ldquo;proving that a type set is empty&rdquo;.
While the <a href="https://en.wikipedia.org/wiki/Principle_of_explosion" title="Wikipedia: Principle of explosion">principle of explosion</a> is familiar to Mathematicians, it is hard to take its implications seriously if you are not.</p>
<p>Needing to type-check a generic function call is far more obvious as a problem that <em>needs</em> solving and it is easier to find understandable examples.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>And inefficiencies, as calling a method on a type parameter can often be devirtualized and/or inlined.
A <code>func</code> value sometimes can&rsquo;t.
For example if it is stored in a field of a generic type, the compiler is usually unable to prove that it doesn&rsquo;t change at runtime.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Cleanly merge git repositories</title><link href="https://blog.merovius.de/posts/2022-12-08-cleanly-merge-git-repositories/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2022-12-08-cleanly-merge-git-repositories/</id><published>2022-12-08T12:05:00+00:00</published><updated>2022-12-08T12:05:00+00:00</updated><content type="html"><![CDATA[<p><em>Note: If you don&rsquo;t want to read the exposition and explanations and just want
to know the steps I did, scroll to the summary at the bottom.</em></p>
<p>For a couple of years I have (with varying degrees of commitment) participated
in <a href="https://adventofcode.com/">Advent of Code</a>, a yearly programming
competition. It consists of fun little daily challenges. It is great to
exercise your coding muscles and can provide opportunity to learn new languages
and technologies.</p>
<p>So far I have created a separate repository for each year, with a directory
per day. But I decided that I&rsquo;d prefer to have a single repository, containing
my solutions for <em>all</em> years. The main reason is that I tend to write little
helpers that I would like to re-use between years.</p>
<p>When merging the repositories it was important to me to preserve the history
of the individual years as well, though. I googled around for how to do this
and the solutions I found didn&rsquo;t <em>quite</em> work for me. So I thought I should
document my own solution, in case anyone finds it useful.</p>
<p>You can <a href="https://github.com/Merovius/AdventOfCode/network">see the result here</a>.
As you can see, there are four cleanly disjoint branches with separate
histories. They then merge into one single commit.</p>
<p>One neat effect of this is that the merged repository functions as a normal
remote for all the four old repositories. It involves no rewrites of history
and all the previous commits are preserved exactly as-is.  So you can just <code>git pull</code> from this new repository and git will fast-forward the branch.</p>
<h1 id="step-1-prepare-individual-repositories">Step 1: Prepare individual repositories</h1>
<p>First I went through all repositories and prepared them. I wanted to have the
years in individual directories. In theory, it is possible to use
<a href="https://git-scm.com/docs/git-filter-branch">git-filter-repo</a> and similar
tooling to automate this step. For larger projects this might be worth it.</p>
<p>I found it simpler to manually make the changes in the individual repositories
and commit them. In particular, I did not only need to move the files to the
sub directory, I also had to fix up Go module and import paths. Figuring out
how to automate that seemed like a chore. But doing it manually is a quick and
easy <code>sed</code> command.</p>
<p>You can see an example of that
<a href="https://github.com/Merovius/AdventOfCode/commit/8acd4ccd75c3e77cebacad98561bcf23a00e986e">in this commit</a>.
While that link points at the final, merged repository, I created the commit in
the old repository. You can see that a lot of files simply moved. But some also
had additional changes.</p>
<p>You can also see that I left the <code>go.mod</code> in the top-level directory. That was
intentional - I want the final repository to share a single module, so that&rsquo;s
where the <code>go.mod</code> belongs.</p>
<p>After this I was left with four repositories, each of which had all the
solutions in their own subdirectory, with a <code>go.mod</code>/<code>go.sum</code> file with the
shared module path. I tested that all solutions still compile and appeared to
work and moved on.</p>
<h1 id="step-2-prepare-merged-repository">Step 2: Prepare merged repository</h1>
<p>The next step is to create a new repository which can reference commits and
objects in all the other repos. After all, it needs to contain the individual
histories. This is simple by setting the individual repositories as remotes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir ~/src/github.com/Merovius/AdventOfCode
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> ~/src/github.com/Merovius/AdventOfCode
</span></span><span class="line"><span class="cl">$ git init
</span></span><span class="line"><span class="cl">$ git remote add <span class="m">2018</span> ~/src/github.com/Merovius/aoc18
</span></span><span class="line"><span class="cl">$ git remote add <span class="m">2020</span> ~/src/github.com/Merovius/aoc_2020
</span></span><span class="line"><span class="cl">$ git remote add <span class="m">2021</span> ~/src/github.com/Merovius/aoc_2021
</span></span><span class="line"><span class="cl">$ git remote add <span class="m">2022</span> ~/src/github.com/Merovius/aoc_2022
</span></span><span class="line"><span class="cl">$ git fetch --multiple <span class="m">2018</span> <span class="m">2020</span> <span class="m">2021</span> <span class="m">2022</span>
</span></span><span class="line"><span class="cl">$ git branch -a
</span></span><span class="line"><span class="cl">remotes/2018/master
</span></span><span class="line"><span class="cl">remotes/2020/main
</span></span><span class="line"><span class="cl">remotes/2021/main
</span></span><span class="line"><span class="cl">remotes/2022/main
</span></span></code></pre></div><p>One thing worth pointing out is that at this point, the merged <code>AdventOfCode</code>
repository <em>does not have any branches itself</em>. The only existing branches are
<code>remotes/</code> references. This is relevant because we don&rsquo;t want our resulting
histories to share any common ancestor. And because git behaves slightly
differently in an empty repository. A lot of commands operate on <code>HEAD</code> (the
“current branch”), so they have special handling if there is no <code>HEAD</code>.</p>
<h1 id="step-3-create-merge-commit">Step 3: Create merge commit</h1>
<p>A git commit can have an arbitrary number of “parents”:</p>
<ul>
<li>If a commit has zero parents, it is the start of the history. This is what
happens if you run <code>git commit</code> in a fresh repository.</li>
<li>If a commit has exactly one parent, it is a regular commit. This is what
happens when you run <code>git commit</code> normally.</li>
<li>If a parent has more than one parent, it is a merge commit. This is what
happens when you use <code>git merge</code> or merge a pull request in the web UI of a
git hoster (like GitHub or Gitlab).</li>
</ul>
<p>Normally merge commits have two parents - one that is the “main” branch and
one that is being “merged into”. However, git does not really distinguish
between “main” and “merged” branch. And it also allows a branch to have <em>more</em>
than two parents.</p>
<p>We want to create a new commit with four parents: The <code>HEAD</code>s of our four
individual repositories. I expected this to be simple, but:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git merge --allow-unrelated-histories remotes/2018/master remotes/2020/main remotes/2021/main remotes/2022/main
</span></span><span class="line"><span class="cl">fatal: Can merge only exactly one commit into empty head
</span></span></code></pre></div><p>This command was supposed to create a merge commit with four parents. We have
to pass <code>--allow-unrelated-histories</code>, as git otherwise tries to find a common
ancestor between the parents and complains if it can&rsquo;t find any.</p>
<p>But the command is failing. It seems git is unhappy using <code>git merge</code> with
multiple parents if we do not have any branch yet.</p>
<p>I suspect the intended path at this point would be to check out one of the
branches and then merge the others into that. But that creates merge conflicts
and it also felt… asymmetric to me. I did not want to give any of the base
repositories preference. So instead I opted for a more brute-force approach:
Dropping down to the
<a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">plumbing layer</a>.</p>
<p>First, I created the merged directory structure:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cp -r ~/src/github.com/Merovius/aoc18/* .
</span></span><span class="line"><span class="cl">$ cp -r ~/src/github.com/Merovius/aoc_2020/* .
</span></span><span class="line"><span class="cl">$ cp -r ~/src/github.com/Merovius/aoc_2021/* .
</span></span><span class="line"><span class="cl">$ cp -r ~/src/github.com/Merovius/aoc_2022/* .
</span></span><span class="line"><span class="cl">$ vim go.mod <span class="c1"># fix up the merged list of dependencies</span>
</span></span><span class="line"><span class="cl">$ go mod tidy
</span></span><span class="line"><span class="cl">$ git add .
</span></span></code></pre></div><p><em>Note: The above does not copy hidden files (like <code>.gitignore</code>). If you do
copy hidden files, take care not to copy any <code>.git</code> directories.</em></p>
<p>At this point the working directory contains the complete directory layout for
the merged commit and it is all in the staging area (or “index”). This is where
we normally run <code>git commit</code>. Instead we do the equivalent steps manually,
allowing us to override the exact contents:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">TREE</span><span class="o">=</span><span class="k">$(</span>git write-tree<span class="k">)</span>
</span></span><span class="line"><span class="cl">$ <span class="nv">COMMIT</span><span class="o">=</span><span class="k">$(</span>git commit-tree <span class="nv">$TREE</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/2018/master <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/2020/main <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/2021/main <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/2022/main <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -m <span class="s2">&#34;merge history of all years&#34;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">$ git branch main <span class="nv">$COMMIT</span>
</span></span></code></pre></div><p>The <code>write-tree</code> command takes the content of the index and writes it to a
<a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects#_tree_objects">“Tree Object”</a>
and then returns a reference to the Tree it has written.</p>
<p>A Tree is an immutable representation of a directory in git. It (essentially)
contains a list of file name and ID pairs, where each ID points either to a
“Blob” (an immutable file) or another Tree.</p>
<p>A Commit in git is just a Tree (describing the state of the files in the
repository at that commit), a list of parents, a commit message and some meta
data (like who created the commit and when).</p>
<p>The <code>commit-tree</code> command is a low-level command to create such a Commit
object. We give it the ID of the Tree the Commit should contain and a list of
parents (using <code>-p</code>) as well as a message (using <code>-m</code>). It then writes out that
Commit to storage and returns its ID.</p>
<p>At this point we have a well-formed Commit, but it is just loosely stored in
the repository. We still need a Branch to point at it, so it doesn&rsquo;t get lost
and we have a memorable handle.</p>
<p>You probably used the <code>git branch</code> command before. In the form above, it
creates a new branch <code>main</code> (remember: So far our repository had no branches)
pointing at the Commit we created.</p>
<p>And that&rsquo;s it. We can now treat the repository as a normal git repo. All that
is left is to publish it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git remote add origin git@github.com:Merovius/AdventOfCode
</span></span><span class="line"><span class="cl">$ git push --set-upstream origin main
</span></span></code></pre></div><h1 id="executive-summary">Executive Summary</h1>
<p>To summarize the steps I did:</p>
<ol>
<li>Create commits in each of the old repositories to move files around and
fixing anticipated merge conflicts as needed.</li>
<li>Create a pristine new repository without any branches:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git init merged
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> merged
</span></span></code></pre></div></li>
<li>Add the old repositories as remotes for the merged repo:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git remote add &lt;repo1&gt; /path/to/repo1
</span></span><span class="line"><span class="cl">$ git fetch repo1
</span></span><span class="line"><span class="cl">$ git remote add &lt;repo2&gt; /path/to/repo2
</span></span><span class="line"><span class="cl">$ git fetch repo2
</span></span><span class="line"><span class="cl">$ <span class="c1"># …</span>
</span></span></code></pre></div></li>
<li>Copy files from old repositories into merged repo:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cp -r /path/to/repo1/* .
</span></span><span class="line"><span class="cl">$ cp -r /path/to/repo2/* .
</span></span><span class="line"><span class="cl">$ <span class="c1"># …</span>
</span></span></code></pre></div></li>
<li>Create commit using plumbing commands:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git add .
</span></span><span class="line"><span class="cl">$ <span class="nv">TREE</span><span class="o">=</span><span class="k">$(</span>git write-tree<span class="k">)</span>
</span></span><span class="line"><span class="cl">$ <span class="nv">COMMIT</span><span class="o">=</span><span class="k">$(</span>git commit-tree <span class="nv">$TREE</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -m <span class="s2">&#34;merge repositories&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/repo1/main <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p remotes/repo2/main<span class="k">)</span>
</span></span><span class="line"><span class="cl">$ git branch main <span class="nv">$COMMIT</span>
</span></span></code></pre></div></li>
</ol>
]]></content></entry><entry><title type="html">Operator constraints in Go</title><link href="https://blog.merovius.de/posts/2022-05-23-operator-constraints/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2022-05-23-operator-constraints/</id><published>2022-05-23T17:34:00+00:00</published><updated>2022-05-23T17:34:00+00:00</updated><content type="html"><![CDATA[<p>Let&rsquo;s say you want to implement a sorting function in Go. Or perhaps a data
structure like a
<a href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a>,
providing ordered access to its elements. Because you want your code to be
re-usable and type safe, you want to use type parameters. So you need a way to
order user-provided types.</p>
<p>There are multiple methods of doing that, with different trade-offs. Let&rsquo;s talk
about four in particular here:</p>
<ol>
<li><code>constraints.Ordered</code></li>
<li>A method constraint</li>
<li>Taking a comparison function</li>
<li>Comparator types</li>
</ol>
<h2 id="constraintsordered"><code>constraints.Ordered</code></h2>
<p>Go 1.18 has a mechanism to constrain a type parameter to all types which have
the <code>&lt;</code> operator defined on them. The types which have this operator are
exactly all types whose underlying type is <code>string</code> or one of the predeclared
integer and float types. So we can write a type set expressing that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Integer</span> <span class="p">|</span> <span class="nx">Float</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Because that&rsquo;s a fairly common thing to want to do,
<a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered">there is already a package which contains these kinds of type sets</a>.</p>
<p>With this, you can write the signature of your sorting function or the
definition of your search tree as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The main advantage of this is that it works directly with predeclared types and
simple types like <code>time.Duration</code>. It also is very clear.</p>
<p>The main disadvantage is that it does not allow composite types like <code>struct</code>s.
And what if a user wants a different sorting order than the one implied by <code>&lt;</code>?
For example if they want to reverse the order or want specialized string
collation. A multimedia library might want to sort “The Expanse” under E. And
some letters sort differently depending on the language setting.</p>
<p><code>constraints.Ordered</code> is simple, but it also is inflexible.</p>
<h2 id="method-constraints">Method constraints</h2>
<p>We can use method constraints to allow more flexibility. This allows a user to
implement whatever sorting order they want as a method on their type.</p>
<p>We can write that constraint like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Less returns if the receiver is less than v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Less</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The type parameter is necessary because we have to refer to the receiver type
itself in the <code>Less</code> method. This is hopefully clearer when we look at how this
is used:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>This allows the user of our library to customize the sorting order by defining
a new type with a <code>Less</code> method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReverseInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">ReverseInt</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">j</span> <span class="nx">ReverseInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="c1">// order is reversed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The disadvantage of this is that it requires some boiler plate on part of your
user. Using a custom sorting order always requires defining a type with a method.</p>
<p>They can&rsquo;t use your code with predeclared types like <code>int</code> or <code>string</code> but
always have to wrap it into a new type.</p>
<p>Likewise if a type already has a natural comparison method but it is not
called <code>Less</code>. For example <code>time.Time</code> is naturally sorted by
<code>time.Time.Before</code>. For cases like that there needs to be a wrapper to rename
the method.</p>
<p>Whenever one of these wrappings happens your user might have to convert back
and forth when passing data to or from your code.</p>
<p>It also is a little bit more confusing than <code>constraints.Ordered</code>, as your user
has to understand the purpose of the extra type parameter on <code>Lesser</code>.</p>
<h2 id="passing-a-comparison-function">Passing a comparison function</h2>
<p>A simple way to get flexibility is to have the user pass us a function used for
comparison directly:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewSearchTree</span><span class="p">(</span><span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Less</span><span class="p">:</span> <span class="nx">less</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This essentially abandons the idea of type constraints altogether. Our code
works with <em>any</em> type and we directly pass around the custom behavior as
<code>func</code>s. Type parameters are only used to ensure that the arguments to those
<code>func</code>s are compatible.</p>
<p>The advantage of this is maximum flexibility. Any type which already has a
<code>Less</code> method like above can simply be used with this directly by using
<a href="https://go.dev/ref/spec#Method_expressions">method expressions</a>. Regardless of
how the method is actually named:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Sort</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nx">Before</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There is also no boilerplate needed to customize sorting behavior:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">1337</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Sort</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="c1">// reversed order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And you can provide helpers for common customizations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Reversed</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">greater</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">less</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This approach is arguably also more correct than the one above because it
decouples the type from the comparison used. If I use a <code>SearchTree</code> as a set
datatype, there is no real reason why the elements in the set would be specific
to the comparison used. It should be “a set of <code>string</code>” not “a set of
<code>MyCustomlyOrderedString</code>”. This reflects the fact that with the method
constraint, we have to convert back-and-forth when putting things into the
container or taking it out again.</p>
<p>The main <em>disadvantage</em> of this approach is that it means you can not have
useful zero values. Your <code>SearchTree</code> type needs the <code>Less</code> field to be
populated to work. So its zero value can not be used to represent an empty set.</p>
<p>You cannot even lazily initialize it (which is a common trick to make types
which need initialization have a useful zero value) because <em>you don&rsquo;t know
what it should be</em>.</p>
<h2 id="comparator-types">Comparator types</h2>
<p>There is a way to pass a function “statically”. That is, instead of passing
around a <code>func</code> value, we can pass it as a type argument. The way to do that is
to attach it as a method to a <code>struct{}</code> type:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;golang.org/x/exp/slices&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntComparator</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">IntComparator</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">1337</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">less</span> <span class="o">:=</span> <span class="nx">IntComparator</span><span class="p">{}.</span><span class="nx">Less</span> <span class="c1">// has type func(int, int) bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">slices</span><span class="p">.</span><span class="nf">SortFunc</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">less</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Based on this, we can devise a mechanism to allow custom comparisons:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Comparator is a helper type used to compare two T values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">a</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">c</span> <span class="nx">C</span>
</span></span><span class="line"><span class="cl">  <span class="nx">less</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Less</span> <span class="c1">// has type func(T, T) bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The <code>~struct{}</code> constraints any implementation of <code>Comparator[T]</code> to have
underlying type <code>struct{}</code>. It is not strictly necessary, but it serves two
purposes here:</p>
<ol>
<li>It makes clear that <code>Comparator[T]</code> itself is not supposed to carry any
state. It only exists to have its method called.</li>
<li>It ensures (as much as possible) that the zero value of <code>C</code> is safe to use.
In particular, <code>Comparator[T]</code> would be a normal interface type. And it
would have a <code>Less</code> method of the right type, so it would implement itself.
But a zero <code>Comparator[T]</code> is <code>nil</code> and would always panic, if its method is
called.</li>
</ol>
<p>An implication of this is that it is not possible to have a <code>Comparator[T]</code>
which uses an arbitrary <code>func</code> value. The <code>Less</code> method can not rely on having
access to a <code>func</code> to call, for this approach to work.</p>
<p>But you can provide other helpers. This can also be used to combine this approach
with the above ones:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LessOperator</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">LessOperator</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LessMethod</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">LessMethod</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Reversed</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">Reversed</span><span class="p">[</span><span class="nx">C</span><span class="p">,</span> <span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">c</span> <span class="nx">C</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The advantage of this approach is that it makes the zero value of
<code>SearchTree[C, T]</code> useful. For example, a <code>SearchTree[LessOperator[int], int]</code>
can be used directly, without extra initialization.</p>
<p>It also carries over the advantage of decoupling the comparison from the
element type, which we got from accepting comparison functions.</p>
<p>One disadvantage is that the comparator can never be inferred. It always has to
be specified in the instantiation explicitly<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. That&rsquo;s similar to how we
always had to pass a <code>less</code> function explicitly above.</p>
<p>Another disadvantage is that this <em>always</em> requires defining a type for
comparisons. Where with the comparison function we could define customizations
(like reversing the order) inline with a <code>func</code> literal, this mechanism always
requires a method.</p>
<p>Lastly, this is arguably too clever for its own good. Understanding the purpose
and idea behind the <code>Comparator</code> type is likely to trip up your users when
reading the documentation.</p>
<h2 id="summary">Summary</h2>
<p>We are left with these trade-offs:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>constraints.Ordered</code></th>
<th><code>Lesser[T]</code></th>
<th><code>func(T,T) bool</code></th>
<th><code>Comparator[T]</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Predeclared types</td>
<td>👍</td>
<td>👎</td>
<td>👎</td>
<td>👎</td>
</tr>
<tr>
<td>Composite types</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Custom order</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Reversal helpers</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Type boilerplate</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
<td>👎</td>
</tr>
<tr>
<td>Useful zero value</td>
<td>👍</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
</tr>
<tr>
<td>Type inference</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
<td>👎</td>
</tr>
<tr>
<td>Coupled Type/Order</td>
<td>👎</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Clarity</td>
<td>👍</td>
<td>🤷<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></td>
<td>👍</td>
<td>👎</td>
</tr>
</tbody>
</table>
<p>One thing standing out in this table is that there is no way to <em>both</em> support
predeclared types <em>and</em> support user defined types.</p>
<p>It would be great if there was a way to support multiple of these mechanisms
using the same code. That is, it would be great if we could write something
like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Ordered is a constraint to allow a type to be sorted.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If a Less method is present, it has precedent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span> <span class="p">|</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Unfortunately, allowing this
<a href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/">is harder than one might think</a>.</p>
<p>Until then, you might want to provide multiple APIs to allow your users more
flexibility. The standard library currently seems to be converging on providing
a <code>constraints.Ordered</code> version and a comparison function version.  The latter
gets a <code>Func</code> suffix to the name. See
<a href="https://pkg.go.dev/golang.org/x/exp/slices">the experimental <code>slices</code> package</a>
for an example.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Though as we put the <code>Comparator[T]</code> type parameter first, we can infer
<code>T</code> from the <code>Comparator</code>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>It&rsquo;s a <em>little</em> bit worse, but probably fine.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Calculating type sets is harder than you think</title><link href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/</id><published>2022-05-16T09:33:10+00:00</published><updated>2022-05-16T09:33:10+00:00</updated><content type="html"><![CDATA[<script defer crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<p>Go 1.18 added the biggest and probably one of the most requested features of
all time to the language: <a href="https://go.dev/doc/go1.18#generics">Generics</a>. If
you want a comprehensive introduction to the topic, there are many out there
and I would personally <a href="https://www.youtube.com/watch?v=QP6v-Q5Foek">recommend this talk I gave at the Frankfurt Gopher
Meetup</a>.</p>
<p>This blog post is not an introduction to generics, though. It is about <a href="https://go.dev/ref/spec#Operands">this
sentence from the spec</a>:</p>
<blockquote>
<p>Implementation restriction: A compiler need not report an error if an
operand&rsquo;s type is a type parameter with an empty type set.</p>
</blockquote>
<p>As an example, consider this interface:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nf">M</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This constraint can never be satisfied. It says that a type has to be <em>both</em>
the predeclared type <code>int</code> <em>and</em> have a method <code>M()</code>. But predeclared
types in Go do not have any methods. So there is no type satisfying <code>C</code> and its
type set is empty.
<a href="https://go.dev/play/p/36pFPhJKGxl">The compiler accepts it just fine</a>, though.
That is what this clause from the spec is about.</p>
<p>This decision might seem strange to you. After all, if a type set is empty,
it would be very helpful to report that to the user. They obviously made a
mistake - an empty type set can never be used as a constraint. A function using
it could never be instantiated.</p>
<p>I want to explain why that sentence is there and also go into a couple of
related design decisions of the generics design. I&rsquo;m trying to be expansive in
my explanation, which means that you should not need any special knowledge to
understand it. It also means, some of the information might be boring to you -
feel free to skip the corresponding sections.</p>
<p>That sentence is in the Go spec because it turns out to be hard to determine if
a type set is empty. Hard enough, that the Go team did not want to require an
implementation to solve that. Let&rsquo;s see why.</p>
<h2 id="p-vs-np">P vs. NP</h2>
<p>When we talk about whether or not a problem is hard, we often group problems
into two big classes:</p>
<ol>
<li>Problems which can be <em>solved</em> reasonably efficiently. This class is called
P.</li>
<li>Problems which can be <em>verified</em> reasonably efficiently. This class is called
NP.</li>
</ol>
<p>The first obvious follow up question is “what does ‘reasonably efficient’
mean?”. The answer to that is “there is an algorithm with a running time
polynomial in its input size”<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>The second obvious follow up question is “what&rsquo;s the difference between
‘solving’ and ‘verifying’?”.</p>
<p><em>Solving</em> a problem means what you think it means: Finding a solution. If I
give you a number and ask you to solve the factorization problem, I&rsquo;m asking
you to find a (non-trivial) factor of that number.</p>
<p><em>Verifying</em> a problem means that I give you a solution and I&rsquo;m asking you if the
solution is correct. For the factorization problem, I&rsquo;d give you two numbers
and ask you to verify that the second is a factor of the first.</p>
<p>These two things are often very different in difficulty. If I ask you to give
me a factor of 297863737, you probably know no better way than to sit down and
try to divide it by a lot of numbers and see if it comes out evenly. But if I
ask you to verify that 9883 is a factor of that number, you just have to do a
bit of long division and it either divides it, or it does not.</p>
<p>It turns out, that every problem which is efficiently <em>solvable</em> is also
efficiently <em>verifiable</em>. You can just calculate the solution and compare it to
the given one. So every problem in P is also in NP<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. But it is
<a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">a famously open question</a>
whether the opposite is true - that is, we don&rsquo;t really <em>know</em>, if there are
problems which are hard to solve but easy to verify.</p>
<p>This is hard to know in general. Because us not having <em>found</em> an efficient
algorithm to solve a problem does not mean <em>there is none</em>. But in practice we
usually assume that there are some problems like that.</p>
<p>One fact that helps us talk about hard problems, is that there are some
problems which are <em>as hard as possible</em> in NP. That means we were able to
prove that if you can solve one of these problems you can use that to solve
<em>any other problem in NP</em>. These problems are called “NP-complete”.</p>
<p>That is, to be frank, plain magic and explaining it is far beyond my
capabilities. But it helps us to tell if a given problem is hard, by doing it
the other way around. If solving problem X would enable us to solve one of
these NP-complete problems then solving problem X is obviously itself NP-complete
and therefore <em>probably very hard</em>. This is called a “proof by reduction”.</p>
<p>One example of such problem is boolean satisfiability. And it is used very
often to prove a problem is hard.</p>
<h2 id="sat">SAT</h2>
<p>Imagine I give you a boolean function. The function has a bunch of <code>bool</code>
arguments and returns <code>bool</code>, by joining its arguments with logical operators
into a single expression. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">((!</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">)</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If I give you values for these arguments, you can efficiently tell me if the
formula evaluates to <code>true</code> or <code>false</code>. You just substitute them in and
evaluate every operator. For example</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">f</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((!</span><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="p">!</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="p">!</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>  <span class="p">(</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>   <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>   <span class="kc">false</span>
</span></span></code></pre></div><p>This takes at most one step per operator in the expression. So it takes a
<em>linear</em> number of steps in the length of the input, which is very efficient.</p>
<p>But if I <em>only</em> give you the function and ask you to <em>find</em> arguments which
make it return <code>true</code> - or even to find out whether such arguments exist - you
probably have to try out all possible input combinations to see if any of them
does. That&rsquo;s easy for three arguments. But for \(n\) arguments there are
\(2^n\) possible assignments, so it takes <em>exponential</em> time in the number of
arguments.</p>
<p>The problem of finding arguments that makes such a function return <code>true</code> (or
proving that no such arguments exists) is called &ldquo;boolean satisfiability&rdquo; and
it is NP-complete.</p>
<p>It is extremely important <em>in what form</em> the expression is given, though. Some
forms make it pretty easy to solve, while others make it hard.</p>
<p>For example, every expression can be rewritten into what is called a
<a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">“Disjunctive Normal Form” (DNF)</a>.
It is called that because it consists of a series of <em>conjunction</em> (<code>&amp;&amp;</code>)
terms, joined together by <em>disjunction</em> (<code>||</code>) operators<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F_DNF</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span><span class="p">)</span> <span class="o">||</span> <span class="p">(!</span><span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(You can verify that this is the same function as above, by
<a href="https://go.dev/play/p/dCtSs3tf91F">trying out all 8 input combinations</a>)</p>
<p>Each term has a subset of the arguments, possibly negated, joined by
<code>&amp;&amp;</code>. The terms are then joined together using <code>||</code>.</p>
<p>Solving the satisfiability problem for an expression in DNF is easy:</p>
<ol>
<li>Go through the individual terms. <code>||</code> is <code>true</code> if and only if
either of its operands is <code>true</code>. So for each term:
<ul>
<li>If it contains both an argument and its negation (<code>x &amp;&amp; !x</code>) it can never
be <code>true</code>. Continue to the next term.</li>
<li>Otherwise, you can infer valid arguments from the term:
<ul>
<li>If it contains <code>x</code>, then we must pass <code>true</code> for <code>x</code></li>
<li>If it contains <code>!x</code>, then we must pass <code>false</code> for <code>x</code></li>
<li>If it contains neither, then what we pass for <code>x</code> does not matter and
either value works.</li>
</ul>
</li>
<li>The term then evaluates to <code>true</code> with these arguments, so the entire
expression does.</li>
</ul>
</li>
<li>If none of the terms can be made <code>true</code>, the function can never return
<code>true</code> and there is no valid set of arguments.</li>
</ol>
<p>On the other hand, there is also a <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">“Conjunctive Normal Form”
(CNF)</a>. Here, the
expression is a series of <em>disjunction</em> (<code>||</code>) terms, joined together with
<em>conjunction</em> (<code>&amp;&amp;</code>) operators:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F_CNF</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(!</span><span class="nx">x</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(Again, you can <a href="https://go.dev/play/p/0xldLVGqu7m">verify that this is the same function</a>)</p>
<p>For this, the idea of our algorithm does not work. To find a solution, you have
to take <em>all terms</em> into account simultaneously. You can&rsquo;t just tackle them one
by one. In fact, solving satisfiability on CNF (often abbreviated as “CNFSAT”)
is NP-complete<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p><a href="https://en.wikipedia.org/wiki/Functional_completeness">It turns out</a> that
<em>every</em> boolean function can be written as a single expression using only <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>. In particular, every boolean function has a DNF and a CNF.</p>
<p>Very often, when we want to prove a problem is hard, we do so by reducing
CNFSAT to it. That&rsquo;s what we will do for the problem of calculating type sets.
But there is one more preamble we need.</p>
<h2 id="sets-and-satisfiability">Sets and Satisfiability</h2>
<p>There is an important relationship between
<a href="https://en.wikipedia.org/wiki/Set_(mathematics)">sets</a> and boolean functions.</p>
<p>Say we have a type <code>T</code> and a <code>Universe</code> which contains all possible values of
<code>T</code>. If we have a <code>func(T) bool</code>, we can create a set from that, by looking at
all objects for which the function returns <code>true</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">Universe</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">Universe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">s</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This set contains exactly all elements for which <code>f</code> is <code>true</code>. So calculating
<code>f(v)</code> is equivalent to checking <code>s.Contains(v)</code>. And checking if <code>s</code> is empty
is equivalent to checking if <code>f</code> can ever return <code>true</code>.</p>
<p>We can also go the other way around:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>So in a sense <code>func(T) bool</code> and <code>Set[T]</code> are “the same thing”. We can
transform a question about one into a question about the other and back.</p>
<p>As we observed above it is important <em>how</em> a boolean function is given.
To take that into account we have to also convert boolean operators into set
operations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Union(s, t) contains all elements which are in s *or* in t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Union</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Intersect(s, t) contains all elements which are in s *and* in t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Intersect</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Complement(s) contains all elements which are *not* in s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Complement</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And back:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Or creates a function which returns if f or g is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Or</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Union</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// And creates a function which returns if f and g are true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">And</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Intersect</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Not creates a function which returns if f is false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Not</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Complement</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The takeaway from all of this is that constructing a set using <code>Union</code>,
<code>Intersect</code> and <code>Complement</code> is really the same as writing a boolean function
using <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>.</p>
<p>And proving that a set constructed in this way is empty is the same as proving
that a corresponding boolean function is never <code>true</code>.</p>
<p>And because checking that a boolean function is never <code>true</code> is NP-complete, so
is checking if one of the sets constructed like this.</p>
<p>With this, let us look at the specific sets we are interested in.</p>
<h2 id="basic-interfaces-as-type-sets">Basic interfaces as type sets</h2>
<p>Interfaces in Go are used to describe sets of types. For example, the interface</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">X</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Y</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Z</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>is “the set of all types which have a method <code>X()</code> and a method <code>Y()</code> and a
method <code>Z()</code>”.</p>
<p>We can also express set intersection, using <a href="https://go.dev/ref/spec#Embedded_interfaces">interface embedding</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">U</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">S</span>
</span></span><span class="line"><span class="cl">    <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This expresses the intersection of <code>S</code> and <code>T</code> as an interface. Or we can view
the property “has a method <code>X()</code>” as a boolean variable and think of this as
the formula <code>x &amp;&amp; y</code>.</p>
<p>Surprisingly, there is also a limited form of negation. It happens implicitly,
because a type can not have two different methods with the same name.
Implicitly, if a type has a method <code>X()</code> it does <em>not</em> have a method <code>X() int</code> for example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotX</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span></code></pre></div><p>There is a small snag: A type can have <em>neither</em> a method <code>X()</code> <em>nor</em> have a
method <code>X() int</code>. That&rsquo;s why our negation operator is limited. Real boolean
variables are always <em>either</em> <code>true</code> <em>or</em> <code>false</code>, whereas our negation also
allows them to be neither. In mathematics we say that this logic language lacks
<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">the law of the excluded middle</a>
(also called “Tertium Non Datur” - “there is no third”). For this section, that does not matter. But we have to worry about it later.</p>
<p>Because we have intersection and negation, we can express interfaces which
could never be satisfied by any type (i.e. which describe an empty type set):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">interface</span><span class="p">{</span> <span class="nx">X</span><span class="p">;</span> <span class="nx">NotX</span> <span class="p">}</span>
</span></span></code></pre></div><p><a href="https://go.dev/play/p/r4kpXNynscX">The compiler rejects such interfaces</a>. But
how can it do that? Did we not say above that checking if a set is empty is
NP-complete?</p>
<p>The reason this works is that we only have negation and conjunction (<code>&amp;&amp;</code>). So
all the boolean expressions we can build with this language have the form</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">z</span>
</span></span></code></pre></div><p>These expressions are in DNF! We have a term, which contains a couple of
variables - possibly negated - and joins them together using <code>&amp;&amp;</code>. We don&rsquo;t
have <code>||</code>, so there is only a single term.</p>
<p>Solving satisfiability in DNF is easy, as we said. So with the language as we
have described it so far, we can only express type sets which are easy to check
for emptiness.</p>
<h2 id="adding-unions">Adding unions</h2>
<p>Go 1.18 extends the interface syntax. For our purposes, the important addition
is the <code>|</code> operator:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="p">|</span> <span class="nx">B</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This represents the set of all types which are in the <em>union</em> of the type sets
<code>A</code> and <code>B</code> - that is, it is the set of all types which are in <code>A</code> <em>or</em> in <code>B</code>
(or both).</p>
<p>This means our language of expressible formulas now also includes a
<code>||</code>-operator - we have added set unions and set unions are equivalent to
<code>||</code> in the language of formulas. What&rsquo;s more, the form of our formula is now a
<em>conjunctive</em> normal form - every line is a term of <code>||</code> and the lines are
connected by <code>&amp;&amp;</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotX</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Y</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotY</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Z</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Z</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotZ</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">Z</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">NotX</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This is not <em>quite</em> enough to prove NP-completeness though, because of the snag
above. If we want to prove that it is easy, it does not matter that a type can
have neither method. But if we want to prove that it is hard, we really need an
<em>exact</em> equivalence between boolean functions and type sets. So we need to
guarantee that a type has one of our two contradictory methods.</p>
<p>“Luckily”, the <code>|</code> operator gives us a way to fix that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TertiumNonDatur</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Z</span> <span class="p">|</span> <span class="nx">NotZ</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">TertiumNonDatur</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">NotX</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Now any type which could possibly implement <code>S</code> <em>must</em> have either an <code>X()</code> or
an <code>X() int</code> method, because it must implement <code>TertiumNonDatur</code> as well. So
this extra interface helps us to get the law of the excluded middle into our
language of type sets.</p>
<p>With this, checking if a type set is empty is in general as hard as checking if
an arbitrary boolean formula in CNF has no solution. As described above, that
is NP-complete.</p>
<p>Even worse, we want to define which operations are allowed on a type parameter
by saying that it is allowed if every type in a type set supports it. However,
<a href="https://github.com/golang/go/issues/45346#issuecomment-822330394">that check is also NP-complete</a>.</p>
<p>The easy way to prove that is to observe that if a type set is empty, <em>every
operator</em> should be allowed on a type parameter constrained by it. Because any
statement about “every element of the empty set“ is true<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>.</p>
<p>But this would mean that type-checking a generic function would be NP-complete.
If an operator is used, we have to at least check if the type set of its
constraint is empty. Which is NP-complete.</p>
<h2 id="why-do-we-care">Why do we care?</h2>
<p>A fair question is “why do we even care? Surely these cases are super exotic.
In any real program, checking this is trivial”.</p>
<p>That&rsquo;s true, but there are still reasons to care:</p>
<ul>
<li>
<p>Go has the goal of having a fast compiler. And importantly, one which is
guaranteed to be fast <em>for any program</em>. If I give you a Go program, you can
be reasonably sure that it compiles quickly, in a time frame predictable by
the size of the input.</p>
<p>If I <em>can</em> craft a program which compiles slowly - and may take longer than
the lifetime of the universe - this is no longer true.</p>
<p>This is especially important for environments like the Go playground, which
regularly compiles untrusted code.</p>
</li>
<li>
<p>NP complete problems are notoriously hard to debug if they fail.</p>
<p>If you use Linux, you might have occasionally run into a problem where you
accidentally tried installing conflicting versions of some package. And if
so, you might have noticed that your computer first chugged along for a while
and then gave you an unhelpful error message about the conflict. And maybe
you had trouble figuring out which packages declared the conflicting
dependencies.</p>
<p>This is typical for NP complete problems. As an exact solution is often too
hard to compute, they rely on heuristics and randomization and it&rsquo;s hard to
work backwards from a failure.</p>
</li>
<li>
<p>We generally don&rsquo;t want the correctness of a Go program to depend on the
compiler used. That is, a program should not suddenly stop compiling because
you used a different compiler or the compiler was updated to a new Go
version.</p>
<p>But NP-complete problems don&rsquo;t allow us to calculate an exact solution. They
always need some heuristic (even if it is just “give up after a bit”). If we
don&rsquo;t want the correctness of a program to be implementation defined, that
heuristic must become part of the Go language specification. But these
heuristics are very complex to describe. So we would have to spend a lot of
room in the spec for something which does not give us a very large benefit.</p>
</li>
</ul>
<p>Note that Go also decided to restrict the version constraints a <code>go.mod</code> file
can express, <a href="https://research.swtch.com/version-sat">for exactly the same reasons</a>.
Go has a clear priority, not to require too complicated algorithms in its
compilers and tooling. Not because they are hard to implement, but because the
behavior of complicated algorithms also tends to be hard to understand for
humans.</p>
<p>So requiring to solve an NP-complete problem is out of the question.</p>
<h2 id="the-fix">The fix</h2>
<p>Given that there must not be an NP-complete problem in the language
specification and given that Go 1.18 was released, this problem must have
somehow been solved.</p>
<p>What changed is that the language for describing interfaces was limited from
what I described above. <a href="https://go.dev/ref/spec#General_interfaces">Specifically</a></p>
<blockquote>
<p>Implementation restriction: A union (with more than one term) cannot contain
the predeclared identifier <code>comparable</code> or interfaces that specify methods, or
embed <code>comparable</code> or interfaces that specify methods.</p>
</blockquote>
<p>This disallows the main mechanism we used to map formulas to interfaces above.
We can no longer express our <code>TertiumNonDatur</code> type, or the individual <code>|</code>
terms of the formula, as the respective terms specify methods. Without
specifying methods, we can&rsquo;t get our “implicit negation” to work either.</p>
<p>The hope is that this change (among a couple of others) is sufficient to ensure
that we can always calculate type sets accurately. Which means I pulled a bit
of a bait-and-switch: I said that calculating type sets is hard. But as they
were actually released, they <em>might not be</em>.</p>
<p>The reason I wrote this blog post anyways is to explain the <em>kind of problems</em>
that exist in this area. It is easy to say we have solved this problem
<a href="https://www.youtube.com/watch?v=0SYpUSjSgFg">once and for all</a>.</p>
<p>But to be certain, someone should <em>prove</em> this - either by writing a proof that
the problem is still hard or by writing an algorithm which solves it
efficiently.</p>
<p>There are also still discussions about changing the generics design. As one
example, the limitations we introduced to fix all of this made
<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#interface-types-in-union-elements">one of the use cases from the design doc</a>
impossible to express. We might want to tweak the design to allow this use
case. We have to look out in these discussions, so we don&rsquo;t
re-introduce NP-completeness. It took us some time to even detect it
<a href="https://github.com/golang/go/issues/45346">when the union operator was proposed</a>.</p>
<p>And there are other kinds of “implicit negations” in the Go language. For
example, a <code>struct</code> can not have both a field <em>and</em> a method with the same
name. Or being one type implies not being another type (so <code>interface{int}</code>
implicitly negates <code>interface{string}</code>).</p>
<p>All of which is to say that even if the problem might no longer be
NP-complete - I hope that I convinced you it is still more complicated than you
might have thought.</p>
<p>If you want to discuss this further, you can find links to my social media on
the bottom of this site.</p>
<hr>
<p>I want to thank my beta-readers for helping me improve this article.
Namely
<a href="https://github.com/arnehormann">arnehormann</a>,
<a href="https://twitter.com/johanbrandhorst">@johanbrandhorst</a>,
<a href="https://twitter.com/mvdan_">@mvdan_</a>,
<a href="https://twitter.com/_myitcv">@_myitcv</a>,
<a href="https://mobile.twitter.com/readcodesing">@readcodesing</a>,
<a href="https://twitter.com/rogpeppe">@rogpeppe</a> and
<a href="https://twitter.com/zekjur">@zekjur</a>.</p>
<p>They took a frankly unreasonable chunk of time out of their day. And their
suggestions were invaluable.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>It should be pointed out, though, that “polynomial” can still be
extremely inefficient. \(n^{1000}\) still grows extremely fast, but is
polynomial. And for many practical problems, even \(n^3\) is
intolerably slow. But for complicated reasons, there is a qualitatively
important difference between “polynomial” and “exponential”<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> run time. So
you just have to trust me that the distinction makes sense.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>These names might seem strange, by the way. P is easy to explain: It
stands for “polynomial”.</p>
<p>NP doesn&rsquo;t mean “not polynomial” though. It means “non-deterministic
polynomial”. A non-deterministic computer, in this context, is a
hypothetical machine which can run arbitrarily many computations
simultaneously. A program which can be <em>verified</em> efficiently by any
computer can be <em>solved</em> efficiently by a non-deterministic one. It just
tries out all possible solutions at the same time and returns a correct
one.</p>
<p>Thus, being able to verify a problem on a normal computer means being
able to solve it on a non-deterministic one. That is why the two
definitions of NP “verifiable by a classical computer” and “solvable by a
non-deterministic computer” mean the same thing.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>You might complain that it is hard to remember if the “disjunctive normal
form” is a disjunction of conjunctions, or a conjunction of disjunctions -
and that no one can remember which of these means <code>&amp;&amp;</code> and which means <code>||</code>
anyways.</p>
<p>You would be correct.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>You might wonder why we can&rsquo;t just solve CNFSAT by transforming the formula
into DNF and solving that.</p>
<p>The answer is that the transformation can make the formula exponentially
larger. So even though solving the problem on DNF is linear in the size the
DNF formula, that size is <em>exponential</em> in the size of the CNF formula. So
we still use exponential time in the size of the CNF formula.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>This is called <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">the principle of explosion</a>
or “ex falso quodlibet” (“from falsehoold follows anything”).</p>
<p>Many people - including many first year math students - have anxieties and
confusion around this principle and feel that it makes no sense. So I have
little hope that I can make it palatable to you. But it is extremely
important for mathematics to “work” and it really <em>is</em> the most reasonable
way to set things up.</p>
<p>Sorry.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Yes, I know that there are complexity classes between polynomial and
exponential. Allow me the simplification.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry></feed>