<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">programming on Mero's Blog</title><link href="https://blog.merovius.de/tags/programming/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/tags/programming/atom.xml"/><updated>2022-05-23T21:23:25+00:00</updated><id>https://blog.merovius.de/tags/programming/</id><author><name>Axel Wagner</name></author><entry><title type="html">Operator constraints in Go</title><link href="https://blog.merovius.de/posts/2022-05-23-operator-constraints/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2022-05-23-operator-constraints/</id><published>2022-05-23T17:34:00+00:00</published><updated>2022-05-23T17:34:00+00:00</updated><content type="html"><![CDATA[<p>Let&rsquo;s say you want to implement a sorting function in Go. Or perhaps a data
structure like a
<a href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a>,
providing ordered access to its elements. Because you want your code to be
re-usable and type safe, you want to use type parameters. So you need a way to
order user-provided types.</p>
<p>There are multiple methods of doing that, with different trade-offs. Let&rsquo;s talk
about four in particular here:</p>
<ol>
<li><code>constraints.Ordered</code></li>
<li>A method constraint</li>
<li>Taking a comparison function</li>
<li>Comparator types</li>
</ol>
<h2 id="constraintsordered"><code>constraints.Ordered</code></h2>
<p>Go 1.18 has a mechanism to constrain a type parameter to all types which have
the <code>&lt;</code> operator defined on them. The types which have this operator are
exactly all types whose underlying type is <code>string</code> or one of the predeclared
integer and float types. So we can write a type set expressing that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Integer</span> <span class="p">|</span> <span class="nx">Float</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Because that&rsquo;s a fairly common thing to want to do,
<a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered">there is already a package which contains these kinds of type sets</a>.</p>
<p>With this, you can write the signature of your sorting function or the
definition of your search tree as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The main advantage of this is that it works directly with predeclared types and
simple types like <code>time.Duration</code>. It also is very clear.</p>
<p>The main disadvantage is that it does not allow composite types like <code>struct</code>s.
And what if a user wants a different sorting order than the one implied by <code>&lt;</code>?
For example if they want to reverse the order or want specialized string
collation. A multimedia library might want to sort “The Expanse” under E. And
some letters sort differently depending on the language setting.</p>
<p><code>constraints.Ordered</code> is simple, but it also is inflexible.</p>
<h2 id="method-constraints">Method constraints</h2>
<p>We can use method constraints to allow more flexibility. This allows a user to
implement whatever sorting order they want as a method on their type.</p>
<p>We can write that constraint like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Less returns if the receiver is less than v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Less</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The type parameter is necessary because we have to refer to the receiver type
itself in the <code>Less</code> method. This is hopefully clearer when we look at how this
is used:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>This allows the user of our library to customize the sorting order by defining
a new type with a <code>Less</code> method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReverseInt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">ReverseInt</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">j</span> <span class="nx">ReverseInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="c1">// order is reversed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The disadvantage of this is that it requires some boiler plate on part of your
user. Using a custom sorting order always requires defining a type with a method.</p>
<p>They can&rsquo;t use your code with predeclared types like <code>int</code> or <code>string</code> but
always have to wrap it into a new type.</p>
<p>Likewise if a type already has a natural comparison method but it is not
called <code>Less</code>. For example <code>time.Time</code> is naturally sorted by
<code>time.Time.Before</code>. For cases like that there needs to be a wrapper to rename
the method.</p>
<p>Whenever one of these wrappings happens your user might have to convert back
and forth when passing data to or from your code.</p>
<p>It also is a little bit more confusing than <code>constraints.Ordered</code>, as your user
has to understand the purpose of the extra type parameter on <code>Lesser</code>.</p>
<h2 id="passing-a-comparison-function">Passing a comparison function</h2>
<p>A simple way to get flexibility is to have the user pass us a function used for
comparison directly:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewSearchTree</span><span class="p">(</span><span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">SearchTree</span><span class="p">[</span><span class="nx">T</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Less</span><span class="p">:</span> <span class="nx">less</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This essentially abandons the idea of type constraints altogether. Our code
works with <em>any</em> type and we directly pass around the custom behavior as
<code>func</code>s. Type parameters are only used to ensure that the arguments to those
<code>func</code>s are compatible.</p>
<p>The advantage of this is maximum flexibility. Any type which already has a
<code>Less</code> method like above can simply be used with this directly by using
<a href="https://go.dev/ref/spec#Method_expressions">method expressions</a>. Regardless of
how the method is actually named:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Sort</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nx">Before</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There is also no boilerplate needed to customize sorting behavior:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">1337</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Sort</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="c1">// reversed order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And you can provide helpers for common customizations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Reversed</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">greater</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">less</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This approach is arguably also more correct than the one above because it
decouples the type from the comparison used. If I use a <code>SearchTree</code> as a set
datatype, there is no real reason why the elements in the set would be specific
to the comparison used. It should be “a set of <code>string</code>” not “a set of
<code>MyCustomlyOrderedString</code>”. This reflects the fact that with the method
constraint, we have to convert back-and-forth when putting things into the
container or taking it out again.</p>
<p>The main <em>disadvantage</em> of this approach is that it means you can not have
useful zero values. Your <code>SearchTree</code> type needs the <code>Less</code> field to be
populated to work. So its zero value can not be used to represent an empty set.</p>
<p>You cannot even lazily initialize it (which is a common trick to make types
which need initialization have a useful zero value) because <em>you don&rsquo;t know
what it should be</em>.</p>
<h2 id="comparator-types">Comparator types</h2>
<p>There is a way to pass a function “statically”. That is, instead of passing
around a <code>func</code> value, we can pass it as a type argument. The way to do that is
to attach it as a method to a <code>struct{}</code> type:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;golang.org/x/exp/slices&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntComparator</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">IntComparator</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">1337</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">less</span> <span class="o">:=</span> <span class="nx">IntComparator</span><span class="p">{}.</span><span class="nx">Less</span> <span class="c1">// has type func(int, int) bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">slices</span><span class="p">.</span><span class="nf">SortFunc</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">less</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Based on this, we can devise a mechanism to allow custom comparisons:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Comparator is a helper type used to compare two T values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">~</span><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Sort</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">a</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">c</span> <span class="nx">C</span>
</span></span><span class="line"><span class="cl">  <span class="nx">less</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Less</span> <span class="c1">// has type func(T, T) bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchTree</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The <code>~struct{}</code> constraints any implementation of <code>Comparator[T]</code> to have
underlying type <code>struct{}</code>. It is not strictly necessary, but it serves two
purposes here:</p>
<ol>
<li>It makes clear that <code>Comparator[T]</code> itself is not supposed to carry any
state. It only exists to have its method called.</li>
<li>It ensures (as much as possible) that the zero value of <code>C</code> is safe to use.
In particular, <code>Comparator[T]</code> would be a normal interface type. And it
would have a <code>Less</code> method of the right type, so it would implement itself.
But a zero <code>Comparator[T]</code> is <code>nil</code> and would always panic, if its method is
called.</li>
</ol>
<p>An implication of this is that it is not possible to have a <code>Comparator[T]</code>
which uses an arbitrary <code>func</code> value. The <code>Less</code> method can not rely on having
access to a <code>func</code> to call, for this approach to work.</p>
<p>But you can provide other helpers. This can also be used to combine this approach
with the above ones:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LessOperator</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">LessOperator</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LessMethod</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">LessMethod</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Reversed</span><span class="p">[</span><span class="nx">C</span> <span class="nx">Comparator</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">Reversed</span><span class="p">[</span><span class="nx">C</span><span class="p">,</span> <span class="nx">T</span><span class="p">])</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">c</span> <span class="nx">C</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The advantage of this approach is that it makes the zero value of
<code>SearchTree[C, T]</code> useful. For example, a <code>SearchTree[LessOperator[int], int]</code>
can be used directly, without extra initialization.</p>
<p>It also carries over the advantage of decoupling the comparison from the
element type, which we got from accepting comparison functions.</p>
<p>One disadvantage is that the comparator can never be inferred. It always has to
be specified in the instantiation explicitly<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. That&rsquo;s similar to how we
always had to pass a <code>less</code> function explicitly above.</p>
<p>Another disadvantage is that this <em>always</em> requires defining a type for
comparisons. Where with the comparison function we could define customizations
(like reversing the order) inline with a <code>func</code> literal, this mechanism always
requires a method.</p>
<p>Lastly, this is arguably too clever for its own good. Understanding the purpose
and idea behind the <code>Comparator</code> type is likely to trip up your users when
reading the documentation.</p>
<h2 id="summary">Summary</h2>
<p>We are left with these trade-offs:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>constraints.Ordered</code></th>
<th><code>Lesser[T]</code></th>
<th><code>func(T,T) bool</code></th>
<th><code>Comparator[T]</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Predeclared types</td>
<td>👍</td>
<td>👎</td>
<td>👎</td>
<td>👎</td>
</tr>
<tr>
<td>Composite types</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Custom order</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Reversal helpers</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Type boilerplate</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
<td>👎</td>
</tr>
<tr>
<td>Useful zero value</td>
<td>👍</td>
<td>👍</td>
<td>👎</td>
<td>👍</td>
</tr>
<tr>
<td>Type inference</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
<td>👎</td>
</tr>
<tr>
<td>Coupled Type/Order</td>
<td>👎</td>
<td>👎</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>Clarity</td>
<td>👍</td>
<td>🤷<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></td>
<td>👍</td>
<td>👎</td>
</tr>
</tbody>
</table>
<p>One thing standing out in this table is that there is no way to <em>both</em> support
predeclared types <em>and</em> support user defined types.</p>
<p>It would be great if there was a way to support multiple of these mechanisms
using the same code. That is, it would be great if we could write something
like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Ordered is a constraint to allow a type to be sorted.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If a Less method is present, it has precedent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span> <span class="p">|</span> <span class="nx">Lesser</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Unfortunately, allowing this
<a href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/">is harder than one might think</a>.</p>
<p>Until then, you might want to provide multiple APIs to allow your users more
flexibility. The standard library currently seems to be converging on providing
a <code>constraints.Ordered</code> version and a comparison function version.  The latter
gets a <code>Func</code> suffix to the name. See
<a href="https://pkg.go.dev/golang.org/x/exp/slices">the experimental <code>slices</code> package</a>
for an example.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Though as we put the <code>Comparator[T]</code> type parameter first, we can infer
<code>T</code> from the <code>Comparator</code>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>It&rsquo;s a <em>little</em> bit worse, but probably fine.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Calculating type sets is harder than you think</title><link href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/" rel="alternate" type="text/html"/><id>https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/</id><published>2022-05-16T09:33:10+00:00</published><updated>2022-05-16T09:33:10+00:00</updated><content type="html"><![CDATA[<script defer crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<p>Go 1.18 added the biggest and probably one of the most requested features of
all time to the language: <a href="https://go.dev/doc/go1.18#generics">Generics</a>. If
you want a comprehensive introduction to the topic, there are many out there
and I would personally <a href="https://www.youtube.com/watch?v=QP6v-Q5Foek">recommend this talk I gave at the Frankfurt Gopher
Meetup</a>.</p>
<p>This blog post is not an introduction to generics, though. It is about <a href="https://go.dev/ref/spec#Operands">this
sentence from the spec</a>:</p>
<blockquote>
<p>Implementation restriction: A compiler need not report an error if an
operand&rsquo;s type is a type parameter with an empty type set.</p>
</blockquote>
<p>As an example, consider this interface:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nf">M</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This constraint can never be satisfied. It says that a type has to be <em>both</em>
the predeclared type <code>int</code> <em>and</em> have a method <code>M()</code>. But predeclared
types in Go do not have any methods. So there is no type satisfying <code>C</code> and its
type set is empty.
<a href="https://go.dev/play/p/36pFPhJKGxl">The compiler accepts it just fine</a>, though.
That is what this clause from the spec is about.</p>
<p>This decision might seem strange to you. After all, if a type set is empty,
it would be very helpful to report that to the user. They obviously made a
mistake - an empty type set can never be used as a constraint. A function using
it could never be instantiated.</p>
<p>I want to explain why that sentence is there and also go into a couple of
related design decisions of the generics design. I&rsquo;m trying to be expansive in
my explanation, which means that you should not need any special knowledge to
understand it. It also means, some of the information might be boring to you -
feel free to skip the corresponding sections.</p>
<p>That sentence is in the Go spec because it turns out to be hard to determine if
a type set is empty. Hard enough, that the Go team did not want to require an
implementation to solve that. Let&rsquo;s see why.</p>
<h2 id="p-vs-np">P vs. NP</h2>
<p>When we talk about whether or not a problem is hard, we often group problems
into two big classes:</p>
<ol>
<li>Problems which can be <em>solved</em> reasonably efficiently. This class is called
P.</li>
<li>Problems which can be <em>verified</em> reasonably efficiently. This class is called
NP.</li>
</ol>
<p>The first obvious follow up question is “what does ‘reasonably efficient’
mean?”. The answer to that is “there is an algorithm with a running time
polynomial in its input size”<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>The second obvious follow up question is “what&rsquo;s the difference between
‘solving’ and ‘verifying’?”.</p>
<p><em>Solving</em> a problem means what you think it means: Finding a solution. If I
give you a number and ask you to solve the factorization problem, I&rsquo;m asking
you to find a (non-trivial) factor of that number.</p>
<p><em>Verifying</em> a problem means that I give you a solution and I&rsquo;m asking you if the
solution is correct. For the factorization problem, I&rsquo;d give you two numbers
and ask you to verify that the second is a factor of the first.</p>
<p>These two things are often very different in difficulty. If I ask you to give
me a factor of 297863737, you probably know no better way than to sit down and
try to divide it by a lot of numbers and see if it comes out evenly. But if I
ask you to verify that 9883 is a factor of that number, you just have to do a
bit of long division and it either divides it, or it does not.</p>
<p>It turns out, that every problem which is efficiently <em>solvable</em> is also
efficiently <em>verifiable</em>. You can just calculate the solution and compare it to
the given one. So every problem in P is also in NP<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. But it is
<a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">a famously open question</a>
whether the opposite is true - that is, we don&rsquo;t really <em>know</em>, if there are
problems which are hard to solve but easy to verify.</p>
<p>This is hard to know in general. Because us not having <em>found</em> an efficient
algorithm to solve a problem does not mean <em>there is none</em>. But in practice we
usually assume that there are some problems like that.</p>
<p>One fact that helps us talk about hard problems, is that there are some
problems which are <em>as hard as possible</em> in NP. That means we were able to
prove that if you can solve one of these problems you can use that to solve
<em>any other problem in NP</em>. These problems are called “NP-complete”.</p>
<p>That is, to be frank, plain magic and explaining it is far beyond my
capabilities. But it helps us to tell if a given problem is hard, by doing it
the other way around. If solving problem X would enable us to solve one of
these NP-complete problems then solving problem X is obviously itself NP-complete
and therefore <em>probably very hard</em>. This is called a “proof by reduction”.</p>
<p>One example of such problem is boolean satisfiability. And it is used very
often to prove a problem is hard.</p>
<h2 id="sat">SAT</h2>
<p>Imagine I give you a boolean function. The function has a bunch of <code>bool</code>
arguments and returns <code>bool</code>, by joining its arguments with logical operators
into a single expression. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">((!</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">)</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If I give you values for these arguments, you can efficiently tell me if the
formula evaluates to <code>true</code> or <code>false</code>. You just substitute them in and
evaluate every operator. For example</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">f</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((!</span><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="p">!</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="p">!</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span> <span class="p">((</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>  <span class="p">(</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">)</span> <span class="o">||</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>   <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="err">→</span>   <span class="kc">false</span>
</span></span></code></pre></div><p>This takes at most one step per operator in the expression. So it takes a
<em>linear</em> number of steps in the length of the input, which is very efficient.</p>
<p>But if I <em>only</em> give you the function and ask you to <em>find</em> arguments which
make it return <code>true</code> - or even to find out whether such arguments exist - you
probably have to try out all possible input combinations to see if any of them
does. That&rsquo;s easy for three arguments. But for \(n\) arguments there are
\(2^n\) possible assignments, so it takes <em>exponential</em> time in the number of
arguments.</p>
<p>The problem of finding arguments that makes such a function return <code>true</code> (or
proving that no such arguments exists) is called &ldquo;boolean satisfiability&rdquo; and
it is NP-complete.</p>
<p>It is extremely important <em>in what form</em> the expression is given, though. Some
forms make it pretty easy to solve, while others make it hard.</p>
<p>For example, every expression can be rewritten into what is called a
<a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">“Disjunctive Normal Form” (DNF)</a>.
It is called that because it consists of a series of <em>conjunction</em> (<code>&amp;&amp;</code>)
terms, joined together by <em>disjunction</em> (<code>||</code>) operators<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F_DNF</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span><span class="p">)</span> <span class="o">||</span> <span class="p">(!</span><span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(You can verify that this is the same function as above, by
<a href="https://go.dev/play/p/dCtSs3tf91F">trying out all 8 input combinations</a>)</p>
<p>Each term has a subset of the arguments, possibly negated, joined by
<code>&amp;&amp;</code>. The terms are then joined together using <code>||</code>.</p>
<p>Solving the satisfiability problem for an expression in DNF is easy:</p>
<ol>
<li>Go through the individual terms. <code>||</code> is <code>true</code> if and only if
either of its operands is <code>true</code>. So for each term:
<ul>
<li>If it contains both an argument and its negation (<code>x &amp;&amp; !x</code>) it can never
be <code>true</code>. Continue to the next term.</li>
<li>Otherwise, you can infer valid arguments from the term:
<ul>
<li>If it contains <code>x</code>, then we must pass <code>true</code> for <code>x</code></li>
<li>If it contains <code>!x</code>, then we must pass <code>false</code> for <code>x</code></li>
<li>If it contains neither, then what we pass for <code>x</code> does not matter and
either value works.</li>
</ul>
</li>
<li>The term then evaluates to <code>true</code> with these arguments, so the entire
expression does.</li>
</ul>
</li>
<li>If none of the terms can be made <code>true</code>, the function can never return
<code>true</code> and there is no valid set of arguments.</li>
</ol>
<p>On the other hand, there is also a <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">“Conjunctive Normal Form”
(CNF)</a>. Here, the
expression is a series of <em>disjunction</em> (<code>||</code>) terms, joined together with
<em>conjunction</em> (<code>&amp;&amp;</code>) operators:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">F_CNF</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(!</span><span class="nx">x</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="nx">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(Again, you can <a href="https://go.dev/play/p/0xldLVGqu7m">verify that this is the same function</a>)</p>
<p>For this, the idea of our algorithm does not work. To find a solution, you have
to take <em>all terms</em> into account simultaneously. You can&rsquo;t just tackle them one
by one. In fact, solving satisfiability on CNF (often abbreviated as “CNFSAT”)
is NP-complete<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p><a href="https://en.wikipedia.org/wiki/Functional_completeness">It turns out</a> that
<em>every</em> boolean function can be written as a single expression using only <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>. In particular, every boolean function has a DNF and a CNF.</p>
<p>Very often, when we want to prove a problem is hard, we do so by reducing
CNFSAT to it. That&rsquo;s what we will do for the problem of calculating type sets.
But there is one more preamble we need.</p>
<h2 id="sets-and-satisfiability">Sets and Satisfiability</h2>
<p>There is an important relationship between
<a href="https://en.wikipedia.org/wiki/Set_(mathematics)">sets</a> and boolean functions.</p>
<p>Say we have a type <code>T</code> and a <code>Universe</code> which contains all possible values of
<code>T</code>. If we have a <code>func(T) bool</code>, we can create a set from that, by looking at
all objects for which the function returns <code>true</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">Universe</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">Universe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">s</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This set contains exactly all elements for which <code>f</code> is <code>true</code>. So calculating
<code>f(v)</code> is equivalent to checking <code>s.Contains(v)</code>. And checking if <code>s</code> is empty
is equivalent to checking if <code>f</code> can ever return <code>true</code>.</p>
<p>We can also go the other way around:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>So in a sense <code>func(T) bool</code> and <code>Set[T]</code> are “the same thing”. We can
transform a question about one into a question about the other and back.</p>
<p>As we observed above it is important <em>how</em> a boolean function is given.
To take that into account we have to also convert boolean operators into set
operations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Union(s, t) contains all elements which are in s *or* in t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Union</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Intersect(s, t) contains all elements which are in s *and* in t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Intersect</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Complement(s) contains all elements which are *not* in s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Complement</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Set</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And back:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Or creates a function which returns if f or g is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Or</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Union</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// And creates a function which returns if f and g are true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">And</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Intersect</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nf">MakeSet</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Not creates a function which returns if f is false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Not</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">MakeFunc</span><span class="p">(</span><span class="nf">Complement</span><span class="p">(</span><span class="nf">MakeSet</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The takeaway from all of this is that constructing a set using <code>Union</code>,
<code>Intersect</code> and <code>Complement</code> is really the same as writing a boolean function
using <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>.</p>
<p>And proving that a set constructed in this way is empty is the same as proving
that a corresponding boolean function is never <code>true</code>.</p>
<p>And because checking that a boolean function is never <code>true</code> is NP-complete, so
is checking if one of the sets constructed like this.</p>
<p>With this, let us look at the specific sets we are interested in.</p>
<h2 id="basic-interfaces-as-type-sets">Basic interfaces as type sets</h2>
<p>Interfaces in Go are used to describe sets of types. For example, the interface</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">X</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Y</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Z</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>is “the set of all types which have a method <code>X()</code> and a method <code>Y()</code> and a
method <code>Z()</code>”.</p>
<p>We can also express set intersection, using <a href="https://go.dev/ref/spec#Embedded_interfaces">interface embedding</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">U</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">S</span>
</span></span><span class="line"><span class="cl">    <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This expresses the intersection of <code>S</code> and <code>T</code> as an interface. Or we can view
the property “has a method <code>X()</code>” as a boolean variable and think of this as
the formula <code>x &amp;&amp; y</code>.</p>
<p>Surprisingly, there is also a limited form of negation. It happens implicitly,
because a type can not have two different methods with the same name.
Implicitly, if a type has a method <code>X()</code> it does <em>not</em> have a method <code>X() int</code> for example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotX</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span></code></pre></div><p>There is a small snag: A type can have <em>neither</em> a method <code>X()</code> <em>nor</em> have a
method <code>X() int</code>. That&rsquo;s why our negation operator is limited. Real boolean
variables are always <em>either</em> <code>true</code> <em>or</em> <code>false</code>, whereas our negation also
allows them to be neither. In mathematics we say that this logic language lacks
<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">the law of the excluded middle</a>
(also called “Tertium Non Datur” - “there is no third”). For this section, that does not matter. But we have to worry about it later.</p>
<p>Because we have intersection and negation, we can express interfaces which
could never be satisfied by any type (i.e. which describe an empty type set):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">interface</span><span class="p">{</span> <span class="nx">X</span><span class="p">;</span> <span class="nx">NotX</span> <span class="p">}</span>
</span></span></code></pre></div><p><a href="https://go.dev/play/p/r4kpXNynscX">The compiler rejects such interfaces</a>. But
how can it do that? Did we not say above that checking if a set is empty is
NP-complete?</p>
<p>The reason this works is that we only have negation and conjunction (<code>&amp;&amp;</code>). So
all the boolean expressions we can build with this language have the form</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">z</span>
</span></span></code></pre></div><p>These expressions are in DNF! We have a term, which contains a couple of
variables - possibly negated - and joins them together using <code>&amp;&amp;</code>. We don&rsquo;t
have <code>||</code>, so there is only a single term.</p>
<p>Solving satisfiability in DNF is easy, as we said. So with the language as we
have described it so far, we can only express type sets which are easy to check
for emptiness.</p>
<h2 id="adding-unions">Adding unions</h2>
<p>Go 1.18 extends the interface syntax. For our purposes, the important addition
is the <code>|</code> operator:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="p">|</span> <span class="nx">B</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This represents the set of all types which are in the <em>union</em> of the type sets
<code>A</code> and <code>B</code> - that is, it is the set of all types which are in <code>A</code> <em>or</em> in <code>B</code>
(or both).</p>
<p>This means our language of expressible formulas now also includes a
<code>||</code>-operator - we have added set unions and set unions are equivalent to
<code>||</code> in the language of formulas. What&rsquo;s more, the form of our formula is now a
<em>conjunctive</em> normal form - every line is a term of <code>||</code> and the lines are
connected by <code>&amp;&amp;</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">X</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotX</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">X</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Y</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotY</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">Y</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Z</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Z</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NotZ</span> <span class="kd">interface</span><span class="p">{</span> <span class="nf">Z</span><span class="p">()</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">NotX</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This is not <em>quite</em> enough to prove NP-completeness though, because of the snag
above. If we want to prove that it is easy, it does not matter that a type can
have neither method. But if we want to prove that it is hard, we really need an
<em>exact</em> equivalence between boolean functions and type sets. So we need to
guarantee that a type has one of our two contradictory methods.</p>
<p>“Luckily”, the <code>|</code> operator gives us a way to fix that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TertiumNonDatur</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Z</span> <span class="p">|</span> <span class="nx">NotZ</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">S</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">TertiumNonDatur</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">NotX</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Y</span> <span class="p">|</span> <span class="nx">Z</span>
</span></span><span class="line"><span class="cl">    <span class="nx">X</span> <span class="p">|</span> <span class="nx">NotY</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Now any type which could possibly implement <code>S</code> <em>must</em> have either an <code>X()</code> or
an <code>X() int</code> method, because it must implement <code>TertiumNonDatur</code> as well. So
this extra interface helps us to get the law of the excluded middle into our
language of type sets.</p>
<p>With this, checking if a type set is empty is in general as hard as checking if
an arbitrary boolean formula in CNF has no solution. As described above, that
is NP-complete.</p>
<p>Even worse, we want to define which operations are allowed on a type parameter
by saying that it is allowed if every type in a type set supports it. However,
<a href="https://github.com/golang/go/issues/45346#issuecomment-822330394">that check is also NP-complete</a>.</p>
<p>The easy way to prove that is to observe that if a type set is empty, <em>every
operator</em> should be allowed on a type parameter constrained by it. Because any
statement about “every element of the empty set“ is true<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>.</p>
<p>But this would mean that type-checking a generic function would be NP-complete.
If an operator is used, we have to at least check if the type set of its
constraint is empty. Which is NP-complete.</p>
<h2 id="why-do-we-care">Why do we care?</h2>
<p>A fair question is “why do we even care? Surely these cases are super exotic.
In any real program, checking this is trivial”.</p>
<p>That&rsquo;s true, but there are still reasons to care:</p>
<ul>
<li>
<p>Go has the goal of having a fast compiler. And importantly, one which is
guaranteed to be fast <em>for any program</em>. If I give you a Go program, you can
be reasonably sure that it compiles quickly, in a time frame predictable by
the size of the input.</p>
<p>If I <em>can</em> craft a program which compiles slowly - and may take longer than
the lifetime of the universe - this is no longer true.</p>
<p>This is especially important for environments like the Go playground, which
regularly compiles untrusted code.</p>
</li>
<li>
<p>NP complete problems are notoriously hard to debug if they fail.</p>
<p>If you use Linux, you might have occasionally run into a problem where you
accidentally tried installing conflicting versions of some package. And if
so, you might have noticed that your computer first chugged along for a while
and then gave you an unhelpful error message about the conflict. And maybe
you had trouble figuring out which packages declared the conflicting
dependencies.</p>
<p>This is typical for NP complete problems. As an exact solution is often too
hard to compute, they rely on heuristics and randomization and it&rsquo;s hard to
work backwards from a failure.</p>
</li>
<li>
<p>We generally don&rsquo;t want the correctness of a Go program to depend on the
compiler used. That is, a program should not suddenly stop compiling because
you used a different compiler or the compiler was updated to a new Go
version.</p>
<p>But NP-complete problems don&rsquo;t allow us to calculate an exact solution. They
always need some heuristic (even if it is just “give up after a bit”). If we
don&rsquo;t want the correctness of a program to be implementation defined, that
heuristic must become part of the Go language specification. But these
heuristics are very complex to describe. So we would have to spend a lot of
room in the spec for something which does not give us a very large benefit.</p>
</li>
</ul>
<p>Note that Go also decided to restrict the version constraints a <code>go.mod</code> file
can express, <a href="https://research.swtch.com/version-sat">for exactly the same reasons</a>.
Go has a clear priority, not to require too complicated algorithms in its
compilers and tooling. Not because they are hard to implement, but because the
behavior of complicated algorithms also tends to be hard to understand for
humans.</p>
<p>So requiring to solve an NP-complete problem is out of the question.</p>
<h2 id="the-fix">The fix</h2>
<p>Given that there must not be an NP-complete problem in the language
specification and given that Go 1.18 was released, this problem must have
somehow been solved.</p>
<p>What changed is that the language for describing interfaces was limited from
what I described above. <a href="https://go.dev/ref/spec#General_interfaces">Specifically</a></p>
<blockquote>
<p>Implementation restriction: A union (with more than one term) cannot contain
the predeclared identifier <code>comparable</code> or interfaces that specify methods, or
embed <code>comparable</code> or interfaces that specify methods.</p>
</blockquote>
<p>This disallows the main mechanism we used to map formulas to interfaces above.
We can no longer express our <code>TertiumNonDatur</code> type, or the individual <code>|</code>
terms of the formula, as the respective terms specify methods. Without
specifying methods, we can&rsquo;t get our “implicit negation” to work either.</p>
<p>The hope is that this change (among a couple of others) is sufficient to ensure
that we can always calculate type sets accurately. Which means I pulled a bit
of a bait-and-switch: I said that calculating type sets is hard. But as they
were actually released, they <em>might not be</em>.</p>
<p>The reason I wrote this blog post anyways is to explain the <em>kind of problems</em>
that exist in this area. It is easy to say we have solved this problem
<a href="https://www.youtube.com/watch?v=0SYpUSjSgFg">once and for all</a>.</p>
<p>But to be certain, someone should <em>prove</em> this - either by writing a proof that
the problem is still hard or by writing an algorithm which solves it
efficiently.</p>
<p>There are also still discussions about changing the generics design. As one
example, the limitations we introduced to fix all of this made
<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#interface-types-in-union-elements">one of the use cases from the design doc</a>
impossible to express. We might want to tweak the design to allow this use
case. We have to look out in these discussions, so we don&rsquo;t
re-introduce NP-completeness. It took us some time to even detect it
<a href="https://github.com/golang/go/issues/45346">when the union operator was proposed</a>.</p>
<p>And there are other kinds of “implicit negations” in the Go language. For
example, a <code>struct</code> can not have both a field <em>and</em> a method with the same
name. Or being one type implies not being another type (so <code>interface{int}</code>
implicitly negates <code>interface{string}</code>).</p>
<p>All of which is to say that even if the problem might no longer be
NP-complete - I hope that I convinced you it is still more complicated than you
might have thought.</p>
<p>If you want to discuss this further, you can find links to my social media on
the bottom of this site.</p>
<hr>
<p>I want to thank my beta-readers for helping me improve this article.
Namely
<a href="https://github.com/arnehormann">arnehormann</a>,
<a href="https://twitter.com/johanbrandhorst">@johanbrandhorst</a>,
<a href="https://twitter.com/mvdan_">@mvdan_</a>,
<a href="https://twitter.com/_myitcv">@_myitcv</a>,
<a href="https://mobile.twitter.com/readcodesing">@readcodesing</a>,
<a href="https://twitter.com/rogpeppe">@rogpeppe</a> and
<a href="https://twitter.com/zekjur">@zekjur</a>.</p>
<p>They took a frankly unreasonable chunk of time out of their day. And their
suggestions were invaluable.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>It should be pointed out, though, that “polynomial” can still be
extremely inefficient. \(n^{1000}\) still grows extremely fast, but is
polynomial. And for many practical problems, even \(n^3\) is
intolerably slow. But for complicated reasons, there is a qualitatively
important difference between “polynomial” and “exponential”<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> run time. So
you just have to trust me that the distinction makes sense.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>These names might seem strange, by the way. P is easy to explain: It
stands for “polynomial”.</p>
<p>NP doesn&rsquo;t mean “not polynomial” though. It means “non-deterministic
polynomial”. A non-deterministic computer, in this context, is a
hypothetical machine which can run arbitrarily many computations
simultaneously. A program which can be <em>verified</em> efficiently by any
computer can be <em>solved</em> efficiently by a non-deterministic one. It just
tries out all possible solutions at the same time and returns a correct
one.</p>
<p>Thus, being able to verify a problem on a normal computer means being
able to solve it on a non-deterministic one. That is why the two
definitions of NP “verifiable by a classical computer” and “solvable by a
non-deterministic computer” mean the same thing.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>You might complain that it is hard to remember if the “disjunctive normal
form” is a disjunction of conjunctions, or a conjunction of disjunctions -
and that no one can remember which of these means <code>&amp;&amp;</code> and which means <code>||</code>
anyways.</p>
<p>You would be correct.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>You might wonder why we can&rsquo;t just solve CNFSAT by transforming the formula
into DNF and solving that.</p>
<p>The answer is that the transformation can make the formula exponentially
larger. So even though solving the problem on DNF is linear in the size the
DNF formula, that size is <em>exponential</em> in the size of the CNF formula. So
we still use exponential time in the size of the CNF formula.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>This is called <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">the principle of explosion</a>
or “ex falso quodlibet” (“from falsehoold follows anything”).</p>
<p>Many people - including many first year math students - have anxieties and
confusion around this principle and feel that it makes no sense. So I have
little hope that I can make it palatable to you. But it is extremely
important for mathematics to “work” and it really <em>is</em> the most reasonable
way to set things up.</p>
<p>Sorry.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Yes, I know that there are complexity classes between polynomial and
exponential. Allow me the simplification.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry></feed>