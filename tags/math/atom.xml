<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">math on Mero's Blog</title><link href="https://blog.merovius.de/tags/math/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/tags/math/atom.xml"/><updated>2022-04-06T10:35:35+00:00</updated><id>https://blog.merovius.de/tags/math/</id><author><name>Axel Wagner</name></author><entry><title type="html">Monads are just monoids in the category of endofunctors</title><link href="https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/08/monads-are-just-monoids.html</id><published>2018-01-08T00:30:00+00:00</published><updated>2018-01-08T00:30:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory.</strong></p>
<p>There is a running gag in the programming community, that newcomers will often
be confused by the concept of monads (which is how sequential computations are
modeled in purely functional languages) and getting the explanation &ldquo;it is
simple, really: Monads are just monoids in the category of endofunctors&rdquo;. This
is not meant as an actual explanation, but rather to poke a bit of fun at the
habit of functional programmers to give quite abstract and theoretical
explanations at times, that are not all that helpful.</p>
<p>However, given my background in mathematics, I decided that I wanted to
actually approach Haskell from this point of view: I am interested in how it
uses math to model programming and also to, after several years of doing mostly
engineering focused programming work, flex my math muscles again</p>
<ul>
<li>as there is quite a bit of interesting math behind these concepts.</li>
</ul>
<p>The quote is from a pretty popular <a href="http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf">book about category
theory</a> and is, in full:</p>
<blockquote>
<p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p>
</blockquote>
<p>This, of course, is an explanation of the <em>mathematical</em> concept of monads,
not meant for programmers. Most explanations of the quote that I found either
assumed quite a bit of knowledge in Haskell or took a lot of liberties with the
mathematical concepts (and relied a lot on &ldquo;squinting&rdquo;) or both. This write up
is my attempt, to walk through all the concepts needed to explain monads as a
mathematical concept and how it relates to Haskell - with as little squinting
as possible.</p>
<p>Of course, there are a couple of disclaimers, I should start with:</p>
<ol>
<li>This is not the best way to understand what monads are, if you are actually
interested in using them to program. In fact, it is literally the worst way.
I would recommend <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">this intro</a>,
which takes a much more practical approach.</li>
<li>This is not the best way to understand how category theory works, if you are
actually interested in learning mathematics. In fact, it is literally the
worst way. I would recommend <a href="http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf">the book the quote is from</a>,
it&rsquo;s quite good (but assumes a math audience).</li>
<li>I haven&rsquo;t done mathematics in years. I also don&rsquo;t know much Haskell either.
So I might be getting a bunch of stuff wrong to varying degrees. I&rsquo;m sure I
will hear all about it :)</li>
<li>Even if I would <em>understand</em> everything correctly, there are still a lot of
details, mostly of technical nature, I had to omit, to keep this &ldquo;short&rdquo;.
Not that it is short.</li>
</ol>
<p>Originally, I intended this to be the ultimate explanation, which would teach
Haskellers category theory, mathematicians Haskell and people who know neither
both. Unsurprisingly, this is not what this is, at all. It ended up mostly a
write up to assure myself that I understood the path myself. If anything, you
can treat this as a kind of &ldquo;reading companion&rdquo;: If you want to understand this
topic of the intersection between category theory and functional programming,
this post can lead you through the correct terms to search for and give you a
good idea what to focus on, in the respective Wikipedia articles.</p>
<p>With all that out of the way, let&rsquo;s begin.</p>
<h2 id="categories">Categories</h2>
<p>In mathematics, a category is (roughly) a collection of objects and a
collection of arrows between them. There is not a lot of meaning behind these,
but it will probably help you to think of objects as sets and arrows as
mappings.  Every arrow goes from an object (the <em>domain</em>) to an object (the
<em>codomain</em>) and we write an arrow as \(f:X\to Y\), where \(f\) is the name
of the arrow, \(X\) is the domain and \(Y\) is the codomain. Just like with
mappings, there can be many arrows between any given pair of objects - or there
may be none.</p>
<p>We do need <em>some</em> restrictions: First, we require a specific <em>identity</em> arrow
\(\mathrm{id}:X\to X\) attached to every object \(X\), which has \(X\) as
both domain and codomain. Secondly, we require (some) arrows to be
<em>composable</em>. That is if we have two arrows \(f:X\to Y,g:Y\to Z\) - so,
whenever the domain of \(g\) is the codomain of \(f\) - there should also
be a composed arrow<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
\(g\circ f: X\to Z\), that shares the domain with \(f\) and the codomain with
\(g\).</p>
<p>Furthermore, the identity arrows must act as a <em>unit</em> for composition, that is,
for every arrow \(f\) we require \(\mathrm{id}\circ f = f = f
\circ\mathrm{id}\). We also require composition to be <em>associative</em>, that is
\((f\circ g)\circ h = f\circ(g\circ h)\) (whenever all compositions exist)<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>When we talk about a category, we often draw diagrams like this:</p>
<div>
\[
\require{AMScd}
\begin{CD}
X       @>{f}>> Y       \\
@V{g}VV         @VV{p}V \\
Z       @>>{q}> W       \\
\end{CD}
\]
</div>
<p>They show some of the objects and arrows from the category in a compact way.
This particular diagram indicates that there are four objects and four arrows
involved, with obvious domains and codomains. We only draw a subset of the
objects and arrows, that is interesting for the point we are trying to make -
for example, above diagram could also contain, of course, identity arrows and
compositions \(p\circ f\) and \(q\circ g\)), but we didn&rsquo;t draw them. In
a square like this, we can take two paths from \(X\) to \(W\). If these
paths are identical (that is, \(p\circ f = q\circ g\), we say that the
square <em>commutes</em>. A <em>commutative</em> diagram is a diagram, in which any square
commutes, that is, it does not matter which path we take from any object to
another. Most of the time, when we draw a diagram, we intend it to be
commutative.</p>
<p>So, to summarize, to define a mathematical category, we need to:</p>
<ol>
<li>Specify what our objects are</li>
<li>Specify what our arrows are, where each arrow starts and ends at a certain
object</li>
<li>This collection of arrows need to include an arrow \(\mathrm{id}_X\) for
every object \(X\), which starts and ends at \(X\)</li>
<li>And we need to be able to glue together arrows \(f:X\to Y\) and \(g:Y\to
Z\) to an arrow \(g\circ f: X\to Z\)</li>
</ol>
<p>In Haskell, we work on the category <strong>Hask</strong>, which consists of:</p>
<ol>
<li>The objects are <em>types</em>: <code>Int</code> is an object, <code>String</code> is an object but also
<code>Int | String</code>, <code>String -&gt; Int</code> and any other complicated type you can think
of.</li>
<li>The arrows are <em>functions</em>: <code>f :: a -&gt; b</code> is a function taking an <code>a</code> as an
input and returning a <code>b</code> and is represented by an arrow <code>f</code>, which has <code>a</code>
as its domain and <code>b</code> as its codomain.  So, for example, <code>length :: String -&gt; Int</code> would start at the type <code>String</code> and end at <code>Int</code>.</li>
<li>Haskell has a function <code>id :: a -&gt; a</code> which gives us the identity arrow
for any type <code>a</code>.</li>
<li>We can compose functions with the operator <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>. Note, that this follows the swapped notation of \(\circ\), where
the input type of the left function is the output type of the right function.</li>
</ol>
<p>In general, category theory is concerned with the <em>relationship between</em>
categories, whereas in functional programming, we usually only deal with this
one category. This turns out to be both a blessing and a curse: It means that
our object of study is much simpler, but it also means, that it is sometimes
hard to see how to apply the general concepts to the limited environment of
functional programming.</p>
<h2 id="monoids">Monoids</h2>
<p>Understanding categories puts us in the position to understand <em>monoids</em>. A
monoid is the generalized structure underlying concepts like the natural
numbers: We can <em>add</em> two natural numbers, but we can&rsquo;t (in general) <em>subtract</em>
them, as there are no negative numbers. We also have the number \(0\), which,
when added to any number, does nothing - it acts as a <em>unit</em> for addition. And
we also observe, that addition is <em>associative</em>, that is, when doing a bunch of
additions, the order we do them in doesn&rsquo;t matter.</p>
<p>The same properties also apply to other constructs. For example, if we take all
maps from a given set to itself, they can be composed and that composition is
associative and there is a unit element (the identity map).</p>
<p>This provides us with the following elements to define a monoid:</p>
<ol>
<li>A set \(M\)</li>
<li>An operation \(\star\colon M\times M\to M\), which &ldquo;adds&rdquo; together two elements to
make a new one</li>
<li>We need a special unit element \(u\in M\), which acts neutrally when added to
any other element, that is \(m\star u=m=u\star m\)</li>
<li>The operation needs to be associative, that is we always require
\(m\star(n\star k)=(m\star n)\star k\)</li>
</ol>
<p>There is another way to frame this, which is closer in line with category theory.
If we take \(1 := \{0\}\) to be a 1-element set, we can see that the
elements of \(M\) are in a one-to-one correspondence to functions \(1\to M\):
Every such function chooses an element of \(M\) (the image of \(0\)) and
every element \(m\in M\) fixes such a function, by using \(f(0) := m\).
Thus, instead of saying &ldquo;we need a special element of \(M\)&rdquo;, we can also
choose a special <em>function</em> \(\eta: 1\to M\). And instead of talking about an
&ldquo;operation&rdquo;, we can talk about a function \(\mu: M\times M\to M\). Which
means, we can define a monoid via a commutative diagram like so:</p>
<div>
\[
\begin{CD}
1 \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times 1 @>{\mathrm{id}\times\eta}>> M\times M @<{\eta\times\mathrm{id}}<< 1\times M \\
@V{\pi_1}VV                           @V{\mu}VV                             @V{\pi_2}VV \\
M         @>{\mathrm{id}}>>           M         @<{\mathrm{id}}<<           M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M\times M @>{\mu\times\mathrm{id}}>> M\times M \\
@V{\mathrm{id}\times\mu}VV                   @V{\mu}VV \\
M\times M         @>{\mu}>>                  M \\
\end{CD}
\]
</div>
<p>\(\pi_1\) and \(\pi_2\) here, are the functions that project to the first
or second component of a cross product respectively (that is \(\pi_1(a, b) :=
a, \pi_2(a, b) := b\)) and e.g. \(\mathrm{id}\times\eta\) is the map that
applies \(\mathrm{id}\) to the first component of a cross-product and
\(\eta\) to the second: \(\mathrm{id}\times\eta(m, 0) = (m, \eta(0))\).</p>
<p>There are four sub-diagrams here:</p>
<ol>
<li>The first diagram just says, that we need an arrow \(\eta:1\to M\). This
chooses a unit element for us.</li>
<li>Likewise, the second diagram just says, that we need an arrow
\(\mu:M\times M\to M\). This is the operation.</li>
<li>The third diagram tells us that the chosen by \(\eta\) should be a unit
for \(\mu\). The commutativity of the left square tells us, that it should
be right-neutral, that is
\[ \forall m\in M: m = \pi_1(m, 0) = \mu(\mathrm{id}\times\eta(m, 0)) = \mu(m, \eta(0)) \]
and the commutativity of the right square tells us, that it should be left-neutral, that is
\[ \forall m\in M: m = \pi_2(0,m) = \mu(\eta\times\mathrm{id}(0, m)) = \mu(\eta(0), m) \]</li>
</ol>
<p>Thus, the first diagram is saying that the element chosen by \(\eta\) should
act like a unit. For example, the left square says</p>
<p>\[\pi_1(m,0) = \mu((\mathrm{id}\times\eta)(m,0)) = \mu(m,\eta(0))\]</p>
<p>Now, writing \(\mu(m,n) = m\star n\) and \(\eta(0) = u\), this is equivalent to saying \(m = u\star m\).</p>
<p>The second diagram is saying that \(\mu\) should be associative: The top arrow
combines the first two elements, the left arrow combines the second two. The right and
bottom arrows then combine the result with the remaining element respectively,
so commutativity of that square means the familiar \(m\star (n\star k) = (m\star n)\star k\).</p>
<p>Haskell has the concept of a monoid too. While it&rsquo;s not really relevant to the
discussion, it might be enlightening to see, how it&rsquo;s modeled. A monoid in
Haskell is a type-class with two (required) methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Monoid</span> a <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  mempty <span style="color:#f92672">::</span> a
</span></span><span style="display:flex;"><span>  mappend <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
</span></span></code></pre></div><p>Now, this gives us the operation (<code>mappend</code>) and the unit (<code>a</code>), but where are
the requirements of associativity and the unit acting neutrally? The Haskell
type system is unable to codify these requirements, so they are instead given
as a &ldquo;law&rdquo;, that is, any implementation of a monoid is supposed to have these
properties, to be manually checked by the programmer:</p>
<ul>
<li><code>mappend mempty x = x</code> (the unit is left-neutral)</li>
<li><code>mappend x mempty = x</code> (the unit is right-neutral)</li>
<li><code>mappend x (mappend y z) = mappend (mappend x y) z</code> (the operation is associative)</li>
</ul>
<h2 id="functors">Functors</h2>
<p>I mentioned that category theory investigates the relationship between
categories - but so far, everything we&rsquo;ve seen only happens inside a single
category. Functors are, how we relate categories to each other. Given two
categories \(\mathcal{B}\) and \(\mathcal{C}\), a <em>functor</em>
\(F:\mathcal{B}\to \mathcal{C}\) assigns to every object \(X\) of
\(\mathcal{B}\), an object \(F(X)\) of \(\mathcal{C}\). It also assigns
to every arrow \(f:X\to Y\) in \(\mathcal{B}\) a corresponding arrow
\(F(f): F(X)\to F(Y)\) in \(\mathcal{C}\)<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. So, a functor transfers
arrows from one category to another, preserving domain and codomain. To
actually preserve the structure, we also need it to preserve the extra requirements
of a category, identities and composition. So we need, in total:</p>
<ol>
<li>An object map, \(F:O_\mathcal{B} \to O_\mathcal{C}\)</li>
<li>An arrow map, \(F:A_\mathcal{B}\to A_\mathcal{C}\), which preserves
start and end object, that is the image of an arrow \(X\to Y\) starts at
\(F(X)\) and ends at \(F(Y)\)</li>
<li>The arrow map has to preserve identities, that is \(F(\mathrm{id}_X) =
\mathrm{id}_{F(X)}\)</li>
<li>The arrow map has to preserve composition, that is \(F(g\circ f) =
F(g)\circ F(f)\).</li>
</ol>
<p>A trivial example of a functor is the <em>identity functor</em> (which we will call
\(I\)), which assigns each object to itself and each arrow to itself - that
is, it doesn&rsquo;t change the category at all.</p>
<p>A simple example is the construction of the <em>free monoid</em>, which maps from the
category of sets to the category of monoids. The Free monoid \(S^*\) on a
set \(S\) is the set of all finite length strings of elements of \(S\),
with concatenation as the operation and the empty string as the unit. Our
object map then assigns to each set \(S\) its free monoid \(S^*\). And our
arrow map assigns to each function \(f:S\to T\) the function \(f^*:S^*\to
T^*\), that applies \(f\) to each element of the input string.</p>
<p>There is an interesting side note here: Mathematicians love to abstract.
Categories arose from the observation, that in many branches of mathematics we
are researching some class of objects with some associated structure and those
maps between them, that preserve this structure. It turns out that category
theory is a branch of mathematics that is researching the objects of
categories, with some associated structure (identity arrows and composition)
and maps (functors) between them, that preserve that structure. So it seems
obvious that we should be able to view categories <em>as objects of a category</em>,
with functors as arrows. Functors can be composed (in the obvious way) and
every category has an identity functor, that just maps every object and arrow
to itself.</p>
<p>Now, in Haskell, Functors are again a type class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Functor</span> f <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  fmap <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> (f a <span style="color:#f92672">-&gt;</span> f b)
</span></span></code></pre></div><p>This looks like our arrow map: It assigns to each function <code>g :: a -&gt; b</code> a
function <code>fmap g :: f a -&gt; f b</code>. The object map is implicit: When we write <code>f a</code>,
we are referring to a new type, that depends on <code>a</code> - so we &ldquo;map&rdquo; <code>a</code> to <code>f a</code>
<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p>Again, there are additional requirements the type system of Haskell can not
capture. So we provide them as laws the programmer has to check manually:</p>
<ul>
<li><code>fmap id  ==  id</code> (preserves identities)</li>
<li><code>fmap (f . g)  ==  fmap f . fmap g</code> (preserves composition)</li>
</ul>
<p>There is one thing to note here: As mentioned, in Haskell we only really deal
with one category, the category of types. That means that a functor always maps
from the category of types to <em>itself</em>. In mathematics, we call such a functor,
that maps a category to itself, an <em>endofunctor</em>. So we can tell, that in
Haskell, every functor is automatically an endofunctor.</p>
<h2 id="natural-transformations">Natural transformations</h2>
<p>We now understand categories and we understand functors. We also understand,
that we can look at something like the category of categories. But the
definition of a monad given to us talks about the <em>category of endofunctors</em>.
So we seem to have to step up yet another level in the abstraction hierarchy
and somehow build this category. As objects, we&rsquo;d like to have endofunctors -
and arrows will be <em>natural transformations</em>, which take one functor to
another, while preserving its internal structure (the mapping of arrows). If
that sounds complicated and abstract, that&rsquo;s because it is.</p>
<p>We need two functors \(F,G:\mathcal{B}\to \mathcal{C}\) of the same &ldquo;kind&rdquo;
(that is, mapping to and from the same categories). A natural transformation
\(\eta:F\dot\to G\) assigns an arrow<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> \(\eta_X: F(X)\to G(X)\) (called
a <em>component</em> of \(\eta\)) to every object in \(\mathcal{B}\). So a component
\(\eta_X\) describes, how we can translate the action of \(F\) on \(X\)
into the action of \(G\) on \(X\) - i.e. how to translate their object maps.
We also have to talk about the translation of the arrow maps. For that, we observe
that for any arrow \(f:X\to Y\) in \(\mathcal{B}\), we get four new arrows in
\(\mathcal{C}\):</p>
<div>
\[
\begin{CD}
X       \\
@V{f}VV \\
Y       \\
\end{CD}
\hspace{1em}
\begin{CD}
F(X)        @>{\eta_X}>> G(X)       \\
@V{F(f)}VV               @VV{G(f)}V \\
F(Y)        @>>{\eta_Y}> G(Y)       \\
\end{CD}
\]
</div>
<p>For a natural transformation, we require the resulting square to commute.</p>
<p>So, to recap: To create a natural transformation, we need</p>
<ol>
<li>Two functors \(F,G:\mathcal{B}\to\mathcal{C}\)</li>
<li>For every object \(X\) in \(\mathcal{B}\), an arrow \(\eta_X: F(X)\to
G(X)\)</li>
<li>The components need to be compatible with the arrow maps of the functors:
\(\eta_Y\circ F(f) = G(f)\circ \eta_X\).</li>
</ol>
<p>In Haskell, we can define a natural transformation like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> (<span style="color:#66d9ef">Functor</span> f, <span style="color:#66d9ef">Functor</span> g) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Transformation</span> f g <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    eta <span style="color:#f92672">::</span> f a <span style="color:#f92672">-&gt;</span> g a
</span></span></code></pre></div><p><code>f</code> and <code>g</code> are functors and a natural transformation from <code>f</code> to <code>g</code> provides
a map <code>f a -&gt; g a</code> for every type <code>a</code>. Again, the requirement of compatibility
with the actions of the functors is not expressible as a type signature, but we
can require it as a law:</p>
<ul>
<li><code>eta (fmap fn a) = fmap fn (eta a)</code></li>
</ul>
<h2 id="monads">Monads</h2>
<p>This, finally, puts us in the position to define monads. Let&rsquo;s look at our quote above:</p>
<blockquote>
<p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p>
</blockquote>
<p>It should be clear, how we can <em>compose</em> endofunctors. But it is important,
that this is a different view of these things than if we&rsquo;d look at the category
of categories - there, objects are categories and functors are arrows, while
here, objects are <em>functors</em> and arrows are natural transformations. That
shows, how composition of functors can take the role of the cross-product of
sets: In a set-category, the cross product makes a new set out of two other
set. In the category of endofunctors, composition makes a new endofunctor out
of two other endofunctors.</p>
<p>When we defined monoids diagrammatically, we also needed a cross product of
mappings, that is, given a map \(f:X_1\to Y_1\) and a map \(g:X_2\to
Y_2\), we needed the map \(f\times g: X_1\times X_2\to Y_1\times
Y_2\), which operated on the individual constituents. If we want to replace
the cross product with composition of endofunctors, we need an equivalent for
natural transformations. That is, given two natural transformations
\(\eta:F\to G\) and \(\epsilon:J\to K\), we want to construct a natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This diagram
illustrates how we get there (working on components):</p>
<div>
\[
\begin{CD}
F(X)    @>{\eta_X}>>    G(X)                  @.                            \\
@V{J}VV                 @VV{J}V               @.                            \\
J(F(X)) @>{J(\eta_X)}>> J(G(X))               @>{\epsilon_{G(X)}}>> K(G(X)) \\
\end{CD}
\]
</div>
<p>As we can see, we can build an arrow \(\epsilon_{G(X)}\circ J(\eta_X):
J(F(X)) \to K(G(X))\), which we can use as the components of our natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This construction is
called the <em>horizontal composition</em> of natural transformations. We should
verify that this is indeed a natural transformation - for now, let&rsquo;s just
accept that it follows from the naturality of \(\eta\) and \(\epsilon\).</p>
<p>Lastly, there is an obvious natural transformation taking a functor to itself;
each component being just the identity arrow. We call that natural
transformation \(\iota\), staying with the convention of using Greek letters
for natural transformations.</p>
<p>With this, we can redraw the diagram we used to define monoids above, the
replacements indicated by the quotes:</p>
<div>
\[
\begin{CD}
I \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ I @>{\iota\ \eta}>> M\circ M  @<{\eta\ \iota}<< I\circ M \\
@VVV                       @V{\mu}VV                   @VVV \\
M        @>{\iota}>>       M         @<{\iota}<<       M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M\circ M @>{\mu\ \iota}>> M\circ M  \\
@V{\iota\ \mu}VV                 @V{\mu}VV \\
M\circ M        @>{\mu}>>      M         \\
\end{CD}
\]
</div>
<p>The vertical arrows in the middle diagram now simply apply the composition of
functors, using that the identity functor is a unit.</p>
<p>These diagrams encode these conditions on our natural transformations<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>:</p>
<ul>
<li>\(\mu\circ\eta\iota = \mu = \iota\eta\circ\mu\), that is \(\eta\) serves as a unit</li>
<li>\(\mu\circ\mu\iota = \mu\circ\iota\mu\), that is \(\mu\) is associative</li>
</ul>
<p>To recap, a monad, in category theory, is</p>
<ul>
<li>An endofunctor \(M\)</li>
<li>A natural transformation \(\eta: I\to M\), which serves as an identity for
horizontal composition.</li>
<li>A natural transformation \(\mu: M\circ M\to M\), which is associative in
respect to horizontal composition.</li>
</ul>
<p>Now, let&rsquo;s see, how this maps to Haskell monads.</p>
<p>First, what is the identity functor in Haskell? As we pointed out above, the
object function of functors is implicit, when we write <code>f a</code> instead of <code>a</code>. As
such, the identity functor is simply <code>a</code> - i.e. we map any type to itself.
<code>fmap</code> of that functor would thus also just be the identity
<code>fmap :: (a -&gt; a) -&gt; (a -&gt; a)</code>.</p>
<p>So, what would our natural transformation \(\eta\) look like? As we said, a
natural transformation between two functors is just a map <code>f a -&gt; g a</code>. So (if
we call our endofunctor <code>m</code>) the identity transformation of our monoid is
<code>eta :: a -&gt; m a</code>
mapping the identity functor to <code>m</code>. We also need our monoidal operation, which
should map <code>m</code> applied twice to <code>m</code>:
<code>mu :: m (m a) -&gt; m a</code>.</p>
<p>Now, Haskellers write <code>return</code> instead of <code>eta</code> and write <code>join</code> instead of
<code>mu</code>, giving us the type class<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> (<span style="color:#66d9ef">Functor</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  return <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> m a
</span></span><span style="display:flex;"><span>  join <span style="color:#f92672">::</span> m (m a) <span style="color:#f92672">-&gt;</span> m a
</span></span></code></pre></div><p>As a last note, it is worth pointing out that you usually won&rsquo;t implement
<code>join</code>, but instead a different function, called &ldquo;monadic bind&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&gt;&gt;=</span>) <span style="color:#f92672">::</span> m a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
</span></span></code></pre></div><p>The reason is, that this more closely maps to what monads are actually <em>used</em>
for in functional programming. But we can move between <code>join</code> and <code>&gt;&gt;=</code> via</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&gt;&gt;=</span>) <span style="color:#f92672">::</span> m a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v</span> <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> join ((fmap f) v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">join</span> <span style="color:#f92672">::</span> m (m a) <span style="color:#f92672">-&gt;</span> m a
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">join</span> v <span style="color:#f92672">=</span> v <span style="color:#f92672">&gt;&gt;=</span> id
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>This certainly was a bit of a long ride. It took me <em>much</em> longer than
anticipated both to understand all the steps necessary and to write them down.
I hope you found it helpful and I hope I didn&rsquo;t make too many, too glaring
mistakes. If so (either), feel free to let me know on
<a href="https://twitter.com/TheMerovius">Twitter</a>,
<a href="https://www.reddit.com/r/haskell/comments/7oudxd/monads_are_just_monoids_in_the_category_of/">reddit</a>
or <a href="https://news.ycombinator.com/item?id=16093508">Hacker News</a> - but please
remember to be kind :)</p>
<p><em>I want to thank <a href="https://twitter.com/r4dler">Tim Adler</a> and
<a href="https://twitter.com/9b17fe">mxf+</a> for proof-reading this absurdly long post
and for making many helpful suggestions for improvements</em></p>
<hr>
<p>The fact that we are not doing that is a completely justified criticism,
that is due to a historical accident - we write function application from
right to left, that is we write \(f(x)\), for applying \(f\) to \(x\).
Accordingly, we write \(g(f(x))\), when applying \(g\) to the result of
applying \(f\) to \(x\). And we chose to have the composite-notation be
consistent with <em>that</em>, instead of the arrow-notation.</p>
<p>I chose to just eat the unfortunate confusion, as it turns out Haskell is
doing exactly the same thing, so swapping things around would just increase
the confusion.</p>
<p>Sorry.</p>
<p>What was that? Oh, you thought Mathematicians where precise? Ha!</p>
<p>This is one of the things that was tripping me up for a while: I was trying to
figure out, how I would map types to other types in Haskell or even talk about
the object map. But the most useful answer is &ldquo;you don&rsquo;t&rdquo;.</p>
<script defer crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>It is often confusing to people, that the way the
arrows point in the notation and the order they are written seems to contradict
each other: When writing \(f:X\to Y\) and \(g:Y\to Z\) you might reasonably
expect their composite to work like \(f\circ g: X\to Z\), that is, you glue
together the arrows in the order you are writing them.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Keep in mind that this is a different notion from the
ones for monoids, which we come to a bit later: While the formulas seem the
same and the identities look like a unit, the difference is that only certain
arrows can be composed, not all. And that there are many identity arrows, not
just one. However, if we would have only <em>one</em> object, it would have to be the
domain and codomain of every arrow and there would be exactly one identity
arrow. In that case, the notions <em>would</em> be the same and indeed, &ldquo;a category
with exactly one object&rdquo; is yet another way to define monoids.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>It is customary, to use the same name for the object
and arrow map, even though that may seem confusing. A slight justification of
that would be, that the object map is already given by the arrow map anyway: If
\(F\) is the arrow map, we can define the object map as \(X\mapsto
\mathrm{dom}(F(\mathrm{id}_X))\). So, given that they are always occurring
together and you can make one from the other, we tend to just drop the
distinction and save some symbols.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>It is important to note, that this is not really a
<em>function</em>. Functions operate on values of a given type. But here, we are
operating on <em>types</em> and Haskell has no concept of a &ldquo;type of types&rdquo; built in
that a function could operate on. There are constructs operating on types to
construct new types, like <code>data</code>, <code>type</code>, <code>newtype</code> or even <code>deriving</code>. But
they are special syntactical constructs that exist outside of the realm of
functions.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>An important note here, is that the \(\eta_X\) are
<em>arrows</em>. Where the object map of a functor is just a general association which
could look anything we like, the components of a natural transformation need to
preserve the internal structure of the category we are working in.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>You will often see these conditions written
differently, namely written e.g. \(\mu M\) instead of \(\mu\iota\). You can
treat that as a notational shorthand, it really means the same thing.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>There is a technicality here, that Haskell also has
an intermediate between functor and monad called &ldquo;applicative&rdquo;. As I understand
it, this does not have a clear category theoretical analogue. I&rsquo;m not sure why
it exits, but I believe it has been added into the hierarchy after the fact.&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Using Hilbert Curves to 100% Zelda</title><link href="https://blog.merovius.de/posts/2017-07-22-using-hilbert-curves-to-100-zelda/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2017/07/22/using-hilbert-curves-to-100-zelda.html</id><published>2017-07-22T23:56:00+00:00</published><updated>2017-07-22T23:56:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I used Hilbert Curves to make it quicker to walk through a list of locations on a map, so I could could fully complete a video game.</strong></p>
<p>As you probably know recently the question of what <a href="https://s-media-cache-ak0.pinimg.com/originals/eb/31/e5/eb31e5c0a14d4a68ab8d492e848de608.jpg">the best Zelda
Game</a>
is was finally settled by Breath Of The Wild. Like most people I know I ended
up playing. And to keep me engaged I early on decided that I would get as close
as possible to 100% of the game before finishing it. That is I wanted to finish
all shrines, find all Korok Seeds, max out all armor and do all quests before
killing Ganon. I recently finished that and finally killed Ganon. Predictably,
I was in for a disappointment:</p>
<p><img loading="lazy" src="/assets/botw_9859.jpg" alt="98.59%"  />
</p>
<p>98.59 percent! I did expect that though. The reason is that only certain things
count into the percentage as displayed; Korok Seeds are one of them, Shrines
are another. But it also counts landmarks and locations as shown on the map.
Each contributes 1/12% to the total.</p>
<p>So I started on the onerous task of finding the last 17 locations. I&rsquo;m not
above using help for that so I carefully scrolled through <a href="https://www.zeldadungeon.net/breath-of-the-wild-interactive-map">an online
map</a> of the
BotW universe, maticulously comparing the locations on it with the ones already
on my in-game map. Anything I haven&rsquo;t visited was marked and visited. But that
only put me to 99.58%; I was still missing 5 locations. apparently I didn&rsquo;t
compare carefully enough.</p>
<p>I needed a more systematic approach. I started to instead go through an
<a href="http://www.ign.com/wikis/the-legend-of-zelda-breath-of-the-wild/Locations_by_Region">alphabetical list of
locations</a>,
looking up each on the map and see if I already had it mapped. But that got old
<em>really</em> quickly. Alphabetical just wasn&rsquo;t a great way to organize these; I
wanted a list that I could systematically check. But I didn&rsquo;t want it
alphabetically but geographically. I didn&rsquo;t want to have to jump around the map
to try and find the next one. Which is when I realized that this would be the
perfect application for a <a href="https://en.wikipedia.org/wiki/Hilbert_curve">Hilbert curve</a>.</p>
<p>If you don&rsquo;t know (though you should really just read the Wikipedia Article),
the Hilbert curve is a space filling fractal curve, that is a continuous
bijective map from the real number line to the plane. It is iteratively
defined as the limit of finite curves that get denser and denser. One of the
most interesting properties of the curve and its finite approximations is that
points that are close on the real number line get mapped to points that are
close in the plane. So if we could extract all locations from the online map,
figure out for each what real number gets mapped to that point and order the
locations by those numbers, we&rsquo;d get a list of locations where neighbors in the
list are close to each other on the map. Presumably, that
would make for easy checking of the list: The next location should be pretty
much neighbouring the previous one and if I can&rsquo;t find a location nearby,
chances are that I didn&rsquo;t visit it yet (and I can then look it up specifically).</p>
<p><strong>[edit]</strong> Commentors on
<a href="https://www.reddit.com/r/programming/comments/6oxra8/using_hilbert_curves_to_100_zelda/dklhina/">reddit</a>
and <a href="https://news.ycombinator.com/item?id=14830691">Hacker news</a> have pointed
out correctly, that all curves satisfy the property that near point on the line
map to near points on the plane. What makes the Hilbert Curve special, is that
we work on finite approximations and with the Hilbert Curve, we don&rsquo;t have to
worry about the &ldquo;correct&rdquo; level of discrete approximation.</p>
<p>To see what that means, we can look at a zig-zag curve. Say, we split our map
into a 100000x100000 grid and move in a zig-zag, left-to-right, top-to-bottom.
Given how sparse our point-set is, this would mean that most of the rows are
empty and some of them would have only one point on them. So we wozuld have to
constantly move along the entire width of the map. On the other hand, if we
split it into a 2x2 grid, it wouldn&rsquo;t be very helpful; a lot of points would
end up in the same quadrant, which would be very large, so we wouldn&rsquo;t have won
anything. So there would have to be some fineness of the grid that&rsquo;s &ldquo;just
right&rdquo; somewhere in the middle, which we&rsquo;d need to find.</p>
<p>On the other hand with Hilbert Curves, this isn&rsquo;t a problem. That&rsquo;s because the
<em>limit</em> of the finite approximations is continuous (which isn&rsquo;t the case with
the limit of zig-zag curves). What that means, in essence, is that where a
point falls on the curve won&rsquo;t jump around a lot when we make our grid finer,
it will &ldquo;home in&rdquo; to its final location on the continuous curve. A first order
Hilbert Curve is just a zig-zag curve, so it has the same problem as the
2x2-grid zig-zag line. But as we increase it&rsquo;s order, the points will just
become more and more local, instead of requiring scanning empty space. That is
the interesting consequence of the Hilbert curve being space-filling.</p>
<p>Really, <a href="https://www.youtube.com/watch?v=3s7h2MHQtxc">this video</a> explains it
much better than I ever could (even though I find the example given there
slightly ridiculous). In the end, I mostly agree with the commentors; it
probably wouldn&rsquo;t have been too hard to find a good approximation that would
make a zig-zag curve work well. But I had Hilbert Curves ready anyway and
appreciated the opportunity to usue them.<strong>[/edit]</strong></p>
<p>The first step for this was to get a list of locations and their corresponding
positions. I was pretty sure that the online map should have that available
somehow, as it uses some Google Maps framework to draw the map. So I
looked at the network tab of the Chrome developer tools, found the URL that
loaded the landmark data, copied the request as curl and saved the output for
further massaging.</p>
<p><img loading="lazy" src="/assets/botw_curl.jpg" alt="Chrome developer tools - copy as cURL"  />
</p>
<p>The returned file turns out to not actually be JSON (that&rsquo;d be too easy, I
guess) but some kind of javascript-code which is then probably eventually
eval&rsquo;d to get the data (<strong>edit</strong>: It has been pointed out, that this is just
<a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>. I was aware that this is probably
the case, but didn&rsquo;t feel comfortable using the term, as I don&rsquo;t know enough
about it. I also didn&rsquo;t consider it very important) :</p>
<pre tabindex="0"><code>/**/jQuery31106443585752152035_1500757689075(/* json-data */)
</code></pre><p>I just removed everything but the actual JSON with my editor and ran it through
a pretty-printer, to get at it&rsquo;s actual structure. I spare you the details; it
turns out the list of locations isn&rsquo;t even simply contained in that it&rsquo;s
embedded as another string, with HTML tags, as a property (twice!).</p>
<p>So I quickly hacked together some go code to dissect the data and voil√†: Got a
list of location names with the corresponding positions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Parse</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Properties</span> []<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">Name</span>    <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;name&#34;`</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">Content</span> <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;*&#34;`</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#e6db74">`json:&#34;properties&#34;`</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#e6db74">`json:&#34;parse&#34;`</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">NewDecoder</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>).<span style="color:#a6e22e">Decode</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">data</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">Parse</span>.<span style="color:#a6e22e">Properties</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Name</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;description&#34;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Content</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">content</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;no content&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">landmarks</span> []<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Type</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Geometry</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Type</span>        <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Coordinates</span> []<span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Properties</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Type</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Id</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Link</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Src</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">NewDecoder</span>(<span style="color:#a6e22e">arrayReader</span>(<span style="color:#a6e22e">content</span>)).<span style="color:#a6e22e">Decode</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">landmarks</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">landmarks</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s: %v\n&#34;</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Properties</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">arrayReader</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSuffix</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">s</span>), <span style="color:#e6db74">&#34;,&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">MultiReader</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;[&#34;</span>), <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">s</span>), <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;]&#34;</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This bode well. Now all I needed to do was to calculate the Hilbert Curve
coordinate for each of them and I&rsquo;d have what I need. The Wikipedia Article
helpfully contains an
<a href="https://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms">implementation</a>
of the corresponding algorithm in C. <code>xy2d</code> assumes a discrete grid of n¬≤ cells
and returns an integer preimage of the given coordinates. The coordinates we have
are all floating point numbers between 0 and 2 (ish) with 5 significant digits.
I figured that 65536 should be able to represent the granularity of points well
enough, so I chose that as an n, ported the code to go, sorted the locations
accordingly and it <em>actually worked</em>!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Same stuff as before
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Slice</span>(<span style="color:#a6e22e">landmarks</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">xi</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2d</span>(<span style="color:#a6e22e">landmarks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">yi</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2d</span>(<span style="color:#a6e22e">landmarks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">xj</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2d</span>(<span style="color:#a6e22e">landmarks</span>[<span style="color:#a6e22e">j</span>].<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">yj</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f2d</span>(<span style="color:#a6e22e">landmarks</span>[<span style="color:#a6e22e">j</span>].<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">di</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">xy2d</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">16</span>, <span style="color:#a6e22e">xi</span>, <span style="color:#a6e22e">yi</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">dj</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">xy2d</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">16</span>, <span style="color:#a6e22e">xj</span>, <span style="color:#a6e22e">yj</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">di</span> &lt; <span style="color:#a6e22e">dj</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">landmarks</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s: %v\n&#34;</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Properties</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Geometry</span>.<span style="color:#a6e22e">Coordinates</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">xy2d</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">s</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">rx</span>, <span style="color:#a6e22e">ry</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">s</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rx</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">y</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">s</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ry</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">d</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span> ((<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">rx</span>) ^ <span style="color:#a6e22e">ry</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">rot</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">rx</span>, <span style="color:#a6e22e">ry</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rot</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">rx</span>, <span style="color:#a6e22e">ry</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ry</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ry</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f2d</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> int((<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the end, there was still a surprising amount of jumping around involved. I
don&rsquo;t know whether that&rsquo;s accidental (i.e. due to my code being wrong) or
inherent (that is the Hilbert curve just can&rsquo;t map this perfectly well). I
assume it&rsquo;s a bit of both. The list also contains the same landmark multiple
times. This is because things like big lakes or plains where marked multiple
times. It would be trivial to filter duplicates but I actually found them
reasonably helpfull when having to jump around.</p>
<p>There might also be better approaches than Hilbert Curves. For example, we
could view it as an instance of the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman
Problem</a> with a
couple of hundred points; it should be possible to have a good heuristic
solution for that. On the other hand, a TSP solution doesn&rsquo;t necessarily only
have short jumps, so it <em>might</em> not be that good?</p>
<p>In any case, this approach was definitely good enough for me and it&rsquo;s probably
the nerdiest thing I ever did :)</p>
<p><img loading="lazy" src="/assets/botw_1000.jpg" alt="100%"  />
</p>
]]></content></entry></feed>